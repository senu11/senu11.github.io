<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection | senu11</title><meta name="author" content="senu11"><meta name="copyright" content="senu11"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="下面分享一篇我发表在安全学术圈上的论文笔记。原文  原文标题：Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection原文作者：Huanting Wang , Guixin Ye , Zhanyong Tang , Shin Hwei Tan, Songfang Hu">
<meta property="og:type" content="article">
<meta property="og:title" content="Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection">
<meta property="og:url" content="http://example.com/2023/03/22/FUNDED/">
<meta property="og:site_name" content="senu11">
<meta property="og:description" content="下面分享一篇我发表在安全学术圈上的论文笔记。原文  原文标题：Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection原文作者：Huanting Wang , Guixin Ye , Zhanyong Tang , Shin Hwei Tan, Songfang Hu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/1.png">
<meta property="article:published_time" content="2023-03-21T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-20T07:15:41.734Z">
<meta property="article:author" content="senu11">
<meta property="article:tag" content="漏洞检测">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/1.png"><link rel="shortcut icon" href="/img/head.png"><link rel="canonical" href="http://example.com/2023/03/22/FUNDED/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"簡","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":730,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: senu11","link":"链接: ","source":"来源: senu11","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-20 15:15:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">133</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="senu11"><span class="site-name">senu11</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-21T16:00:00.000Z" title="发表于 2023-03-22 00:00:00">2023-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>下面分享一篇我发表在安全学术圈上的论文笔记。<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lCkG4_wyhTpX1qDgF9_Flg">原文</a></p>
<blockquote>
<p><em>原文标题：Combining Graph-Based Learning With Automated Data Collection for Code Vulnerability Detection</em><br><em>原文作者：Huanting Wang , Guixin Ye , Zhanyong Tang , Shin Hwei Tan, Songfang Huang, Dingyi Fang, Member, IEEE, Yansong Feng, Lizhong Bian, and Zheng Wang</em><br><em>发表期刊：IEEE Transactions on Information Forensics and Security</em><br><em>原文链接：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/9293321/">https://ieeexplore.ieee.org/document/9293321/</a></em><br><em>笔记作者：senu11@SecQuan</em><br><em>笔记小编：ourren@SecQuan</em> </p>
</blockquote>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>文章提出了一种用于构建漏洞检测模型的新型学习框架FUNDED（Flow-sensitive vUlNerability code Detection）。与将程序视为顺序序列或无类型图不同，FUNDED 学习和操作程序源代码的图形表示，其中各个语句通过关系边连接到其他语句；通过捕获程序语法、语义和流程，FUNDED 为漏洞检测提供代码表示；将概率学习和统计评估相结合，自动从开源项目中收集训练样本。该系统从程序源代码中识别函数级别的软件漏洞。使用 C、Java、Swift 和 Php 编写的程序评估 FUNDED，并将其与六个最先进的代码漏洞检测模型进行比较，FUNDED 在评估设置方面明显优于其他方法。</p>
<h1 id="2-数据集-amp-项目"><a href="#2-数据集-amp-项目" class="headerlink" title="2.数据集 &amp; 项目"></a>2.数据集 &amp; 项目</h1><p>代码：<a target="_blank" rel="noopener" href="https://github.com/HuantWang/FUNDED_NISL">https://github.com/HuantWang/FUNDED_NISL</a></p>
<p>数据集：<a target="_blank" rel="noopener" href="https://drive.google.com/drive/folders/1WFFV8uGi8oXpzYORyiqRCYyqJGiHSbZL">https://drive.google.com/drive/folders/1WFFV8uGi8oXpzYORyiqRCYyqJGiHSbZL</a></p>
<p>文章在两种类型的数据集上评估 FUNDED。在四种语言(C, Java, Php, Swift.)编写的代码样本上评估漏洞检测模型(3.1.节)，使用 C 和 Java 作为主要编程语言的项目的代码修订历史测试专家混合模型（3.2.节）。</p>
<p><img src="image-20240520151205037.png" alt="image-20240520151205037"></p>
<p>上表给出了这个数据集的详细信息，总共 150950 个函数级别的样本，源语言为 C、Java、Php 和 Swift,样本中有一半是阳性（易受攻击的）代码样本， 其为在 CWE 2019 中定义的前 5 到前 30 名的软件错误（例如，“缓冲区溢出”、“越界读/写”、“NULL 指针取消引用”）。数据集由 SARD 、NVD  和托管在 GitHub 上的开源项目构建。使用 SARD 和 NVD 提供的补丁版本作为负（无漏洞）代码示例；对于从GitHub上收集到的漏洞样本，应用相应的补丁commit来获取无漏洞版本。</p>
<p><img src="image-20240520151212792.png" alt="image-20240520151212792"></p>
<p>从上表可以看出，该数据集包括来自 GitHub 以及 SAP 和 ZVD 的总共 6713 个与漏洞相关的代码修订。在来自 GitHub 的 4369 个漏洞相关commit中，有 2071 个是通过 CVE 和 NVD 链接建立的，其余 2298 个来自 GitHub 上最受欢迎的前 1000 个项目，其中以 C 和 Java 为主要编程语言。对于后者，手动检查并标记commit以建立基本事实。SAP 和 ZVD 数据集已经包含负样本。应用相同的方法从 GitHub 获得负面commit，即保留已通过 RE(3.2.2.1节) 过滤器但通过手动检查发现与漏洞无关的代码commit。共有 13,122 个代码commit样本，其中包含与漏洞相关和无关的commit。</p>
<h1 id="3-系统架构"><a href="#3-系统架构" class="headerlink" title="3.系统架构"></a>3.系统架构</h1><p>FUNDED 由两个关键部分组成。第一个是基于 GNN 的改进模型，用于识别源代码漏洞。第二个是自动框架，从GitHub收集易受攻击的代码样本，为学习漏洞检测模型提供额外的训练数据。</p>
<h2 id="3-1-漏洞检测模型"><a href="#3-1-漏洞检测模型" class="headerlink" title="3.1.漏洞检测模型"></a>3.1.漏洞检测模型</h2><p>漏洞检测模型建立在原文提出的<strong>改进GNN</strong>之上。该模型将目标函数的源代码作为输入；然后通过组合从抽象语法树 (AST) 和程序控制和依赖图 (PCDG) 中提取的信息来构建<strong>程序图</strong>。程序结构为有向图，语句、标识符和 immediate values为节点，两个节点之间的直接关系为一条边。一对节点可能存在多种关系，使用<strong>关系图</strong>来记录每种类型的关系。关系图被编码为程序图矩阵。文章的GNN 采用程序矩阵和初始<strong>节点表示</strong>来学习嵌入，嵌入被传递到下游神经网络以进行预测。</p>
<h3 id="3-1-1-模型架构"><a href="#3-1-1-模型架构" class="headerlink" title="3.1.1.模型架构"></a>3.1.1.模型架构</h3><p><img src="image-20240520151218503.png" alt="image-20240520151218503"></p>
<p>图 3 是漏洞检测模型的工作流程，以目标程序的源代码（即函数）作为输入。使用标准编译解析器构建代码的 AST，并使用控制和数据流以及诸如令牌序列的顺序信息来扩展 AST；扩展的 AST 为有向图，其中语句、标识符、代码块或值是图节点，直接关系为边。一对节点可能存在多种关系，使用关系图来记录每种关系（总共九种关系）。关系图的节点连通性被编码为邻接矩阵。</p>
<h3 id="3-1-2-改进的GNN"><a href="#3-1-2-改进的GNN" class="headerlink" title="3.1.2.改进的GNN"></a>3.1.2.改进的GNN</h3><p>基于<a target="_blank" rel="noopener" href="https://eprints.whiterose.ac.uk/164551/12/PACT_2020.pdf">原作者团队最近的工作</a>，原文扩展了门控图神经网络 (GGNN)，对从源代码中提取的多个代码关系进行建模。扩展的 GGNN 由四个基于门控循环单元 (GRU) 的堆叠嵌入模型组成，可跨关系图合并更高程度的邻域。采用关系图的邻接矩阵和初始节点表示来学习全局嵌入向量，然后将其传递到标准的全连接网络进入softmax层分类。</p>
<h3 id="3-1-3-关系图"><a href="#3-1-3-关系图" class="headerlink" title="3.1.3.关系图"></a>3.1.3.关系图</h3><h4 id="3-1-3-1-代码预处理"><a href="#3-1-3-1-代码预处理" class="headerlink" title="3.1.3.1.代码预处理"></a>3.1.3.1.代码预处理</h4><p>使用一致的命名方案重写变量名。此步骤确保程序中的琐碎语义差异（例如变量名称的选择）不会影响token嵌入的选择。图 4(a) 显示了应用于图 1 所示示例的源代码重写。</p>
<p><img src="image-20240520151226742.png" alt="image-20240520151226742"></p>
<p><img src="image-20240520151234101.png" alt="image-20240520151234101"></p>
<h4 id="3-1-3-2-程序图"><a href="#3-1-3-2-程序图" class="headerlink" title="3.1.3.2.程序图"></a>3.1.3.2.程序图</h4><p>程序图是由包含语法节点（即编程语言语法中的非终结符，例如 if 语句或函数声明的 AST 节点）和语法token（标识符名称和常量值等终结符）的 AST（为了构建 AST，对 Java 使用 Soot，对 Swift 和 Php 使用 <a target="_blank" rel="noopener" href="https://www.antlr.org/">ANTLR</a>，对 C/C++ 使用 <a target="_blank" rel="noopener" href="https://joern.io/">Joern</a>。） 构建的。标准 AST 只有子边用于编码两个 AST 节点之间的父子关系。为了捕获额外的语法、数据和控制信息，按照 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1711.00740.pdf">Learning to represent programs with graphs</a>中描述的方法向 AST 添加了八种额外类型的边。如下所述。</p>
<p><strong>Data and control flows</strong>.将从 PCDG 提取的数据和控制路径集成到 AST。</p>
<p><strong>GuardedBy</strong>.使用 GuardedBy 边将变量的每个 AST token连接到变量的封闭保护表达式。例如，对于图 4(a) 中的 if 语句，从 d 和 free(a) 添加一条 GuardedBy 边到 !strcmp() 对应的 AST 节点。 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/3276517">这可能有助于确定操作数的错误顺序</a>。</p>
<p><strong>Jump</strong>.使用跳转边将变量与控制依赖关系连接起来。 GuardedBy 和 Jump 边允许记录发散控制流的关系。这种关系对于捕获漏洞的控制和数据流模式很重要，例如图 1 中给出的“双重释放”示例和“CWE-413：不正确的资源锁定”。</p>
<p><strong>ComputedFrom</strong>.对于每个赋值，v = expr，使用 ComputedFrom 边将 v 连接到出现在表达式 expr 中的所有变量token。该边捕获变量或缓冲区的使用位置，可用于检测“NULL 指针取消引用”等漏洞。</p>
<p><strong>NextToken</strong>.由于标准 AST 子父边不会对语法节点的子节点产生顺序，因此添加 NextToken 边以将每个语法token连接到它的后继节点。可捕获语句的操作码和操作数的顺序。此类信息对于“CWE-404：资源关闭或释放不当”等漏洞类型很有用，因为它捕获了 API 使用和释放的顺序。</p>
<p><strong>LastUse and LastLexicalUse</strong>.使用 LastUse 边连接相同变量的所有使用以捕获变量的使用，其中一个特殊情况是 if 语句中的变量，使用 LastLexicalUse 边连接此类变量。例如，对于图 4(a) 中的 if 语句，链接循环头中出现的 c 及其使用位置。通过记录上次使用变量或缓冲区的时间，这种关系有助于识别“双重释放”等漏洞。图 4(b) 显示了处理图 4(a) 中给出的代码后的增强 AST。</p>
<p><strong>第八个边呢？（没在原文瞅到）</strong></p>
<h4 id="3-1-3-3-关系图"><a href="#3-1-3-3-关系图" class="headerlink" title="3.1.3.3.关系图"></a>3.1.3.3.关系图</h4><p>将扩展 AST 的关系存储在单独的关系图中——上述九种关系（？？？）中的每一种关系图。关系图是一个有向图 G = <V, e>，它包含 AST 节点 V 和边 E，表示两个节点之间存在给定关系。使用邻接矩阵来记录每个关系图的边连接。对于每条边，还添加了相应的后向边（通过转置邻接矩阵），使边数和边类型加倍。这些后向边有助于在关系图中传播信息。</V,></p>
<h3 id="3-1-4-图节点表示"><a href="#3-1-4-图节点表示" class="headerlink" title="3.1.4.图节点表示"></a>3.1.4.图节点表示</h3><p>使用 word2vec 将每个关系图节点（例如 Stmt）和token嵌入。用于将单词和token映射到值的嵌入表和 word2vec 是根据训练代码语料库构建的，该语料库由节点类型和从训练程序收集的token组成；由于变量和函数名称以及常量值可以是任意长度，将其编码为token（即字母、符号和数字）。</p>
<p>为了捕获类型信息，将变量、常量和函数的（返回）类型的嵌入与 AST 节点名称表示连接起来，并将其传递给线性层以获得初始值图中每个节点的表示。</p>
<h3 id="3-1-5-多关系图学习"><a href="#3-1-5-多关系图学习" class="headerlink" title="3.1.5.多关系图学习"></a>3.1.5.多关系图学习</h3><p>给定邻接矩阵和初始节点嵌入，多关系 GNN 在整个关系图上生成 100 维特征的全局一维嵌入。</p>
<h4 id="3-1-5-1-邻域聚合"><a href="#3-1-5-1-邻域聚合" class="headerlink" title="3.1.5.1.邻域聚合"></a>3.1.5.1.邻域聚合</h4><p><img src="image-20240520151244168.png" alt="image-20240520151244168"></p>
<p>使用邻域聚合方案（图 5a）来更新节点嵌入。图节点 v 的 100 维嵌入向量 $h_v$ 由嵌入层通过递归聚合和转换其相邻节点的表示向量来计算。节点通过将它们的当前状态（即嵌入向量）作为消息发送给沿边的所有邻居来交换信息。在每个节点消息被聚合，然后用于更新下一个嵌入层（即下一次迭代）的关联节点表示。在重复更新节点状态的过程进行固定次数的迭代后，使用<strong>读出函数</strong>将节点状态聚合到单个嵌入向量中。</p>
<h4 id="3-1-5-2-多关系模型"><a href="#3-1-5-2-多关系模型" class="headerlink" title="3.1.5.2.多关系模型"></a>3.1.5.2.多关系模型</h4><p>与标准 GNN 不同，该模型跨多个关系图传播和聚合信息。如图 5b 所示，首先，使用可学习的、关系特定的函数通过邻域聚合来计算各个关系图的新图状态来实现这一点；然后，应用 GRU 单元来聚合和更新跨关系图的相同节点的状态。使用前向传播来更新关系图的顶点 v 的状态 $h_v^t$ 以获得新状态 $h_v^{(t+1)}$：</p>
<p><img src="image-20240520151250218.png" alt="image-20240520151250218"></p>
<p>其中$A_t$是节点u和v之间的直接边，$W_t$和GRU是可学习的参数，初始状态$h_v^0$使用word2vec创建</p>
<p>受自然语言处理中使用公路门来控制噪声传播的启发，在作者团队提出的 GGNN (也即改进GNN)中采用了layer-wise公路门：</p>
<p><img src="image-20240520151256067.png" alt></p>
<p>其中 $h_v^{(t)}$ 是第 t + 1 层的输入并获得新状态$h_v^{‘(t+1)}$ ； sigma 是一个 sigmoid 函数； · 是逐元素乘法； $W_T^{(t)}$ 和 $b_T^{(t)}$ 分别是门 $T(h_v^{(t)})$ 的权重矩阵和偏置向量。</p>
<h4 id="3-1-5-3-读出函数"><a href="#3-1-5-3-读出函数" class="headerlink" title="3.1.5.3.读出函数"></a>3.1.5.3.读出函数</h4><p>在跨多个嵌入层执行邻域聚合过程后，为每个token获得另一组嵌入。为了表示整个程序，使用读出函数连接所有邻域聚合迭代和嵌入层的图表示，以形成输出向量 $h_G$ 作为 m 关系图 $G_i$ 的全局程序表示：</p>
<p><img src="image-20240520151302913.png" alt="image-20240520151302913"></p>
<p>t=0,1,,,n,是邻域聚合迭代。给定单个节点嵌入，此读出函数生成 m 个关系图的全局嵌入。</p>
<h3 id="3-1-6-训练GGNN"><a href="#3-1-6-训练GGNN" class="headerlink" title="3.1.6.训练GGNN"></a>3.1.6.训练GGNN</h3><p>本文的 GGNN 使用来自标准漏洞数据库（ CVE 和 NVD）的训练样本和3.2.节描述的数据收集框架收集的开源代码示例进行离线训练，然后可以将学习到的模型应用于未见过的程序。</p>
<p>在分批训练样本上训练 GGNN，其中每批包含正样本和负样本。由于目标是最小化两个概率分布（预测的和实际的）之间的距离，故选择交叉熵损失作为目标函数。使用学习率为 0.001 的小批量随机梯度下降 (SGD) 和 Adam 算法。当损失小于 0.005 或达到最大 100 个训练周期时，训练终止。</p>
<h2 id="3-2-自动收集训练数据框架"><a href="#3-2-自动收集训练数据框架" class="headerlink" title="3.2.自动收集训练数据框架"></a>3.2.自动收集训练数据框架</h2><p>自动训练数据收集框架由一组专家预测模型驱动，每个专家预测模型独立预测每一次commit是否为该项目提供补丁。通过识别与漏洞相关的commit，可以通过检查补丁带来的变化来定位上一版本的哪些代码段也即函数可能导致漏洞，然后将识别出的代码段用作易受攻击的代码训练示例。</p>
<p>每个专家模型都将一组特征（表 II）作为输入，这些特征是从提交消息和提交之间的代码更改（参见表 I）中获得的，然后它预测目标代码修订是否提供漏洞补丁。所有专家模型都使用标记的训练样本进行离线训练。</p>
<p><img src="image-20240520151311309.png" alt="image-20240520151311309"></p>
<h3 id="3-2-1-专家混合模型"><a href="#3-2-1-专家混合模型" class="headerlink" title="3.2.1.专家混合模型"></a>3.2.1.专家混合模型</h3><p><img src="image-20240520151320319.png" alt="image-20240520151320319"></p>
<p>图 6 为专家混合模型的架构，由五个分类器组成：support vector machine (SVM), random forests (RF), k-nearest neighbor (KNN), logistic regression (LR) and gradient boosting (GB).<br><img src="image-20240520151326960.png" alt="image-20240520151326960"></p>
<p>表 I 为 GitHub 上托管的 Linux 内核的两个提交。第一次提交 (C1) 修复了 NULL 指针漏洞，第二次提交 (C2) 修复了性能问题但未修复漏洞。现有方法（<a target="_blank" rel="noopener" href="https://teamusec.de/pdf/conf-ccs-PerlD0AYRFA15.pdf">VCCFINDER</a> 和 <a target="_blank" rel="noopener" href="https://www.researchgate.net/profile/Asankhaya-Sharma/publication/318872391_Automated_identification_of_security_issues_from_commit_messages_and_bug_reports/links/5a7947c2a6fdcc4ffe90c684/Automated-identification-of-security-issues-from-commit-messages-and-bug-reports.pdf">ZHOU 等人</a>）可能会错误地将表 I 中的第二个修订token为漏洞相关提交，因为提交消息包含关键字“check”和“NULL”。为避免此类错误，应用共形预测 (CP) 来量化每个专家模型对提交的预测的置信度，并且仅在相信模型的结果时才考虑预测，然后使用多数表决方案来汇总剩余的预测以生成结果。</p>
<h3 id="3-2-2-专家模型的训练数据"><a href="#3-2-2-专家模型的训练数据" class="headerlink" title="3.2.2.专家模型的训练数据"></a>3.2.2.专家模型的训练数据</h3><h4 id="3-2-2-1-收集代码修改训练样本"><a href="#3-2-2-1-收集代码修改训练样本" class="headerlink" title="3.2.2.1.收集代码修改训练样本"></a>3.2.2.1.收集代码修改训练样本</h4><p>使用相同的训练数据集来训练每个专家模型。训练数据由两个来源构成，第一个是 CVE 和 NVD 报告的提交日志和补丁，第二个是从 GitHub 上托管的开源项目中提取的提交日志和补丁，例如表 I 中给出的示例。</p>
<p>CVE 和 NVD 的日志已经与已知漏洞相关联，可以直接使用。为了从 GitHub 收集数据，考虑了 1,000 个主要编程语言为 C 或 Java 的项目。应用一组从 <a target="_blank" rel="noopener" href="https://www.researchgate.net/profile/Asankhaya-Sharma/publication/318872391_Automated_identification_of_security_issues_from_commit_messages_and_bug_reports/links/5a7947c2a6fdcc4ffe90c684/Automated-identification-of-security-issues-from-commit-messages-and-bug-reports.pdf">Automated identification of security issues from commit messages and bug reports,</a>扩展而来的正则表达式 (RE) 规则来选择可能与漏洞相关的提交。</p>
<p>为了简化提取漏洞代码示例的过程，<strong>当前的实现仅考虑一次修改一个源文件</strong>的代码修订。收集初始代码修订样本后，手动确定代码提交中报告的漏洞是否已在 CVE 中发布,若在则使用 CVE 编号与公开的 CVE 描述建立链接；否则，手动提取包含漏洞的代码段、提交日志和问题报告（如果有）。手动标记所有通过 RE 规则的代码修改是否与漏洞相关。然后使用标记的样本作为训练数据。使用了超过 3,000 个手动标记的代码提交来训练专家模型。这个人工检查过程只需要执行一次来训练模型，学习到的模型可以用来收集更多的样本。</p>
<h4 id="3-2-2-2-特征提取"><a href="#3-2-2-2-特征提取" class="headerlink" title="3.2.2.2.特征提取"></a>3.2.2.2.特征提取</h4><p>使用表 II 中给出的三种类型的特征来捕获开源项目的质量和代码提交的目的。提交消息描述了代码修改的原因——是否与漏洞修复相关，以及漏洞类型。</p>
<p>使用预训练的 word2vec 网络，将提交消息和修改后的代码语句映射到嵌入向量中。生成的嵌入与项目质量和活动的特征值放在一起形成聚合特征向量。</p>
<h3 id="3-2-3-专家模型训练"><a href="#3-2-3-专家模型训练" class="headerlink" title="3.2.3.专家模型训练"></a>3.2.3.专家模型训练</h3><h4 id="3-2-3-1-训练每个专家模型"><a href="#3-2-3-1-训练每个专家模型" class="headerlink" title="3.2.3.1.训练每个专家模型"></a>3.2.3.1.训练每个专家模型</h4><p>训练数据用于确定每个专家模型的最佳超参数。每个训练样本都包含一个数值特征向量和一个标签，该标签指示代码修订样本是否用于修复代码漏洞。对于训练，只需为专家模型提供训练数据，它就会执行其内部监督学习算法。</p>
<h4 id="3-2-3-2-置信度评估"><a href="#3-2-3-2-置信度评估" class="headerlink" title="3.2.3.2.置信度评估"></a>3.2.3.2.置信度评估</h4><p>应用 CP 来捕获输入 x 的类标签 y（即是否与漏洞相关或不相关）的“奇怪性”（称为不合格度量），通过使用特定于模型的不合格函数 A(x, y, h) , 来估计模型 h 的不合格分数来实现,为  <a target="_blank" rel="noopener" href="https://hal.inria.fr/hal-01459631/document">PyCP</a> 中给出的默认特定方法的不合格函数。直观上，专家模型定义的特征空间上的异常模式将比更常见的模式获得更大的不合格分数。</p>
<p>为了计算统计置信度，预留了 10% 的模型训练数据作为校准集（不用于训练专家模型）。离线计算校准分数 $a<em>1^{y^{p}}$,$a_2^{y^{p}}$ ,…,$a_n^{y^{p}}$ ，方法是通过模型 h 为每个类别标签y给出的概率 ($y^p$) 将函数 A 应用于校准集中的 n 个实例中的每一个。给定一个新输入 $x</em>{n+1}$，使用函数 A 计算一致性分数 $a<em>{n+1}^{y^{p}}$,然后计算 p 值 pv,对于$x</em>{n+1}$ ：</p>
<p><img src="image-20240520151334398.png" alt></p>
<p>若 p 值较小（接近其下限 1/(n + 1)），则预测非常不合格（离群值）。如果它很大（接近其上限 1），则预测非常符合。如果预测的 p 值大于 1 − c (c 是一个可配置的显着水平,本文根据经验设置为 0.3）)，只考虑预测。</p>
<h3 id="3-2-4-专家模型应用"><a href="#3-2-4-专家模型应用" class="headerlink" title="3.2.4.专家模型应用"></a>3.2.4.专家模型应用</h3><p><img src="image-20240520151340469.png" alt="image-20240520151340469"></p>
<p>图 7 描述了收集和标记开源代码样本的过程。首先，使用GitHub API 自动爬取排名靠前项目的代码提交；然后应用 RE 规则来选择可能与漏洞相关的代码提交；</p>
<p>1.标记代码提交</p>
<p>首先应用离线训练的专家模型来预测通过 RE 过滤器的代码修订是否与代码漏洞修复相关；再使用特征提取器来处理收集到的代码提交日志、补丁和项目相关信息，以形成特征向量；然后给定特征值，每个专家模型预测代码修订是否与漏洞修复相关。为了在多个分类器（专家模型）之间达成共识，应用 CP 来估计每个专家输出的不合格分数，保留不合格分数高于置信水平的输出；然后根据对剩余输出的简单多数投票做出最终共识。</p>
<p>2.提取代码样本</p>
<p>对于通过 RE 过滤器的每个代码提交，使用代码更改来定位修补函数的先前版本,然后提取这个函数的代码，并将其与专家模型(作者在原文中将上述一组专家模型称为专家委员会)给出是否存在漏洞的标签相关联。</p>
<p>3.持续学习</p>
<p>使用 CP 的优势之一是可以用可信度较低的样本来随着时间的推移改进专家模型。</p>
<h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4.实验"></a>4.实验</h1><p>对于漏洞检测，将 FUNDED 与六种相关方法进行比较：<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1801.01681.pdf?source=post_page---------------------------">VULDEEPECKER</a>、<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2001.02334.pdf">μVULDEEPECKER</a>、<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/8906156/footnotes#footnotes">LIN 等</a>、 <a target="_blank" rel="noopener" href="http://prl.korea.ac.kr/~pronto/home/papers/snp17-KiWoLeOh.pdf">VUDDY</a>、 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/3276517">DEEPBUGS</a> 和  <a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper/2019/file/49265d2447bc3bbfe9e76306ce40a31f-Paper.pdf">DEVIGN</a>；前三个建立在 BiLSTM 之上，VUDDY 使用散列函数来发现易受攻击的代码克隆，DEEPBUGS 利用前馈神经网络进行错误检测，DEVIGN 使用标准 GNN 在具有非类型化 AST 边缘的图形表示上运行。除了 μVULDEEPECKER 之外，所有竞争方案都做出二元决策来预测代码是否包含错误或漏洞。</p>
<p>使用五重交叉验证来评估各自数据集上的所有方法(除非另有说明),该标准方法评估预测模型的泛化能力。另外四个常见指标：Accuracy、Precision、Recall、F1 score</p>
<p><img src="image-20240520151348891.png" alt="image-20240520151348891"></p>
<p><img src="image-20240520151354792.png" alt="image-20240520151354792"></p>
<p><img src="image-20240520151402849.png" alt="image-20240520151402849"></p>
<p>除了好看的之外，在 FFmpeg、ImageMagick 和 Linux 内核中各有一个 FUNDED 未能检测到但可以被其他人识别的漏洞，这种漏洞是由滥用 API 参数引起的，FUNDED 使用的 word2vec 模型不会捕获此类模式，这个问题可以通过使用更好的语言嵌入模型来解决。</p>
<p><img src="image-20240520151410780.png" alt="image-20240520151410780"></p>
<p><img src="image-20240520151418055.png" alt="image-20240520151418055"></p>
<p>在这个实验中，首先为一种语言训练一个基线模型;然后，应用迁移学习，使用交叉验证将基线模型移植到另一种语言：C to Java、Java to Php , C to Swift，其中第一个是基线模型训练的语言，第二个是要定位的新语言。下图表明，FUNDED 可以更好地利用先验知识来检测新编程语言的软件漏洞，这是因为 FUNDED 捕获了易受攻击代码模式的大部分与语言无关的信息，此功能对于训练样本稀缺的语言或库很有用。</p>
<p><img src="image-20240520151426781.png" alt="image-20240520151426781"></p>
<p>下图为数据收集框架评估</p>
<p><img src="image-20240520151437138.png" alt="image-20240520151437138"></p>
<p>基线模型额外的比较<br><img src="image-20240520151445833.png" alt="image-20240520151445833"></p>
<p>数据标记模型的实验</p>
<p><img src="image-20240520151452988.png" alt="image-20240520151452988"></p>
<p>漏洞类型预测准确度前三：<br><img src="image-20240520151459852.png" alt="image-20240520151459852"></p>
<p>扩展AST的比较<br><img src="image-20240520151506829.png" alt="image-20240520151506829"></p>
<p>嵌入比较</p>
<p><img src="image-20240520151512769.png" alt="image-20240520151512769"></p>
<p>训练开销比较</p>
<p><img src="image-20240520151525247.png" alt="image-20240520151525247"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">senu11</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/22/FUNDED/">http://example.com/2023/03/22/FUNDED/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">senu11</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/">漏洞检测</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/20/SySeVR/" title="SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities"><img class="cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/18/SeqTrans/" title="SeqTrans: Automatic Vulnerability Fix via Sequence to Sequence Learning"><img class="cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SeqTrans: Automatic Vulnerability Fix via Sequence to Sequence Learning</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/20/SySeVR/" title="SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities</div></div></a></div><div><a href="/2023/03/16/VulDeePecker/" title="VulDeePecker: A Deep Learning-Based System for Vulnerability Detection"><img class="cover" src="/img/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">VulDeePecker: A Deep Learning-Based System for Vulnerability Detection</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%9B%86-amp-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">2.数据集 &amp; 项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3.系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.漏洞检测模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1.模型架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%94%B9%E8%BF%9B%E7%9A%84GNN"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2.改进的GNN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3.关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-%E4%BB%A3%E7%A0%81%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">3.1.3.1.代码预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-2-%E7%A8%8B%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">3.1.3.2.程序图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-3-%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">3.1.3.3.关系图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%9B%BE%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4.图节点表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E5%A4%9A%E5%85%B3%E7%B3%BB%E5%9B%BE%E5%AD%A6%E4%B9%A0"><span class="toc-number">3.1.5.</span> <span class="toc-text">3.1.5.多关系图学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-1-%E9%82%BB%E5%9F%9F%E8%81%9A%E5%90%88"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">3.1.5.1.邻域聚合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-2-%E5%A4%9A%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">3.1.5.2.多关系模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-3-%E8%AF%BB%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">3.1.5.3.读出函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-%E8%AE%AD%E7%BB%83GGNN"><span class="toc-number">3.1.6.</span> <span class="toc-text">3.1.6.训练GGNN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%87%AA%E5%8A%A8%E6%94%B6%E9%9B%86%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.自动收集训练数据框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E4%B8%93%E5%AE%B6%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1.专家混合模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E4%B8%93%E5%AE%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2.专家模型的训练数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-1-%E6%94%B6%E9%9B%86%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">3.2.2.1.收集代码修改训练样本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-2-%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">3.2.2.2.特征提取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E4%B8%93%E5%AE%B6%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3.专家模型训练</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-1-%E8%AE%AD%E7%BB%83%E6%AF%8F%E4%B8%AA%E4%B8%93%E5%AE%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">3.2.3.1.训练每个专家模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-2-%E7%BD%AE%E4%BF%A1%E5%BA%A6%E8%AF%84%E4%BC%B0"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">3.2.3.2.置信度评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E4%B8%93%E5%AE%B6%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4.专家模型应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.</span> <span class="toc-text">4.实验</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>